[
	{
		"filePath": "/app/ambient.d.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-empty-object-type",
				"severity": 2,
				"message": "An empty interface declaration allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowInterfaces' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.",
				"line": 6,
				"column": 13,
				"nodeType": "Identifier",
				"messageId": "noEmptyInterface",
				"endLine": 6,
				"endColumn": 19,
				"suggestions": [
					{
						"messageId": "replaceEmptyInterface",
						"data": { "replacement": "object" },
						"fix": { "range": [101, 163], "text": "type Locals = object" },
						"desc": "Replace empty interface with `object`."
					},
					{
						"messageId": "replaceEmptyInterface",
						"data": { "replacement": "unknown" },
						"fix": { "range": [101, 163], "text": "type Locals = unknown" },
						"desc": "Replace empty interface with `unknown`."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/// <reference types=\"@sveltejs/kit\" />\n\ndeclare global {\n\tnamespace App {\n\t\t// interface Error {}\n\t\tinterface Locals {\n\t\t\t// Add any local properties you need\n\t\t}\n\t\t// interface PageData {}\n\t\t// interface PageState {}\n\t\t// interface Platform {}\n\t}\n}\n\nexport {};\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/public/sw.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/public/workbox-f1770938.js",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 4,
				"column": 3,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 4,
				"endColumn": 46
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'_t' is defined but never used.",
				"line": 5,
				"column": 11,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 5,
				"endColumn": 13
			},
			{
				"ruleId": "no-empty",
				"severity": 2,
				"message": "Empty block statement.",
				"line": 5,
				"column": 15,
				"nodeType": "BlockStatement",
				"messageId": "unexpected",
				"endLine": 5,
				"endColumn": 17,
				"suggestions": [
					{
						"messageId": "suggestComment",
						"data": { "type": "block" },
						"fix": { "range": [118, 118], "text": " /* empty */ " },
						"desc": "Add comment inside empty block statement."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 18,
				"column": 3,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 18,
				"endColumn": 49
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'_t' is defined but never used.",
				"line": 19,
				"column": 11,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 19,
				"endColumn": 13
			},
			{
				"ruleId": "no-empty",
				"severity": 2,
				"message": "Empty block statement.",
				"line": 19,
				"column": 15,
				"nodeType": "BlockStatement",
				"messageId": "unexpected",
				"endLine": 19,
				"endColumn": 17,
				"suggestions": [
					{
						"messageId": "suggestComment",
						"data": { "type": "block" },
						"fix": { "range": [409, 409], "text": " /* empty */ " },
						"desc": "Add comment inside empty block statement."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 55,
				"column": 5,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 55,
				"endColumn": 27
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 64,
				"column": 9,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 64,
				"endColumn": 43
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 69,
				"column": 6,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 69,
				"endColumn": 88
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 101,
				"column": 9,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 101,
				"endColumn": 39
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 133,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 133,
				"endColumn": 83
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 164,
				"column": 3,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 164,
				"endColumn": 52
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'_t' is defined but never used.",
				"line": 165,
				"column": 11,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 165,
				"endColumn": 13
			},
			{
				"ruleId": "no-empty",
				"severity": 2,
				"message": "Empty block statement.",
				"line": 165,
				"column": 15,
				"nodeType": "BlockStatement",
				"messageId": "unexpected",
				"endLine": 165,
				"endColumn": 17,
				"suggestions": [
					{
						"messageId": "suggestComment",
						"data": { "type": "block" },
						"fix": { "range": [4296, 4296], "text": " /* empty */ " },
						"desc": "Add comment inside empty block statement."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 187,
				"column": 5,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 187,
				"endColumn": 43
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 197,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 204,
				"endColumn": 26
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 367,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 370,
				"endColumn": 42
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 377,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 377,
				"endColumn": 70
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'_i' is defined but never used.",
				"line": 405,
				"column": 13,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 405,
				"endColumn": 15
			},
			{
				"ruleId": "no-empty",
				"severity": 2,
				"message": "Empty block statement.",
				"line": 405,
				"column": 17,
				"nodeType": "BlockStatement",
				"messageId": "unexpected",
				"endLine": 405,
				"endColumn": 19,
				"suggestions": [
					{
						"messageId": "suggestComment",
						"data": { "type": "block" },
						"fix": { "range": [10908, 10908], "text": " /* empty */ " },
						"desc": "Add comment inside empty block statement."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 407,
				"column": 5,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 408,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 410,
				"column": 5,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 410,
				"endColumn": 35
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 436,
				"column": 25,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 436,
				"endColumn": 73
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 491,
				"column": 10,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 493,
				"endColumn": 45
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 496,
				"column": 10,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 496,
				"endColumn": 19
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 499,
				"column": 10,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 499,
				"endColumn": 74
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 501,
				"column": 8,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 503,
				"endColumn": 40
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 520,
				"column": 8,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 520,
				"endColumn": 79
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 523,
				"column": 8,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 523,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 526,
				"column": 8,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 526,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 528,
				"column": 6,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 528,
				"endColumn": 71
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 533,
				"column": 8,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 533,
				"endColumn": 46
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 568,
				"column": 3,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 568,
				"endColumn": 52
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'_t' is defined but never used.",
				"line": 569,
				"column": 11,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 569,
				"endColumn": 13
			},
			{
				"ruleId": "no-empty",
				"severity": 2,
				"message": "Empty block statement.",
				"line": 569,
				"column": 15,
				"nodeType": "BlockStatement",
				"messageId": "unexpected",
				"endLine": 569,
				"endColumn": 17,
				"suggestions": [
					{
						"messageId": "suggestComment",
						"data": { "type": "block" },
						"fix": { "range": [15242, 15242], "text": " /* empty */ " },
						"desc": "Add comment inside empty block statement."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 577,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 577,
				"endColumn": 34
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 581,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 582,
				"endColumn": 61
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 585,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 590,
				"endColumn": 17
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 589,
				"column": 7,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 589,
				"endColumn": 90
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 595,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 595,
				"endColumn": 39
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 609,
				"column": 5,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 610,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 613,
				"column": 23,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 613,
				"endColumn": 62
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 637,
				"column": 10,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 639,
				"endColumn": 89
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 651,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 657,
				"endColumn": 25
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 666,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 666,
				"endColumn": 70
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 680,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 680,
				"endColumn": 53
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 684,
				"column": 3,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 684,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'_t' is defined but never used.",
				"line": 685,
				"column": 11,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 685,
				"endColumn": 13
			},
			{
				"ruleId": "no-empty",
				"severity": 2,
				"message": "Empty block statement.",
				"line": 685,
				"column": 15,
				"nodeType": "BlockStatement",
				"messageId": "unexpected",
				"endLine": 685,
				"endColumn": 17,
				"suggestions": [
					{
						"messageId": "suggestComment",
						"data": { "type": "block" },
						"fix": { "range": [18518, 18518], "text": " /* empty */ " },
						"desc": "Add comment inside empty block statement."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'t' is defined but never used.",
				"line": 727,
				"column": 12,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 727,
				"endColumn": 13
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 736,
				"column": 3,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 736,
				"endColumn": 52
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'_t' is defined but never used.",
				"line": 737,
				"column": 11,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 737,
				"endColumn": 13
			},
			{
				"ruleId": "no-empty",
				"severity": 2,
				"message": "Empty block statement.",
				"line": 737,
				"column": 15,
				"nodeType": "BlockStatement",
				"messageId": "unexpected",
				"endLine": 737,
				"endColumn": 17,
				"suggestions": [
					{
						"messageId": "suggestComment",
						"data": { "type": "block" },
						"fix": { "range": [20228, 20228], "text": " /* empty */ " },
						"desc": "Add comment inside empty block statement."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 756,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 772,
				"endColumn": 8
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 759,
				"column": 6,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 759,
				"endColumn": 35
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 769,
				"column": 7,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 769,
				"endColumn": 66
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 777,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 781,
				"endColumn": 18
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 799,
				"column": 8,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 799,
				"endColumn": 39
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'t' is defined but never used.",
				"line": 800,
				"column": 16,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 800,
				"endColumn": 17
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 813,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 816,
				"endColumn": 65
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 830,
				"column": 5,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 831,
				"endColumn": 83
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 846,
				"column": 5,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 847,
				"endColumn": 87
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 848,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 850,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 853,
				"column": 2,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 858,
				"endColumn": 6
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 861,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 870,
				"endColumn": 48
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 876,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 880,
				"endColumn": 21
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 885,
				"column": 5,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 885,
				"endColumn": 84
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 926,
				"column": 24,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 926,
				"endColumn": 75
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 975,
				"column": 6,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 975,
				"endColumn": 34
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 978,
				"column": 8,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 978,
				"endColumn": 61
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 983,
				"column": 7,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 983,
				"endColumn": 39
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 987,
				"column": 7,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 987,
				"endColumn": 45
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 1002,
				"column": 2,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 1163,
				"endColumn": 25
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 1010,
				"column": 6,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 1010,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 1018,
				"column": 5,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 1045,
				"endColumn": 47
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'_t' is defined but never used.",
				"line": 1032,
				"column": 16,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 1032,
				"endColumn": 18
			},
			{
				"ruleId": "no-empty",
				"severity": 2,
				"message": "Empty block statement.",
				"line": 1032,
				"column": 20,
				"nodeType": "BlockStatement",
				"messageId": "unexpected",
				"endLine": 1032,
				"endColumn": 22,
				"suggestions": [
					{
						"messageId": "suggestComment",
						"data": { "type": "block" },
						"fix": { "range": [28830, 28830], "text": " /* empty */ " },
						"desc": "Add comment inside empty block statement."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 1037,
				"column": 7,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 1037,
				"endColumn": 63
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 1065,
				"column": 34,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 1065,
				"endColumn": 80
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 1071,
				"column": 5,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 1073,
				"endColumn": 47
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 1081,
				"column": 6,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 1081,
				"endColumn": 25
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 1107,
				"column": 6,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 1107,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 1120,
				"column": 5,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 1120,
				"endColumn": 91
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 1132,
				"column": 7,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 1132,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-unused-expressions",
				"severity": 2,
				"message": "Expected an assignment or function call and instead saw an expression.",
				"line": 1155,
				"column": 4,
				"nodeType": "ExpressionStatement",
				"messageId": "unusedExpression",
				"endLine": 1161,
				"endColumn": 11
			}
		],
		"suppressedMessages": [
			{
				"ruleId": "no-func-assign",
				"severity": 2,
				"message": "'q' is a function.",
				"line": 431,
				"column": 5,
				"nodeType": "Identifier",
				"messageId": "isAFunction",
				"endLine": 431,
				"endColumn": 6,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			}
		],
		"errorCount": 85,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "define(['exports'], function (t) {\n\t'use strict';\n\ttry {\n\t\tself['workbox:core:7.0.0'] && (() => {})();\n\t} catch (_t) {}\n\tconst e = (t, ...e) => {\n\t\tlet s = t;\n\t\treturn e.length > 0 && (s += ` :: ${JSON.stringify(e)}`), s;\n\t};\n\tclass s extends Error {\n\t\tconstructor(t, s) {\n\t\t\tsuper(e(t, s));\n\t\t\tthis.name = t;\n\t\t\tthis.details = s;\n\t\t}\n\t}\n\ttry {\n\t\tself['workbox:routing:7.0.0'] && (() => {})();\n\t} catch (_t) {}\n\tconst n = (t) => (t && 'object' == typeof t ? t : { handle: t });\n\tclass r {\n\t\tconstructor(t, e, s = 'GET') {\n\t\t\tthis.handler = n(e);\n\t\t\tthis.match = t;\n\t\t\tthis.method = s;\n\t\t}\n\t\tsetCatchHandler(t) {\n\t\t\tthis.catchHandler = n(t);\n\t\t}\n\t}\n\tclass i extends r {\n\t\tconstructor(t, e, s) {\n\t\t\tsuper(\n\t\t\t\t({ url: e }) => {\n\t\t\t\t\tconst s = t.exec(e.href);\n\t\t\t\t\tif (s && (e.origin === location.origin || 0 === s.index)) return s.slice(1);\n\t\t\t\t},\n\t\t\t\te,\n\t\t\t\ts\n\t\t\t);\n\t\t}\n\t}\n\tclass a {\n\t\tconstructor() {\n\t\t\tthis.t = new Map();\n\t\t\tthis.i = new Map();\n\t\t}\n\t\tget routes() {\n\t\t\treturn this.t;\n\t\t}\n\t\taddFetchListener() {\n\t\t\tself.addEventListener('fetch', (t) => {\n\t\t\t\tconst { request: e } = t,\n\t\t\t\t\ts = this.handleRequest({ request: e, event: t });\n\t\t\t\ts && t.respondWith(s);\n\t\t\t});\n\t\t}\n\t\taddCacheListener() {\n\t\t\tself.addEventListener('message', (t) => {\n\t\t\t\tif (t.data && 'CACHE_URLS' === t.data.type) {\n\t\t\t\t\tconst { payload: e } = t.data,\n\t\t\t\t\t\ts = Promise.all(\n\t\t\t\t\t\t\te.urlsToCache.map((e) => {\n\t\t\t\t\t\t\t\t'string' == typeof e && (e = [e]);\n\t\t\t\t\t\t\t\tconst s = new Request(...e);\n\t\t\t\t\t\t\t\treturn this.handleRequest({ request: s, event: t });\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\tt.waitUntil(s), t.ports && t.ports[0] && s.then(() => t.ports[0].postMessage(!0));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\thandleRequest({ request: t, event: e }) {\n\t\t\tconst s = new URL(t.url, location.href);\n\t\t\tif (!s.protocol.startsWith('http')) return;\n\t\t\tconst n = s.origin === location.origin,\n\t\t\t\t{ params: r, route: i } = this.findMatchingRoute({\n\t\t\t\t\tevent: e,\n\t\t\t\t\trequest: t,\n\t\t\t\t\tsameOrigin: n,\n\t\t\t\t\turl: s\n\t\t\t\t});\n\t\t\tlet a = i && i.handler;\n\t\t\tconst o = t.method;\n\t\t\tif ((!a && this.i.has(o) && (a = this.i.get(o)), !a)) return;\n\t\t\tlet c;\n\t\t\ttry {\n\t\t\t\tc = a.handle({ url: s, request: t, event: e, params: r });\n\t\t\t} catch (t) {\n\t\t\t\tc = Promise.reject(t);\n\t\t\t}\n\t\t\tconst h = i && i.catchHandler;\n\t\t\treturn (\n\t\t\t\tc instanceof Promise &&\n\t\t\t\t\t(this.o || h) &&\n\t\t\t\t\t(c = c.catch(async (n) => {\n\t\t\t\t\t\tif (h)\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn await h.handle({ url: s, request: t, event: e, params: r });\n\t\t\t\t\t\t\t} catch (t) {\n\t\t\t\t\t\t\t\tt instanceof Error && (n = t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.o) return this.o.handle({ url: s, request: t, event: e });\n\t\t\t\t\t\tthrow n;\n\t\t\t\t\t})),\n\t\t\t\tc\n\t\t\t);\n\t\t}\n\t\tfindMatchingRoute({ url: t, sameOrigin: e, request: s, event: n }) {\n\t\t\tconst r = this.t.get(s.method) || [];\n\t\t\tfor (const i of r) {\n\t\t\t\tlet r;\n\t\t\t\tconst a = i.match({ url: t, sameOrigin: e, request: s, event: n });\n\t\t\t\tif (a)\n\t\t\t\t\treturn (\n\t\t\t\t\t\t(r = a),\n\t\t\t\t\t\t((Array.isArray(r) && 0 === r.length) ||\n\t\t\t\t\t\t\t(a.constructor === Object && 0 === Object.keys(a).length) ||\n\t\t\t\t\t\t\t'boolean' == typeof a) &&\n\t\t\t\t\t\t\t(r = void 0),\n\t\t\t\t\t\t{ route: i, params: r }\n\t\t\t\t\t);\n\t\t\t}\n\t\t\treturn {};\n\t\t}\n\t\tsetDefaultHandler(t, e = 'GET') {\n\t\t\tthis.i.set(e, n(t));\n\t\t}\n\t\tsetCatchHandler(t) {\n\t\t\tthis.o = n(t);\n\t\t}\n\t\tregisterRoute(t) {\n\t\t\tthis.t.has(t.method) || this.t.set(t.method, []), this.t.get(t.method).push(t);\n\t\t}\n\t\tunregisterRoute(t) {\n\t\t\tif (!this.t.has(t.method))\n\t\t\t\tthrow new s('unregister-route-but-not-found-with-method', { method: t.method });\n\t\t\tconst e = this.t.get(t.method).indexOf(t);\n\t\t\tif (!(e > -1)) throw new s('unregister-route-route-not-registered');\n\t\t\tthis.t.get(t.method).splice(e, 1);\n\t\t}\n\t}\n\tlet o;\n\tconst c = () => (o || ((o = new a()), o.addFetchListener(), o.addCacheListener()), o);\n\tfunction h(t, e, n) {\n\t\tlet a;\n\t\tif ('string' == typeof t) {\n\t\t\tconst s = new URL(t, location.href);\n\t\t\ta = new r(({ url: t }) => t.href === s.href, e, n);\n\t\t} else if (t instanceof RegExp) a = new i(t, e, n);\n\t\telse if ('function' == typeof t) a = new r(t, e, n);\n\t\telse {\n\t\t\tif (!(t instanceof r))\n\t\t\t\tthrow new s('unsupported-route-type', {\n\t\t\t\t\tmoduleName: 'workbox-routing',\n\t\t\t\t\tfuncName: 'registerRoute',\n\t\t\t\t\tparamName: 'capture'\n\t\t\t\t});\n\t\t\ta = t;\n\t\t}\n\t\treturn c().registerRoute(a), a;\n\t}\n\ttry {\n\t\tself['workbox:strategies:7.0.0'] && (() => {})();\n\t} catch (_t) {}\n\tconst u = {\n\t\t\tcacheWillUpdate: async ({ response: t }) => (200 === t.status || 0 === t.status ? t : null)\n\t\t},\n\t\tl = {\n\t\t\tgoogleAnalytics: 'googleAnalytics',\n\t\t\tprecache: 'precache-v2',\n\t\t\tprefix: 'workbox',\n\t\t\truntime: 'runtime',\n\t\t\tsuffix: 'undefined' != typeof registration ? registration.scope : ''\n\t\t},\n\t\tf = (t) => [l.prefix, t, l.suffix].filter((t) => t && t.length > 0).join('-'),\n\t\tw = (t) => t || f(l.precache),\n\t\td = (t) => t || f(l.runtime);\n\tfunction p(t, e) {\n\t\tconst s = new URL(t);\n\t\tfor (const t of e) s.searchParams.delete(t);\n\t\treturn s.href;\n\t}\n\tclass y {\n\t\tconstructor() {\n\t\t\tthis.promise = new Promise((t, e) => {\n\t\t\t\t(this.resolve = t), (this.reject = e);\n\t\t\t});\n\t\t}\n\t}\n\tconst g = new Set();\n\tfunction m(t) {\n\t\treturn 'string' == typeof t ? new Request(t) : t;\n\t}\n\tclass v {\n\t\tconstructor(t, e) {\n\t\t\t(this.h = {}),\n\t\t\t\tObject.assign(this, e),\n\t\t\t\t(this.event = e.event),\n\t\t\t\t(this.u = t),\n\t\t\t\t(this.l = new y()),\n\t\t\t\t(this.p = []),\n\t\t\t\t(this.m = [...t.plugins]),\n\t\t\t\t(this.v = new Map());\n\t\t\tfor (const t of this.m) this.v.set(t, {});\n\t\t\tthis.event.waitUntil(this.l.promise);\n\t\t}\n\t\tasync fetch(t) {\n\t\t\tconst { event: e } = this;\n\t\t\tlet n = m(t);\n\t\t\tif ('navigate' === n.mode && e instanceof FetchEvent && e.preloadResponse) {\n\t\t\t\tconst t = await e.preloadResponse;\n\t\t\t\tif (t) return t;\n\t\t\t}\n\t\t\tconst r = this.hasCallback('fetchDidFail') ? n.clone() : null;\n\t\t\ttry {\n\t\t\t\tfor (const t of this.iterateCallbacks('requestWillFetch'))\n\t\t\t\t\tn = await t({ request: n.clone(), event: e });\n\t\t\t} catch (t) {\n\t\t\t\tif (t instanceof Error)\n\t\t\t\t\tthrow new s('plugin-error-request-will-fetch', { thrownErrorMessage: t.message });\n\t\t\t}\n\t\t\tconst i = n.clone();\n\t\t\ttry {\n\t\t\t\tlet t;\n\t\t\t\tt = await fetch(n, 'navigate' === n.mode ? void 0 : this.u.fetchOptions);\n\t\t\t\tfor (const s of this.iterateCallbacks('fetchDidSucceed'))\n\t\t\t\t\tt = await s({ event: e, request: i, response: t });\n\t\t\t\treturn t;\n\t\t\t} catch (t) {\n\t\t\t\tthrow (\n\t\t\t\t\t(r &&\n\t\t\t\t\t\t(await this.runCallbacks('fetchDidFail', {\n\t\t\t\t\t\t\terror: t,\n\t\t\t\t\t\t\tevent: e,\n\t\t\t\t\t\t\toriginalRequest: r.clone(),\n\t\t\t\t\t\t\trequest: i.clone()\n\t\t\t\t\t\t})),\n\t\t\t\t\tt)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tasync fetchAndCachePut(t) {\n\t\t\tconst e = await this.fetch(t),\n\t\t\t\ts = e.clone();\n\t\t\treturn this.waitUntil(this.cachePut(t, s)), e;\n\t\t}\n\t\tasync cacheMatch(t) {\n\t\t\tconst e = m(t);\n\t\t\tlet s;\n\t\t\tconst { cacheName: n, matchOptions: r } = this.u,\n\t\t\t\ti = await this.getCacheKey(e, 'read'),\n\t\t\t\ta = Object.assign(Object.assign({}, r), { cacheName: n });\n\t\t\ts = await caches.match(i, a);\n\t\t\tfor (const t of this.iterateCallbacks('cachedResponseWillBeUsed'))\n\t\t\t\ts =\n\t\t\t\t\t(await t({\n\t\t\t\t\t\tcacheName: n,\n\t\t\t\t\t\tmatchOptions: r,\n\t\t\t\t\t\tcachedResponse: s,\n\t\t\t\t\t\trequest: i,\n\t\t\t\t\t\tevent: this.event\n\t\t\t\t\t})) || void 0;\n\t\t\treturn s;\n\t\t}\n\t\tasync cachePut(t, e) {\n\t\t\tconst n = m(t);\n\t\t\tvar r;\n\t\t\tawait ((r = 0), new Promise((t) => setTimeout(t, r)));\n\t\t\tconst i = await this.getCacheKey(n, 'write');\n\t\t\tif (!e)\n\t\t\t\tthrow new s('cache-put-with-no-response', {\n\t\t\t\t\turl:\n\t\t\t\t\t\t((a = i.url),\n\t\t\t\t\t\tnew URL(String(a), location.href).href.replace(new RegExp(`^${location.origin}`), ''))\n\t\t\t\t});\n\t\t\tvar a;\n\t\t\tconst o = await this.R(e);\n\t\t\tif (!o) return !1;\n\t\t\tconst { cacheName: c, matchOptions: h } = this.u,\n\t\t\t\tu = await self.caches.open(c),\n\t\t\t\tl = this.hasCallback('cacheDidUpdate'),\n\t\t\t\tf = l\n\t\t\t\t\t? await (async function (t, e, s, n) {\n\t\t\t\t\t\t\tconst r = p(e.url, s);\n\t\t\t\t\t\t\tif (e.url === r) return t.match(e, n);\n\t\t\t\t\t\t\tconst i = Object.assign(Object.assign({}, n), { ignoreSearch: !0 }),\n\t\t\t\t\t\t\t\ta = await t.keys(e, i);\n\t\t\t\t\t\t\tfor (const e of a) if (r === p(e.url, s)) return t.match(e, n);\n\t\t\t\t\t\t})(u, i.clone(), ['__WB_REVISION__'], h)\n\t\t\t\t\t: null;\n\t\t\ttry {\n\t\t\t\tawait u.put(i, l ? o.clone() : o);\n\t\t\t} catch (t) {\n\t\t\t\tif (t instanceof Error)\n\t\t\t\t\tthrow (\n\t\t\t\t\t\t('QuotaExceededError' === t.name &&\n\t\t\t\t\t\t\t(await (async function () {\n\t\t\t\t\t\t\t\tfor (const t of g) await t();\n\t\t\t\t\t\t\t})()),\n\t\t\t\t\t\tt)\n\t\t\t\t\t);\n\t\t\t}\n\t\t\tfor (const t of this.iterateCallbacks('cacheDidUpdate'))\n\t\t\t\tawait t({\n\t\t\t\t\tcacheName: c,\n\t\t\t\t\toldResponse: f,\n\t\t\t\t\tnewResponse: o.clone(),\n\t\t\t\t\trequest: i,\n\t\t\t\t\tevent: this.event\n\t\t\t\t});\n\t\t\treturn !0;\n\t\t}\n\t\tasync getCacheKey(t, e) {\n\t\t\tconst s = `${t.url} | ${e}`;\n\t\t\tif (!this.h[s]) {\n\t\t\t\tlet n = t;\n\t\t\t\tfor (const t of this.iterateCallbacks('cacheKeyWillBeUsed'))\n\t\t\t\t\tn = m(await t({ mode: e, request: n, event: this.event, params: this.params }));\n\t\t\t\tthis.h[s] = n;\n\t\t\t}\n\t\t\treturn this.h[s];\n\t\t}\n\t\thasCallback(t) {\n\t\t\tfor (const e of this.u.plugins) if (t in e) return !0;\n\t\t\treturn !1;\n\t\t}\n\t\tasync runCallbacks(t, e) {\n\t\t\tfor (const s of this.iterateCallbacks(t)) await s(e);\n\t\t}\n\t\t*iterateCallbacks(t) {\n\t\t\tfor (const e of this.u.plugins)\n\t\t\t\tif ('function' == typeof e[t]) {\n\t\t\t\t\tconst s = this.v.get(e),\n\t\t\t\t\t\tn = (n) => {\n\t\t\t\t\t\t\tconst r = Object.assign(Object.assign({}, n), { state: s });\n\t\t\t\t\t\t\treturn e[t](r);\n\t\t\t\t\t\t};\n\t\t\t\t\tyield n;\n\t\t\t\t}\n\t\t}\n\t\twaitUntil(t) {\n\t\t\treturn this.p.push(t), t;\n\t\t}\n\t\tasync doneWaiting() {\n\t\t\tlet t;\n\t\t\tfor (; (t = this.p.shift()); ) await t;\n\t\t}\n\t\tdestroy() {\n\t\t\tthis.l.resolve(null);\n\t\t}\n\t\tasync R(t) {\n\t\t\tlet e = t,\n\t\t\t\ts = !1;\n\t\t\tfor (const t of this.iterateCallbacks('cacheWillUpdate'))\n\t\t\t\tif (\n\t\t\t\t\t((e = (await t({ request: this.request, response: e, event: this.event })) || void 0),\n\t\t\t\t\t(s = !0),\n\t\t\t\t\t!e)\n\t\t\t\t)\n\t\t\t\t\tbreak;\n\t\t\treturn s || (e && 200 !== e.status && (e = void 0)), e;\n\t\t}\n\t}\n\tclass R {\n\t\tconstructor(t = {}) {\n\t\t\t(this.cacheName = d(t.cacheName)),\n\t\t\t\t(this.plugins = t.plugins || []),\n\t\t\t\t(this.fetchOptions = t.fetchOptions),\n\t\t\t\t(this.matchOptions = t.matchOptions);\n\t\t}\n\t\thandle(t) {\n\t\t\tconst [e] = this.handleAll(t);\n\t\t\treturn e;\n\t\t}\n\t\thandleAll(t) {\n\t\t\tt instanceof FetchEvent && (t = { event: t, request: t.request });\n\t\t\tconst e = t.event,\n\t\t\t\ts = 'string' == typeof t.request ? new Request(t.request) : t.request,\n\t\t\t\tn = 'params' in t ? t.params : void 0,\n\t\t\t\tr = new v(this, { event: e, request: s, params: n }),\n\t\t\t\ti = this.q(r, s, e);\n\t\t\treturn [i, this.D(i, r, s, e)];\n\t\t}\n\t\tasync q(t, e, n) {\n\t\t\tlet r;\n\t\t\tawait t.runCallbacks('handlerWillStart', { event: n, request: e });\n\t\t\ttry {\n\t\t\t\tif (((r = await this.U(e, t)), !r || 'error' === r.type))\n\t\t\t\t\tthrow new s('no-response', { url: e.url });\n\t\t\t} catch (s) {\n\t\t\t\tif (s instanceof Error)\n\t\t\t\t\tfor (const i of t.iterateCallbacks('handlerDidError'))\n\t\t\t\t\t\tif (((r = await i({ error: s, event: n, request: e })), r)) break;\n\t\t\t\tif (!r) throw s;\n\t\t\t}\n\t\t\tfor (const s of t.iterateCallbacks('handlerWillRespond'))\n\t\t\t\tr = await s({ event: n, request: e, response: r });\n\t\t\treturn r;\n\t\t}\n\t\tasync D(t, e, s, n) {\n\t\t\tlet r, i;\n\t\t\ttry {\n\t\t\t\tr = await t;\n\t\t\t} catch (_i) {}\n\t\t\ttry {\n\t\t\t\tawait e.runCallbacks('handlerDidRespond', { event: n, request: s, response: r }),\n\t\t\t\t\tawait e.doneWaiting();\n\t\t\t} catch (t) {\n\t\t\t\tt instanceof Error && (i = t);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t(await e.runCallbacks('handlerDidComplete', {\n\t\t\t\t\tevent: n,\n\t\t\t\t\trequest: s,\n\t\t\t\t\tresponse: r,\n\t\t\t\t\terror: i\n\t\t\t\t}),\n\t\t\t\te.destroy(),\n\t\t\t\ti)\n\t\t\t)\n\t\t\t\tthrow i;\n\t\t}\n\t}\n\tfunction b(t) {\n\t\tt.then(() => {});\n\t}\n\tfunction q() {\n\t\treturn (\n\t\t\t/* eslint-disable-next-line no-func-assign */\n\t\t\t(q = Object.assign\n\t\t\t\t? Object.assign.bind()\n\t\t\t\t: function (t) {\n\t\t\t\t\t\tfor (var e = 1; e < arguments.length; e++) {\n\t\t\t\t\t\t\tvar s = arguments[e];\n\t\t\t\t\t\t\tfor (var n in s) ({}).hasOwnProperty.call(s, n) && (t[n] = s[n]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn t;\n\t\t\t\t\t}),\n\t\t\tq.apply(null, arguments)\n\t\t);\n\t}\n\tlet D, U;\n\tconst x = new WeakMap(),\n\t\tL = new WeakMap(),\n\t\tI = new WeakMap(),\n\t\tC = new WeakMap(),\n\t\tE = new WeakMap();\n\tlet N = {\n\t\tget(t, e, s) {\n\t\t\tif (t instanceof IDBTransaction) {\n\t\t\t\tif ('done' === e) return L.get(t);\n\t\t\t\tif ('objectStoreNames' === e) return t.objectStoreNames || I.get(t);\n\t\t\t\tif ('store' === e)\n\t\t\t\t\treturn s.objectStoreNames[1] ? void 0 : s.objectStore(s.objectStoreNames[0]);\n\t\t\t}\n\t\t\treturn k(t[e]);\n\t\t},\n\t\tset: (t, e, s) => ((t[e] = s), !0),\n\t\thas: (t, e) => (t instanceof IDBTransaction && ('done' === e || 'store' === e)) || e in t\n\t};\n\tfunction O(t) {\n\t\treturn t !== IDBDatabase.prototype.transaction || 'objectStoreNames' in IDBTransaction.prototype\n\t\t\t? (\n\t\t\t\t\tU ||\n\t\t\t\t\t(U = [\n\t\t\t\t\t\tIDBCursor.prototype.advance,\n\t\t\t\t\t\tIDBCursor.prototype.continue,\n\t\t\t\t\t\tIDBCursor.prototype.continuePrimaryKey\n\t\t\t\t\t])\n\t\t\t\t).includes(t)\n\t\t\t\t? function (...e) {\n\t\t\t\t\t\treturn t.apply(B(this), e), k(x.get(this));\n\t\t\t\t\t}\n\t\t\t\t: function (...e) {\n\t\t\t\t\t\treturn k(t.apply(B(this), e));\n\t\t\t\t\t}\n\t\t\t: function (e, ...s) {\n\t\t\t\t\tconst n = t.call(B(this), e, ...s);\n\t\t\t\t\treturn I.set(n, e.sort ? e.sort() : [e]), k(n);\n\t\t\t\t};\n\t}\n\tfunction T(t) {\n\t\treturn 'function' == typeof t\n\t\t\t? O(t)\n\t\t\t: (t instanceof IDBTransaction &&\n\t\t\t\t\t(function (t) {\n\t\t\t\t\t\tif (L.has(t)) return;\n\t\t\t\t\t\tconst e = new Promise((e, s) => {\n\t\t\t\t\t\t\tconst n = () => {\n\t\t\t\t\t\t\t\t\tt.removeEventListener('complete', r),\n\t\t\t\t\t\t\t\t\t\tt.removeEventListener('error', i),\n\t\t\t\t\t\t\t\t\t\tt.removeEventListener('abort', i);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tr = () => {\n\t\t\t\t\t\t\t\t\te(), n();\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ti = () => {\n\t\t\t\t\t\t\t\t\ts(t.error || new DOMException('AbortError', 'AbortError')), n();\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tt.addEventListener('complete', r),\n\t\t\t\t\t\t\t\tt.addEventListener('error', i),\n\t\t\t\t\t\t\t\tt.addEventListener('abort', i);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tL.set(t, e);\n\t\t\t\t\t})(t),\n\t\t\t\t(e = t),\n\t\t\t\t(D || (D = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])).some(\n\t\t\t\t\t(t) => e instanceof t\n\t\t\t\t)\n\t\t\t\t\t? new Proxy(t, N)\n\t\t\t\t\t: t);\n\t\tvar e;\n\t}\n\tfunction k(t) {\n\t\tif (t instanceof IDBRequest)\n\t\t\treturn (function (t) {\n\t\t\t\tconst e = new Promise((e, s) => {\n\t\t\t\t\tconst n = () => {\n\t\t\t\t\t\t\tt.removeEventListener('success', r), t.removeEventListener('error', i);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tr = () => {\n\t\t\t\t\t\t\te(k(t.result)), n();\n\t\t\t\t\t\t},\n\t\t\t\t\t\ti = () => {\n\t\t\t\t\t\t\ts(t.error), n();\n\t\t\t\t\t\t};\n\t\t\t\t\tt.addEventListener('success', r), t.addEventListener('error', i);\n\t\t\t\t});\n\t\t\t\treturn (\n\t\t\t\t\te\n\t\t\t\t\t\t.then((e) => {\n\t\t\t\t\t\t\te instanceof IDBCursor && x.set(e, t);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(() => {}),\n\t\t\t\t\tE.set(e, t),\n\t\t\t\t\te\n\t\t\t\t);\n\t\t\t})(t);\n\t\tif (C.has(t)) return C.get(t);\n\t\tconst e = T(t);\n\t\treturn e !== t && (C.set(t, e), E.set(e, t)), e;\n\t}\n\tconst B = (t) => E.get(t);\n\tconst P = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'],\n\t\tM = ['put', 'add', 'delete', 'clear'],\n\t\tW = new Map();\n\tfunction j(t, e) {\n\t\tif (!(t instanceof IDBDatabase) || e in t || 'string' != typeof e) return;\n\t\tif (W.get(e)) return W.get(e);\n\t\tconst s = e.replace(/FromIndex$/, ''),\n\t\t\tn = e !== s,\n\t\t\tr = M.includes(s);\n\t\tif (!(s in (n ? IDBIndex : IDBObjectStore).prototype) || (!r && !P.includes(s))) return;\n\t\tconst i = async function (t, ...e) {\n\t\t\tconst i = this.transaction(t, r ? 'readwrite' : 'readonly');\n\t\t\tlet a = i.store;\n\t\t\treturn n && (a = a.index(e.shift())), (await Promise.all([a[s](...e), r && i.done]))[0];\n\t\t};\n\t\treturn W.set(e, i), i;\n\t}\n\tN = ((t) =>\n\t\tq({}, t, {\n\t\t\tget: (e, s, n) => j(e, s) || t.get(e, s, n),\n\t\t\thas: (e, s) => !!j(e, s) || t.has(e, s)\n\t\t}))(N);\n\ttry {\n\t\tself['workbox:expiration:7.0.0'] && (() => {})();\n\t} catch (_t) {}\n\tconst S = 'cache-entries',\n\t\tK = (t) => {\n\t\t\tconst e = new URL(t, location.href);\n\t\t\treturn (e.hash = ''), e.href;\n\t\t};\n\tclass A {\n\t\tconstructor(t) {\n\t\t\t(this._ = null), (this.L = t);\n\t\t}\n\t\tI(t) {\n\t\t\tconst e = t.createObjectStore(S, { keyPath: 'id' });\n\t\t\te.createIndex('cacheName', 'cacheName', { unique: !1 }),\n\t\t\t\te.createIndex('timestamp', 'timestamp', { unique: !1 });\n\t\t}\n\t\tC(t) {\n\t\t\tthis.I(t),\n\t\t\t\tthis.L &&\n\t\t\t\t\t(function (t, { blocked: e } = {}) {\n\t\t\t\t\t\tconst s = indexedDB.deleteDatabase(t);\n\t\t\t\t\t\te && s.addEventListener('blocked', (t) => e(t.oldVersion, t)), k(s).then(() => {});\n\t\t\t\t\t})(this.L);\n\t\t}\n\t\tasync setTimestamp(t, e) {\n\t\t\tconst s = { url: (t = K(t)), timestamp: e, cacheName: this.L, id: this.N(t) },\n\t\t\t\tn = (await this.getDb()).transaction(S, 'readwrite', { durability: 'relaxed' });\n\t\t\tawait n.store.put(s), await n.done;\n\t\t}\n\t\tasync getTimestamp(t) {\n\t\t\tconst e = await this.getDb(),\n\t\t\t\ts = await e.get(S, this.N(t));\n\t\t\treturn null == s ? void 0 : s.timestamp;\n\t\t}\n\t\tasync expireEntries(t, e) {\n\t\t\tconst s = await this.getDb();\n\t\t\tlet n = await s.transaction(S).store.index('timestamp').openCursor(null, 'prev');\n\t\t\tconst r = [];\n\t\t\tlet i = 0;\n\t\t\tfor (; n; ) {\n\t\t\t\tconst s = n.value;\n\t\t\t\ts.cacheName === this.L && ((t && s.timestamp < t) || (e && i >= e) ? r.push(n.value) : i++),\n\t\t\t\t\t(n = await n.continue());\n\t\t\t}\n\t\t\tconst a = [];\n\t\t\tfor (const t of r) await s.delete(S, t.id), a.push(t.url);\n\t\t\treturn a;\n\t\t}\n\t\tN(t) {\n\t\t\treturn this.L + '|' + K(t);\n\t\t}\n\t\tasync getDb() {\n\t\t\treturn (\n\t\t\t\tthis._ ||\n\t\t\t\t\t(this._ = await (function (\n\t\t\t\t\t\tt,\n\t\t\t\t\t\te,\n\t\t\t\t\t\t{ blocked: s, upgrade: n, blocking: r, terminated: i } = {}\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst a = indexedDB.open(t, e),\n\t\t\t\t\t\t\to = k(a);\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\tn &&\n\t\t\t\t\t\t\t\ta.addEventListener('upgradeneeded', (t) => {\n\t\t\t\t\t\t\t\t\tn(k(a.result), t.oldVersion, t.newVersion, k(a.transaction), t);\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\ts && a.addEventListener('blocked', (t) => s(t.oldVersion, t.newVersion, t)),\n\t\t\t\t\t\t\to\n\t\t\t\t\t\t\t\t.then((t) => {\n\t\t\t\t\t\t\t\t\ti && t.addEventListener('close', () => i()),\n\t\t\t\t\t\t\t\t\t\tr &&\n\t\t\t\t\t\t\t\t\t\t\tt.addEventListener('versionchange', (t) => r(t.oldVersion, t.newVersion, t));\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.catch(() => {}),\n\t\t\t\t\t\t\to\n\t\t\t\t\t\t);\n\t\t\t\t\t})('workbox-expiration', 1, { upgrade: this.C.bind(this) })),\n\t\t\t\tthis._\n\t\t\t);\n\t\t}\n\t}\n\tclass F {\n\t\tconstructor(t, e = {}) {\n\t\t\t(this.O = !1),\n\t\t\t\t(this.T = !1),\n\t\t\t\t(this.k = e.maxEntries),\n\t\t\t\t(this.B = e.maxAgeSeconds),\n\t\t\t\t(this.P = e.matchOptions),\n\t\t\t\t(this.L = t),\n\t\t\t\t(this.M = new A(t));\n\t\t}\n\t\tasync expireEntries() {\n\t\t\tif (this.O) return void (this.T = !0);\n\t\t\tthis.O = !0;\n\t\t\tconst t = this.B ? Date.now() - 1e3 * this.B : 0,\n\t\t\t\te = await this.M.expireEntries(t, this.k),\n\t\t\t\ts = await self.caches.open(this.L);\n\t\t\tfor (const t of e) await s.delete(t, this.P);\n\t\t\t(this.O = !1), this.T && ((this.T = !1), b(this.expireEntries()));\n\t\t}\n\t\tasync updateTimestamp(t) {\n\t\t\tawait this.M.setTimestamp(t, Date.now());\n\t\t}\n\t\tasync isURLExpired(t) {\n\t\t\tif (this.B) {\n\t\t\t\tconst e = await this.M.getTimestamp(t),\n\t\t\t\t\ts = Date.now() - 1e3 * this.B;\n\t\t\t\treturn void 0 === e || e < s;\n\t\t\t}\n\t\t\treturn !1;\n\t\t}\n\t\tasync delete() {\n\t\t\t(this.T = !1), await this.M.expireEntries(1 / 0);\n\t\t}\n\t}\n\ttry {\n\t\tself['workbox:range-requests:7.0.0'] && (() => {})();\n\t} catch (_t) {}\n\tasync function H(t, e) {\n\t\ttry {\n\t\t\tif (206 === e.status) return e;\n\t\t\tconst n = t.headers.get('range');\n\t\t\tif (!n) throw new s('no-range-header');\n\t\t\tconst r = (function (t) {\n\t\t\t\t\tconst e = t.trim().toLowerCase();\n\t\t\t\t\tif (!e.startsWith('bytes='))\n\t\t\t\t\t\tthrow new s('unit-must-be-bytes', { normalizedRangeHeader: e });\n\t\t\t\t\tif (e.includes(',')) throw new s('single-range-only', { normalizedRangeHeader: e });\n\t\t\t\t\tconst n = /(\\d*)-(\\d*)/.exec(e);\n\t\t\t\t\tif (!n || (!n[1] && !n[2]))\n\t\t\t\t\t\tthrow new s('invalid-range-values', { normalizedRangeHeader: e });\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstart: '' === n[1] ? void 0 : Number(n[1]),\n\t\t\t\t\t\tend: '' === n[2] ? void 0 : Number(n[2])\n\t\t\t\t\t};\n\t\t\t\t})(n),\n\t\t\t\ti = await e.blob(),\n\t\t\t\ta = (function (t, e, n) {\n\t\t\t\t\tconst r = t.size;\n\t\t\t\t\tif ((n && n > r) || (e && e < 0))\n\t\t\t\t\t\tthrow new s('range-not-satisfiable', { size: r, end: n, start: e });\n\t\t\t\t\tlet i, a;\n\t\t\t\t\treturn (\n\t\t\t\t\t\tvoid 0 !== e && void 0 !== n\n\t\t\t\t\t\t\t? ((i = e), (a = n + 1))\n\t\t\t\t\t\t\t: void 0 !== e && void 0 === n\n\t\t\t\t\t\t\t\t? ((i = e), (a = r))\n\t\t\t\t\t\t\t\t: void 0 !== n && void 0 === e && ((i = r - n), (a = r)),\n\t\t\t\t\t\t{ start: i, end: a }\n\t\t\t\t\t);\n\t\t\t\t})(i, r.start, r.end),\n\t\t\t\to = i.slice(a.start, a.end),\n\t\t\t\tc = o.size,\n\t\t\t\th = new Response(o, { status: 206, statusText: 'Partial Content', headers: e.headers });\n\t\t\treturn (\n\t\t\t\th.headers.set('Content-Length', String(c)),\n\t\t\t\th.headers.set('Content-Range', `bytes ${a.start}-${a.end - 1}/${i.size}`),\n\t\t\t\th\n\t\t\t);\n\t\t} catch (t) {\n\t\t\treturn new Response('', { status: 416, statusText: 'Range Not Satisfiable' });\n\t\t}\n\t}\n\tfunction $(t, e) {\n\t\tconst s = e();\n\t\treturn t.waitUntil(s), s;\n\t}\n\ttry {\n\t\tself['workbox:precaching:7.0.0'] && (() => {})();\n\t} catch (_t) {}\n\tfunction z(t) {\n\t\tif (!t) throw new s('add-to-cache-list-unexpected-type', { entry: t });\n\t\tif ('string' == typeof t) {\n\t\t\tconst e = new URL(t, location.href);\n\t\t\treturn { cacheKey: e.href, url: e.href };\n\t\t}\n\t\tconst { revision: e, url: n } = t;\n\t\tif (!n) throw new s('add-to-cache-list-unexpected-type', { entry: t });\n\t\tif (!e) {\n\t\t\tconst t = new URL(n, location.href);\n\t\t\treturn { cacheKey: t.href, url: t.href };\n\t\t}\n\t\tconst r = new URL(n, location.href),\n\t\t\ti = new URL(n, location.href);\n\t\treturn r.searchParams.set('__WB_REVISION__', e), { cacheKey: r.href, url: i.href };\n\t}\n\tclass G {\n\t\tconstructor() {\n\t\t\t(this.updatedURLs = []),\n\t\t\t\t(this.notUpdatedURLs = []),\n\t\t\t\t(this.handlerWillStart = async ({ request: t, state: e }) => {\n\t\t\t\t\te && (e.originalRequest = t);\n\t\t\t\t}),\n\t\t\t\t(this.cachedResponseWillBeUsed = async ({ event: t, state: e, cachedResponse: s }) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t'install' === t.type &&\n\t\t\t\t\t\te &&\n\t\t\t\t\t\te.originalRequest &&\n\t\t\t\t\t\te.originalRequest instanceof Request\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst t = e.originalRequest.url;\n\t\t\t\t\t\ts ? this.notUpdatedURLs.push(t) : this.updatedURLs.push(t);\n\t\t\t\t\t}\n\t\t\t\t\treturn s;\n\t\t\t\t});\n\t\t}\n\t}\n\tclass V {\n\t\tconstructor({ precacheController: t }) {\n\t\t\t(this.cacheKeyWillBeUsed = async ({ request: t, params: e }) => {\n\t\t\t\tconst s = (null == e ? void 0 : e.cacheKey) || this.W.getCacheKeyForURL(t.url);\n\t\t\t\treturn s ? new Request(s, { headers: t.headers }) : t;\n\t\t\t}),\n\t\t\t\t(this.W = t);\n\t\t}\n\t}\n\tlet J, Q;\n\tasync function X(t, e) {\n\t\tlet n = null;\n\t\tif (t.url) {\n\t\t\tn = new URL(t.url).origin;\n\t\t}\n\t\tif (n !== self.location.origin) throw new s('cross-origin-copy-response', { origin: n });\n\t\tconst r = t.clone(),\n\t\t\ti = { headers: new Headers(r.headers), status: r.status, statusText: r.statusText },\n\t\t\ta = e ? e(i) : i,\n\t\t\to = (function () {\n\t\t\t\tif (void 0 === J) {\n\t\t\t\t\tconst t = new Response('');\n\t\t\t\t\tif ('body' in t)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tnew Response(t.body), (J = !0);\n\t\t\t\t\t\t} catch (t) {\n\t\t\t\t\t\t\tJ = !1;\n\t\t\t\t\t\t}\n\t\t\t\t\tJ = !1;\n\t\t\t\t}\n\t\t\t\treturn J;\n\t\t\t})()\n\t\t\t\t? r.body\n\t\t\t\t: await r.blob();\n\t\treturn new Response(o, a);\n\t}\n\tclass Y extends R {\n\t\tconstructor(t = {}) {\n\t\t\t(t.cacheName = w(t.cacheName)),\n\t\t\t\tsuper(t),\n\t\t\t\t(this.j = !1 !== t.fallbackToNetwork),\n\t\t\t\tthis.plugins.push(Y.copyRedirectedCacheableResponsesPlugin);\n\t\t}\n\t\tasync U(t, e) {\n\t\t\tconst s = await e.cacheMatch(t);\n\t\t\treturn s || (e.event && 'install' === e.event.type ? await this.S(t, e) : await this.K(t, e));\n\t\t}\n\t\tasync K(t, e) {\n\t\t\tlet n;\n\t\t\tconst r = e.params || {};\n\t\t\tif (!this.j) throw new s('missing-precache-entry', { cacheName: this.cacheName, url: t.url });\n\t\t\t{\n\t\t\t\tconst s = r.integrity,\n\t\t\t\t\ti = t.integrity,\n\t\t\t\t\ta = !i || i === s;\n\t\t\t\t(n = await e.fetch(new Request(t, { integrity: 'no-cors' !== t.mode ? i || s : void 0 }))),\n\t\t\t\t\ts && a && 'no-cors' !== t.mode && (this.A(), await e.cachePut(t, n.clone()));\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\t\tasync S(t, e) {\n\t\t\tthis.A();\n\t\t\tconst n = await e.fetch(t);\n\t\t\tif (!(await e.cachePut(t, n.clone())))\n\t\t\t\tthrow new s('bad-precaching-response', { url: t.url, status: n.status });\n\t\t\treturn n;\n\t\t}\n\t\tA() {\n\t\t\tlet t = null,\n\t\t\t\te = 0;\n\t\t\tfor (const [s, n] of this.plugins.entries())\n\t\t\t\tn !== Y.copyRedirectedCacheableResponsesPlugin &&\n\t\t\t\t\t(n === Y.defaultPrecacheCacheabilityPlugin && (t = s), n.cacheWillUpdate && e++);\n\t\t\t0 === e\n\t\t\t\t? this.plugins.push(Y.defaultPrecacheCacheabilityPlugin)\n\t\t\t\t: e > 1 && null !== t && this.plugins.splice(t, 1);\n\t\t}\n\t}\n\t(Y.defaultPrecacheCacheabilityPlugin = {\n\t\tcacheWillUpdate: async ({ response: t }) => (!t || t.status >= 400 ? null : t)\n\t}),\n\t\t(Y.copyRedirectedCacheableResponsesPlugin = {\n\t\t\tcacheWillUpdate: async ({ response: t }) => (t.redirected ? await X(t) : t)\n\t\t});\n\tclass Z {\n\t\tconstructor({ cacheName: t, plugins: e = [], fallbackToNetwork: s = !0 } = {}) {\n\t\t\t(this.F = new Map()),\n\t\t\t\t(this.H = new Map()),\n\t\t\t\t(this.$ = new Map()),\n\t\t\t\t(this.u = new Y({\n\t\t\t\t\tcacheName: w(t),\n\t\t\t\t\tplugins: [...e, new V({ precacheController: this })],\n\t\t\t\t\tfallbackToNetwork: s\n\t\t\t\t})),\n\t\t\t\t(this.install = this.install.bind(this)),\n\t\t\t\t(this.activate = this.activate.bind(this));\n\t\t}\n\t\tget strategy() {\n\t\t\treturn this.u;\n\t\t}\n\t\tprecache(t) {\n\t\t\tthis.addToCacheList(t),\n\t\t\t\tthis.G ||\n\t\t\t\t\t(self.addEventListener('install', this.install),\n\t\t\t\t\tself.addEventListener('activate', this.activate),\n\t\t\t\t\t(this.G = !0));\n\t\t}\n\t\taddToCacheList(t) {\n\t\t\tconst e = [];\n\t\t\tfor (const n of t) {\n\t\t\t\t'string' == typeof n ? e.push(n) : n && void 0 === n.revision && e.push(n.url);\n\t\t\t\tconst { cacheKey: t, url: r } = z(n),\n\t\t\t\t\ti = 'string' != typeof n && n.revision ? 'reload' : 'default';\n\t\t\t\tif (this.F.has(r) && this.F.get(r) !== t)\n\t\t\t\t\tthrow new s('add-to-cache-list-conflicting-entries', {\n\t\t\t\t\t\tfirstEntry: this.F.get(r),\n\t\t\t\t\t\tsecondEntry: t\n\t\t\t\t\t});\n\t\t\t\tif ('string' != typeof n && n.integrity) {\n\t\t\t\t\tif (this.$.has(t) && this.$.get(t) !== n.integrity)\n\t\t\t\t\t\tthrow new s('add-to-cache-list-conflicting-integrities', { url: r });\n\t\t\t\t\tthis.$.set(t, n.integrity);\n\t\t\t\t}\n\t\t\t\tif ((this.F.set(r, t), this.H.set(r, i), e.length > 0)) {\n\t\t\t\t\tconst t = `Workbox is precaching URLs without revision info: ${e.join(', ')}\\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`;\n\t\t\t\t\tconsole.warn(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinstall(t) {\n\t\t\treturn $(t, async () => {\n\t\t\t\tconst e = new G();\n\t\t\t\tthis.strategy.plugins.push(e);\n\t\t\t\tfor (const [e, s] of this.F) {\n\t\t\t\t\tconst n = this.$.get(s),\n\t\t\t\t\t\tr = this.H.get(e),\n\t\t\t\t\t\ti = new Request(e, { integrity: n, cache: r, credentials: 'same-origin' });\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\tthis.strategy.handleAll({ params: { cacheKey: s }, request: i, event: t })\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst { updatedURLs: s, notUpdatedURLs: n } = e;\n\t\t\t\treturn { updatedURLs: s, notUpdatedURLs: n };\n\t\t\t});\n\t\t}\n\t\tactivate(t) {\n\t\t\treturn $(t, async () => {\n\t\t\t\tconst t = await self.caches.open(this.strategy.cacheName),\n\t\t\t\t\te = await t.keys(),\n\t\t\t\t\ts = new Set(this.F.values()),\n\t\t\t\t\tn = [];\n\t\t\t\tfor (const r of e) s.has(r.url) || (await t.delete(r), n.push(r.url));\n\t\t\t\treturn { deletedURLs: n };\n\t\t\t});\n\t\t}\n\t\tgetURLsToCacheKeys() {\n\t\t\treturn this.F;\n\t\t}\n\t\tgetCachedURLs() {\n\t\t\treturn [...this.F.keys()];\n\t\t}\n\t\tgetCacheKeyForURL(t) {\n\t\t\tconst e = new URL(t, location.href);\n\t\t\treturn this.F.get(e.href);\n\t\t}\n\t\tgetIntegrityForCacheKey(t) {\n\t\t\treturn this.$.get(t);\n\t\t}\n\t\tasync matchPrecache(t) {\n\t\t\tconst e = t instanceof Request ? t.url : t,\n\t\t\t\ts = this.getCacheKeyForURL(e);\n\t\t\tif (s) {\n\t\t\t\treturn (await self.caches.open(this.strategy.cacheName)).match(s);\n\t\t\t}\n\t\t}\n\t\tcreateHandlerBoundToURL(t) {\n\t\t\tconst e = this.getCacheKeyForURL(t);\n\t\t\tif (!e) throw new s('non-precached-url', { url: t });\n\t\t\treturn (s) => (\n\t\t\t\t(s.request = new Request(t)),\n\t\t\t\t(s.params = Object.assign({ cacheKey: e }, s.params)),\n\t\t\t\tthis.strategy.handle(s)\n\t\t\t);\n\t\t}\n\t}\n\tconst tt = () => (Q || (Q = new Z()), Q);\n\tclass et extends r {\n\t\tconstructor(t, e) {\n\t\t\tsuper(({ request: s }) => {\n\t\t\t\tconst n = t.getURLsToCacheKeys();\n\t\t\t\tfor (const r of (function* (\n\t\t\t\t\tt,\n\t\t\t\t\t{\n\t\t\t\t\t\tignoreURLParametersMatching: e = [/^utm_/, /^fbclid$/],\n\t\t\t\t\t\tdirectoryIndex: s = 'index.html',\n\t\t\t\t\t\tcleanURLs: n = !0,\n\t\t\t\t\t\turlManipulation: r\n\t\t\t\t\t} = {}\n\t\t\t\t) {\n\t\t\t\t\tconst i = new URL(t, location.href);\n\t\t\t\t\t(i.hash = ''), yield i.href;\n\t\t\t\t\tconst a = (function (t, e = []) {\n\t\t\t\t\t\tfor (const s of [...t.searchParams.keys()])\n\t\t\t\t\t\t\te.some((t) => t.test(s)) && t.searchParams.delete(s);\n\t\t\t\t\t\treturn t;\n\t\t\t\t\t})(i, e);\n\t\t\t\t\tif ((yield a.href, s && a.pathname.endsWith('/'))) {\n\t\t\t\t\t\tconst t = new URL(a.href);\n\t\t\t\t\t\t(t.pathname += s), yield t.href;\n\t\t\t\t\t}\n\t\t\t\t\tif (n) {\n\t\t\t\t\t\tconst t = new URL(a.href);\n\t\t\t\t\t\t(t.pathname += '.html'), yield t.href;\n\t\t\t\t\t}\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\tconst t = r({ url: i });\n\t\t\t\t\t\tfor (const e of t) yield e.href;\n\t\t\t\t\t}\n\t\t\t\t})(s.url, e)) {\n\t\t\t\t\tconst e = n.get(r);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\treturn { cacheKey: e, integrity: t.getIntegrityForCacheKey(e) };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, t.strategy);\n\t\t}\n\t}\n\t(t.CacheFirst = class extends R {\n\t\tasync U(t, e) {\n\t\t\tlet n,\n\t\t\t\tr = await e.cacheMatch(t);\n\t\t\tif (!r)\n\t\t\t\ttry {\n\t\t\t\t\tr = await e.fetchAndCachePut(t);\n\t\t\t\t} catch (t) {\n\t\t\t\t\tt instanceof Error && (n = t);\n\t\t\t\t}\n\t\t\tif (!r) throw new s('no-response', { url: t.url, error: n });\n\t\t\treturn r;\n\t\t}\n\t}),\n\t\t(t.ExpirationPlugin = class {\n\t\t\tconstructor(t = {}) {\n\t\t\t\t(this.cachedResponseWillBeUsed = async ({\n\t\t\t\t\tevent: t,\n\t\t\t\t\trequest: e,\n\t\t\t\t\tcacheName: s,\n\t\t\t\t\tcachedResponse: n\n\t\t\t\t}) => {\n\t\t\t\t\tif (!n) return null;\n\t\t\t\t\tconst r = this.V(n),\n\t\t\t\t\t\ti = this.J(s);\n\t\t\t\t\tb(i.expireEntries());\n\t\t\t\t\tconst a = i.updateTimestamp(e.url);\n\t\t\t\t\tif (t)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tt.waitUntil(a);\n\t\t\t\t\t\t} catch (_t) {}\n\t\t\t\t\treturn r ? n : null;\n\t\t\t\t}),\n\t\t\t\t\t(this.cacheDidUpdate = async ({ cacheName: t, request: e }) => {\n\t\t\t\t\t\tconst s = this.J(t);\n\t\t\t\t\t\tawait s.updateTimestamp(e.url), await s.expireEntries();\n\t\t\t\t\t}),\n\t\t\t\t\t(this.X = t),\n\t\t\t\t\t(this.B = t.maxAgeSeconds),\n\t\t\t\t\t(this.Y = new Map()),\n\t\t\t\t\tt.purgeOnQuotaError &&\n\t\t\t\t\t\t(function (t) {\n\t\t\t\t\t\t\tg.add(t);\n\t\t\t\t\t\t})(() => this.deleteCacheAndMetadata());\n\t\t\t}\n\t\t\tJ(t) {\n\t\t\t\tif (t === d()) throw new s('expire-custom-caches-only');\n\t\t\t\tlet e = this.Y.get(t);\n\t\t\t\treturn e || ((e = new F(t, this.X)), this.Y.set(t, e)), e;\n\t\t\t}\n\t\t\tV(t) {\n\t\t\t\tif (!this.B) return !0;\n\t\t\t\tconst e = this.Z(t);\n\t\t\t\tif (null === e) return !0;\n\t\t\t\treturn e >= Date.now() - 1e3 * this.B;\n\t\t\t}\n\t\t\tZ(t) {\n\t\t\t\tif (!t.headers.has('date')) return null;\n\t\t\t\tconst e = t.headers.get('date'),\n\t\t\t\t\ts = new Date(e).getTime();\n\t\t\t\treturn isNaN(s) ? null : s;\n\t\t\t}\n\t\t\tasync deleteCacheAndMetadata() {\n\t\t\t\tfor (const [t, e] of this.Y) await self.caches.delete(t), await e.delete();\n\t\t\t\tthis.Y = new Map();\n\t\t\t}\n\t\t}),\n\t\t(t.NetworkFirst = class extends R {\n\t\t\tconstructor(t = {}) {\n\t\t\t\tsuper(t),\n\t\t\t\t\tthis.plugins.some((t) => 'cacheWillUpdate' in t) || this.plugins.unshift(u),\n\t\t\t\t\t(this.tt = t.networkTimeoutSeconds || 0);\n\t\t\t}\n\t\t\tasync U(t, e) {\n\t\t\t\tconst n = [],\n\t\t\t\t\tr = [];\n\t\t\t\tlet i;\n\t\t\t\tif (this.tt) {\n\t\t\t\t\tconst { id: s, promise: a } = this.et({ request: t, logs: n, handler: e });\n\t\t\t\t\t(i = s), r.push(a);\n\t\t\t\t}\n\t\t\t\tconst a = this.st({ timeoutId: i, request: t, logs: n, handler: e });\n\t\t\t\tr.push(a);\n\t\t\t\tconst o = await e.waitUntil(\n\t\t\t\t\t(async () => (await e.waitUntil(Promise.race(r))) || (await a))()\n\t\t\t\t);\n\t\t\t\tif (!o) throw new s('no-response', { url: t.url });\n\t\t\t\treturn o;\n\t\t\t}\n\t\t\tet({ request: t, logs: _e, handler: s }) {\n\t\t\t\tlet n;\n\t\t\t\treturn {\n\t\t\t\t\tpromise: new Promise((e) => {\n\t\t\t\t\t\tn = setTimeout(async () => {\n\t\t\t\t\t\t\te(await s.cacheMatch(t));\n\t\t\t\t\t\t}, 1e3 * this.tt);\n\t\t\t\t\t}),\n\t\t\t\t\tid: n\n\t\t\t\t};\n\t\t\t}\n\t\t\tasync st({ timeoutId: t, request: e, logs: _s, handler: n }) {\n\t\t\t\tlet r, i;\n\t\t\t\ttry {\n\t\t\t\t\ti = await n.fetchAndCachePut(e);\n\t\t\t\t} catch (t) {\n\t\t\t\t\tt instanceof Error && (r = t);\n\t\t\t\t}\n\t\t\t\treturn t && clearTimeout(t), (!r && i) || (i = await n.cacheMatch(e)), i;\n\t\t\t}\n\t\t}),\n\t\t(t.RangeRequestsPlugin = class {\n\t\t\tconstructor() {\n\t\t\t\tthis.cachedResponseWillBeUsed = async ({ request: t, cachedResponse: e }) =>\n\t\t\t\t\te && t.headers.has('range') ? await H(t, e) : e;\n\t\t\t}\n\t\t}),\n\t\t(t.StaleWhileRevalidate = class extends R {\n\t\t\tconstructor(t = {}) {\n\t\t\t\tsuper(t), this.plugins.some((t) => 'cacheWillUpdate' in t) || this.plugins.unshift(u);\n\t\t\t}\n\t\t\tasync U(t, e) {\n\t\t\t\tconst n = e.fetchAndCachePut(t).catch(() => {});\n\t\t\t\te.waitUntil(n);\n\t\t\t\tlet r,\n\t\t\t\t\ti = await e.cacheMatch(t);\n\t\t\t\tif (i);\n\t\t\t\telse\n\t\t\t\t\ttry {\n\t\t\t\t\t\ti = await n;\n\t\t\t\t\t} catch (t) {\n\t\t\t\t\t\tt instanceof Error && (r = t);\n\t\t\t\t\t}\n\t\t\t\tif (!i) throw new s('no-response', { url: t.url, error: r });\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}),\n\t\t(t.cleanupOutdatedCaches = function () {\n\t\t\tself.addEventListener('activate', (t) => {\n\t\t\t\tconst e = w();\n\t\t\t\tt.waitUntil(\n\t\t\t\t\t(async (t, e = '-precache-') => {\n\t\t\t\t\t\tconst s = (await self.caches.keys()).filter(\n\t\t\t\t\t\t\t(s) => s.includes(e) && s.includes(self.registration.scope) && s !== t\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn await Promise.all(s.map((t) => self.caches.delete(t))), s;\n\t\t\t\t\t})(e).then((_t) => {})\n\t\t\t\t);\n\t\t\t});\n\t\t}),\n\t\t(t.clientsClaim = function () {\n\t\t\tself.addEventListener('activate', () => self.clients.claim());\n\t\t}),\n\t\t(t.precacheAndRoute = function (t, e) {\n\t\t\t!(function (t) {\n\t\t\t\ttt().precache(t);\n\t\t\t})(t),\n\t\t\t\t(function (t) {\n\t\t\t\t\tconst e = tt();\n\t\t\t\t\th(new et(e, t));\n\t\t\t\t})(e);\n\t\t}),\n\t\t(t.registerRoute = h);\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/ai/dev.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/ai/flows/deck-advisor.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 53,
				"column": 10,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 53,
				"endColumn": 17
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "'use server';\n\n/**\n * @fileOverview AI-powered Deck Advisor tool.\n *\n * - getDeckAdvice - A function that provides advice for deck completion.\n * - DeckAdviceInput - The input type for the getDeckAdvice function.\n * - DeckAdviceOutput - The return type for the getDeckAdvice function.\n */\n\nimport { ai } from '../genkit.js';\nimport { z } from 'genkit';\n\nconst DeckAdviceInputSchema = z.object({\n\ttheme: z.string().describe('The theme of the deck.'),\n\tarchetype: z.string().describe('The archetype of the deck.'),\n\tcardSelection: z.string().describe('The specific card selection.')\n});\nexport type DeckAdviceInput = z.infer<typeof DeckAdviceInputSchema>;\n\nconst DeckAdviceOutputSchema = z.object({\n\tadvice: z.string().describe('Advice for completing the deck.')\n});\nexport type DeckAdviceOutput = z.infer<typeof DeckAdviceOutputSchema>;\n\nexport async function getDeckAdvice(input: DeckAdviceInput): Promise<DeckAdviceOutput> {\n\treturn deckAdvisorFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n\tname: 'deckAdvisorPrompt',\n\tinput: { schema: DeckAdviceInputSchema },\n\toutput: { schema: DeckAdviceOutputSchema },\n\tprompt: `You are an expert deck builder for the Altered TCG.\n\nYou will use the following information to give advice for completing the deck.\n\nTheme: {{{theme}}}\nArchetype: {{{archetype}}}\nCard Selection: {{{cardSelection}}}\n\nGive advice for completing the deck, including specific cards to add and strategies to employ.`\n});\n\nconst deckAdvisorFlow = ai.defineFlow(\n\t{\n\t\tname: 'deckAdvisorFlow',\n\t\tinputSchema: DeckAdviceInputSchema,\n\t\toutputSchema: DeckAdviceOutputSchema\n\t},\n\tasync (input) => {\n\t\tconst { output } = await prompt(input);\n\t\treturn output!;\n\t}\n);\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/ai/genkit.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/components/ai/DeckAdvisorClient.svelte",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'DeckAdviceInput' is defined but never used.",
				"line": 6,
				"column": 12,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 6,
				"endColumn": 27
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'DeckAdviceInputSchema' is assigned a value but never used.",
				"line": 24,
				"column": 8,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 24,
				"endColumn": 29
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'setTimeout' is not defined.",
				"line": 64,
				"column": 35,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 64,
				"endColumn": 45
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'alert' is not defined.",
				"line": 74,
				"column": 4,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 74,
				"endColumn": 9
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'console' is not defined.",
				"line": 76,
				"column": 4,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 76,
				"endColumn": 11
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'alert' is not defined.",
				"line": 77,
				"column": 4,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 77,
				"endColumn": 9
			}
		],
		"suppressedMessages": [],
		"errorCount": 6,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n\timport { z } from 'zod';\n\t// Temporarily disabled AI functionality for build\n\t// import { getDeckAdvice, type DeckAdviceInput, type DeckAdviceOutput } from '$ai/flows/deck-advisor';\n\n\tinterface DeckAdviceInput {\n\t\ttheme: string;\n\t\tarchetype: string;\n\t\tcardSelection: string;\n\t}\n\n\tinterface DeckAdviceOutput {\n\t\tadvice: string;\n\t}\n\timport Button from '$components/ui/button/Button.svelte';\n\timport Card from '$components/ui/card/Card.svelte';\n\timport CardContent from '$components/ui/card/CardContent.svelte';\n\timport CardDescription from '$components/ui/card/CardDescription.svelte';\n\timport CardFooter from '$components/ui/card/CardFooter.svelte';\n\timport CardHeader from '$components/ui/card/CardHeader.svelte';\n\timport CardTitle from '$components/ui/card/CardTitle.svelte';\n\timport { Loader2, Lightbulb } from 'lucide-svelte';\n\n\tconst DeckAdviceInputSchema = z.object({\n\t\ttheme: z.string().min(3, 'Theme must be at least 3 characters long.'),\n\t\tarchetype: z.string().min(3, 'Archetype must be at least 3 characters long.'),\n\t\tcardSelection: z\n\t\t\t.string()\n\t\t\t.min(10, 'Card selection description must be at least 10 characters long.')\n\t});\n\n\tlet adviceOutput: DeckAdviceOutput | null = null;\n\tlet isLoading = false;\n\n\tlet formData = {\n\t\ttheme: '',\n\t\tarchetype: '',\n\t\tcardSelection: ''\n\t};\n\n\tlet errors: Record<string, string[]> = {};\n\n\tfunction validateForm() {\n\t\terrors = {};\n\t\tif (formData.theme.length < 3) {\n\t\t\terrors.theme = ['Theme must be at least 3 characters long.'];\n\t\t}\n\t\tif (formData.archetype.length < 3) {\n\t\t\terrors.archetype = ['Archetype must be at least 3 characters long.'];\n\t\t}\n\t\tif (formData.cardSelection.length < 10) {\n\t\t\terrors.cardSelection = ['Card selection description must be at least 10 characters long.'];\n\t\t}\n\t\treturn Object.keys(errors).length === 0;\n\t}\n\n\tasync function handleSubmit() {\n\t\tif (!validateForm()) return;\n\n\t\tisLoading = true;\n\t\tadviceOutput = null;\n\t\ttry {\n\t\t\t// Simulate AI response for now\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, 2000));\n\t\t\tadviceOutput = {\n\t\t\t\tadvice:\n\t\t\t\t\t`Based on your ${formData.theme} theme and ${formData.archetype} archetype:\\n\\n` +\n\t\t\t\t\t` Consider adding cards that synergize with your core strategy\\n` +\n\t\t\t\t\t` Balance your mana curve for consistent gameplay\\n` +\n\t\t\t\t\t` Include versatile cards that work in multiple situations\\n` +\n\t\t\t\t\t` Don't forget defensive options to protect your strategy\\n\\n` +\n\t\t\t\t\t`Note: AI advisor is temporarily disabled during development.`\n\t\t\t};\n\t\t\talert('Advice Received! AI has provided suggestions for your deck.');\n\t\t} catch (error) {\n\t\t\tconsole.error('Error getting deck advice:', error);\n\t\t\talert('Failed to get deck advice. Please try again.');\n\t\t} finally {\n\t\t\tisLoading = false;\n\t\t}\n\t}\n</script>\n\n<div class=\"grid gap-8 md:grid-cols-2\">\n\t<Card class=\"shadow-xl\">\n\t\t<CardHeader>\n\t\t\t<CardTitle class=\"font-headline flex items-center gap-2 text-2xl\">\n\t\t\t\t<Lightbulb class=\"text-primary h-6 w-6\" />\n\t\t\t\tDeck Advisor Input\n\t\t\t</CardTitle>\n\t\t\t<CardDescription>\n\t\t\t\tProvide details about your deck idea, and our AI will help you complete it.\n\t\t\t</CardDescription>\n\t\t</CardHeader>\n\t\t<form on:submit|preventDefault={handleSubmit}>\n\t\t\t<CardContent class=\"space-y-6\">\n\t\t\t\t<div class=\"space-y-2\">\n\t\t\t\t\t<label for=\"theme\" class=\"text-sm font-medium\">Deck Theme</label>\n\t\t\t\t\t<input\n\t\t\t\t\t\tid=\"theme\"\n\t\t\t\t\t\tbind:value={formData.theme}\n\t\t\t\t\t\ton:input={validateForm}\n\t\t\t\t\t\tplaceholder=\"e.g., Aggro, Control, Forest Control\"\n\t\t\t\t\t\tclass=\"border-input bg-background focus:ring-ring w-full rounded-md border px-3 py-2 focus:ring-2 focus:outline-none\"\n\t\t\t\t\t/>\n\t\t\t\t\t<p class=\"text-muted-foreground text-sm\">\n\t\t\t\t\t\tWhat is the central theme or strategy of your deck?\n\t\t\t\t\t</p>\n\t\t\t\t\t{#if errors.theme}\n\t\t\t\t\t\t<p class=\"text-destructive text-sm\">{errors.theme[0]}</p>\n\t\t\t\t\t{/if}\n\t\t\t\t</div>\n\n\t\t\t\t<div class=\"space-y-2\">\n\t\t\t\t\t<label for=\"archetype\" class=\"text-sm font-medium\">Deck Archetype</label>\n\t\t\t\t\t<input\n\t\t\t\t\t\tid=\"archetype\"\n\t\t\t\t\t\tbind:value={formData.archetype}\n\t\t\t\t\t\ton:input={validateForm}\n\t\t\t\t\t\tplaceholder=\"e.g., Axiom Tempo, Bravos Aggro\"\n\t\t\t\t\t\tclass=\"border-input bg-background focus:ring-ring w-full rounded-md border px-3 py-2 focus:ring-2 focus:outline-none\"\n\t\t\t\t\t/>\n\t\t\t\t\t<p class=\"text-muted-foreground text-sm\">What is the general playstyle or archetype?</p>\n\t\t\t\t\t{#if errors.archetype}\n\t\t\t\t\t\t<p class=\"text-destructive text-sm\">{errors.archetype[0]}</p>\n\t\t\t\t\t{/if}\n\t\t\t\t</div>\n\n\t\t\t\t<div class=\"space-y-2\">\n\t\t\t\t\t<label for=\"cardSelection\" class=\"text-sm font-medium\">Current Cards / Core Ideas</label>\n\t\t\t\t\t<textarea\n\t\t\t\t\t\tid=\"cardSelection\"\n\t\t\t\t\t\tbind:value={formData.cardSelection}\n\t\t\t\t\t\ton:input={validateForm}\n\t\t\t\t\t\tplaceholder=\"List key cards you want to include, or describe core card interactions...\"\n\t\t\t\t\t\trows=\"5\"\n\t\t\t\t\t\tclass=\"border-input bg-background focus:ring-ring w-full resize-none rounded-md border px-3 py-2 focus:ring-2 focus:outline-none\"\n\t\t\t\t\t></textarea>\n\t\t\t\t\t<p class=\"text-muted-foreground text-sm\">\n\t\t\t\t\t\tDescribe the cards you've already selected or the core mechanics.\n\t\t\t\t\t</p>\n\t\t\t\t\t{#if errors.cardSelection}\n\t\t\t\t\t\t<p class=\"text-destructive text-sm\">{errors.cardSelection[0]}</p>\n\t\t\t\t\t{/if}\n\t\t\t\t</div>\n\t\t\t</CardContent>\n\t\t\t<CardFooter>\n\t\t\t\t<Button\n\t\t\t\t\ttype=\"submit\"\n\t\t\t\t\tdisabled={isLoading || Object.keys(errors).length > 0}\n\t\t\t\t\tclass=\"bg-accent text-accent-foreground hover:bg-accent/90 w-full\"\n\t\t\t\t>\n\t\t\t\t\t{#if isLoading}\n\t\t\t\t\t\t<Loader2 class=\"mr-2 h-4 w-4 animate-spin\" />\n\t\t\t\t\t\tGetting Advice...\n\t\t\t\t\t{:else}\n\t\t\t\t\t\tGet AI Deck Advice\n\t\t\t\t\t{/if}\n\t\t\t\t</Button>\n\t\t\t</CardFooter>\n\t\t</form>\n\t</Card>\n\n\t<Card class=\"shadow-xl\">\n\t\t<CardHeader>\n\t\t\t<CardTitle class=\"font-headline text-2xl\">AI Generated Advice</CardTitle>\n\t\t\t<CardDescription>Suggestions and insights from our AI deck building expert.</CardDescription>\n\t\t</CardHeader>\n\t\t<CardContent class=\"min-h-[200px]\">\n\t\t\t{#if isLoading && !adviceOutput}\n\t\t\t\t<div class=\"flex h-full flex-col items-center justify-center\">\n\t\t\t\t\t<Loader2 class=\"text-primary mb-4 h-12 w-12 animate-spin\" />\n\t\t\t\t\t<p class=\"text-muted-foreground\">Thinking...</p>\n\t\t\t\t</div>\n\t\t\t{:else if adviceOutput}\n\t\t\t\t<div class=\"h-[400px] overflow-y-auto p-1\">\n\t\t\t\t\t<pre\n\t\t\t\t\t\tclass=\"bg-muted/50 rounded-md p-4 font-mono text-sm whitespace-pre-wrap\">{adviceOutput.advice}</pre>\n\t\t\t\t</div>\n\t\t\t{:else}\n\t\t\t\t<p class=\"text-muted-foreground pt-10 text-center\">\n\t\t\t\t\tEnter your deck details and click \"Get AI Deck Advice\" to see suggestions here.\n\t\t\t\t</p>\n\t\t\t{/if}\n\t\t</CardContent>\n\t</Card>\n</div>\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/components/layout/Footer.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/components/layout/Header.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/components/ui/button/Button.svelte",
		"messages": [
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'MouseEvent' is not defined.",
				"line": 36,
				"column": 21,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 36,
				"endColumn": 31
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n\timport { tv, type VariantProps } from 'tailwind-variants';\n\timport type { HTMLButtonAttributes } from 'svelte/elements';\n\n\tconst buttonVariants = tv({\n\t\tbase: 'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',\n\t\tvariants: {\n\t\t\tvariant: {\n\t\t\t\tdefault: 'bg-primary text-primary-foreground hover:bg-primary/90',\n\t\t\t\tdestructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',\n\t\t\t\toutline: 'border border-input bg-background hover:bg-accent hover:text-accent-foreground',\n\t\t\t\tsecondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',\n\t\t\t\tghost: 'hover:bg-accent hover:text-accent-foreground',\n\t\t\t\tlink: 'text-primary underline-offset-4 hover:underline'\n\t\t\t},\n\t\t\tsize: {\n\t\t\t\tdefault: 'h-10 px-4 py-2',\n\t\t\t\tsm: 'h-9 rounded-md px-3',\n\t\t\t\tlg: 'h-11 rounded-md px-8',\n\t\t\t\ticon: 'h-10 w-10'\n\t\t\t}\n\t\t},\n\t\tdefaultVariants: {\n\t\t\tvariant: 'default',\n\t\t\tsize: 'default'\n\t\t}\n\t});\n\n\ttype Variant = VariantProps<typeof buttonVariants>['variant'];\n\ttype Size = VariantProps<typeof buttonVariants>['size'];\n\n\tinterface ButtonProps extends Omit<HTMLButtonAttributes, 'onclick'> {\n\t\tvariant?: Variant;\n\t\tsize?: Size;\n\t\tclass?: string;\n\t\tonclick?: (event: MouseEvent) => void;\n\t}\n\n\tlet {\n\t\tvariant = 'default',\n\t\tsize = 'default',\n\t\tclass: className,\n\t\tchildren,\n\t\tonclick,\n\t\t...restProps\n\t}: ButtonProps = $props();\n</script>\n\n<button class={buttonVariants({ variant, size, className })} {onclick} {...restProps}>\n\t{@render children?.()}\n</button>\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/components/ui/card/Card.svelte",
		"messages": [
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'HTMLDivElement' is not defined.",
				"line": 5,
				"column": 45,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 5,
				"endColumn": 59
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n\timport { cn } from '$lib/utils';\n\timport type { HTMLAttributes } from 'svelte/elements';\n\n\tinterface CardProps extends HTMLAttributes<HTMLDivElement> {\n\t\tclass?: string;\n\t}\n\n\tlet { class: className, children, ...restProps }: CardProps = $props();\n</script>\n\n<div\n\tclass={cn('bg-card text-card-foreground rounded-lg border shadow-sm', className)}\n\t{...restProps}\n>\n\t{@render children?.()}\n</div>\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/components/ui/card/CardContent.svelte",
		"messages": [
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'HTMLDivElement' is not defined.",
				"line": 5,
				"column": 52,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 5,
				"endColumn": 66
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n\timport { cn } from '$lib/utils';\n\timport type { HTMLAttributes } from 'svelte/elements';\n\n\tinterface CardContentProps extends HTMLAttributes<HTMLDivElement> {\n\t\tclass?: string;\n\t}\n\n\tlet { class: className, children, ...restProps }: CardContentProps = $props();\n</script>\n\n<div class={cn('p-6 pt-0', className)} {...restProps}>\n\t{@render children?.()}\n</div>\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/components/ui/card/CardDescription.svelte",
		"messages": [
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'HTMLParagraphElement' is not defined.",
				"line": 5,
				"column": 56,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 5,
				"endColumn": 76
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n\timport { cn } from '$lib/utils';\n\timport type { HTMLAttributes } from 'svelte/elements';\n\n\tinterface CardDescriptionProps extends HTMLAttributes<HTMLParagraphElement> {\n\t\tclass?: string;\n\t}\n\n\tlet { class: className, children, ...restProps }: CardDescriptionProps = $props();\n</script>\n\n<p class={cn('text-muted-foreground text-sm', className)} {...restProps}>\n\t{@render children?.()}\n</p>\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/components/ui/card/CardFooter.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/components/ui/card/CardHeader.svelte",
		"messages": [
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'HTMLDivElement' is not defined.",
				"line": 5,
				"column": 51,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 5,
				"endColumn": 65
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n\timport { cn } from '$lib/utils';\n\timport type { HTMLAttributes } from 'svelte/elements';\n\n\tinterface CardHeaderProps extends HTMLAttributes<HTMLDivElement> {\n\t\tclass?: string;\n\t}\n\n\tlet { class: className, children, ...restProps }: CardHeaderProps = $props();\n</script>\n\n<div class={cn('flex flex-col space-y-1.5 p-6', className)} {...restProps}>\n\t{@render children?.()}\n</div>\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/components/ui/card/CardTitle.svelte",
		"messages": [
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'HTMLHeadingElement' is not defined.",
				"line": 5,
				"column": 50,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 5,
				"endColumn": 68
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n\timport { cn } from '$lib/utils';\n\timport type { HTMLAttributes } from 'svelte/elements';\n\n\tinterface CardTitleProps extends HTMLAttributes<HTMLHeadingElement> {\n\t\tclass?: string;\n\t}\n\n\tlet { class: className, children, ...restProps }: CardTitleProps = $props();\n</script>\n\n<h3 class={cn('text-2xl leading-none font-semibold tracking-tight', className)} {...restProps}>\n\t{@render children?.()}\n</h3>\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/data/cards.ts",
		"messages": [
			{
				"ruleId": "no-async-promise-executor",
				"severity": 2,
				"message": "Promise executor functions should not be async.",
				"line": 124,
				"column": 61,
				"nodeType": "Identifier",
				"messageId": "async",
				"endLine": 124,
				"endColumn": 66
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { AlteredCard } from '$types';\nimport rawCardData from './altered_optimized.json';\nimport { dbPromise, type MyDatabase } from '$lib/rxdb'; // Import RxDB promise and types\n\n// Keep existing raw type interfaces\ninterface RawPower {\n\tm?: number;\n\to?: number;\n\tf?: number;\n}\n\ninterface RawCardEntry {\n\tname: string;\n\ttype_ref: string;\n\tfaction_ref?: string;\n\trarity_ref: string;\n\timage_path?: string;\n\tqr_url?: string;\n\tmain_cost?: number;\n\trecall_cost?: number;\n\tis_suspended?: boolean; // Added to match JSON\n\tpower?: RawPower;\n\tdescription?: string;\n\tflavorText?: string;\n\tartist?: string;\n\tcard_number?: string;\n\tkeywords?: string[];\n}\n\ninterface RawLookupTables {\n\trarities: { [key: string]: { name: string } };\n\tfactions: { [key: string]: { name: string; color: string } };\n\tcard_types: { [key: string]: { name: string } };\n}\n\ninterface RawAlteredDataSet {\n\tmeta: object;\n\tlookup_tables: RawLookupTables;\n\tcards: { [id: string]: RawCardEntry };\n}\n\nconst typedRawCardData = rawCardData as RawAlteredDataSet;\n\nconst processedCards: AlteredCard[] = Object.entries(typedRawCardData.cards).map(\n\t([id, rawCard]) => {\n\t\tconst cardTypeInfo = typedRawCardData.lookup_tables.card_types[rawCard.type_ref];\n\t\tconst type = cardTypeInfo ? cardTypeInfo.name : rawCard.type_ref;\n\n\t\tlet faction: string | undefined = undefined;\n\t\tlet factionColor: string | undefined = undefined;\n\t\tif (rawCard.faction_ref) {\n\t\t\tconst factionInfo = typedRawCardData.lookup_tables.factions[rawCard.faction_ref];\n\t\t\tif (factionInfo) {\n\t\t\t\tfaction = factionInfo.name;\n\t\t\t\tfactionColor = factionInfo.color;\n\t\t\t} else {\n\t\t\t\tfaction = rawCard.faction_ref;\n\t\t\t}\n\t\t}\n\n\t\tconst rarityInfo = typedRawCardData.lookup_tables.rarities[rawCard.rarity_ref];\n\t\tconst rarity = rarityInfo ? rarityInfo.name : rawCard.rarity_ref;\n\n\t\tlet description = rawCard.description;\n\t\tif (\n\t\t\t!description &&\n\t\t\ttype !== typedRawCardData.lookup_tables.card_types.TOKEN_MANA?.name &&\n\t\t\ttype !== typedRawCardData.lookup_tables.card_types.FOILER?.name\n\t\t) {\n\t\t\t// description = `This is ${rawCard.name}, a ${rarity} ${type} card${faction ? ` of the ${faction} faction` : ''}.`;\n\t\t}\n\n\t\tconst keywords = rawCard.keywords || [];\n\n\t\treturn {\n\t\t\tid,\n\t\t\tname: rawCard.name,\n\t\t\timageUrl: rawCard.image_path,\n\t\t\tqrUrl: rawCard.qr_url,\n\t\t\ttype,\n\t\t\tfaction,\n\t\t\tfactionColor,\n\t\t\trarity,\n\t\t\tcost: rawCard.main_cost,\n\t\t\trecallCost: rawCard.recall_cost,\n\t\t\tattack: rawCard.power?.o,\n\t\t\thealth: rawCard.power?.f,\n\t\t\tpowerM: rawCard.power?.m,\n\t\t\tisSuspended: rawCard.is_suspended ?? false, // Map is_suspended, default to false\n\t\t\tdescription,\n\t\t\tflavorText: rawCard.flavorText,\n\t\t\tartist: rawCard.artist,\n\t\t\tcardNumber: rawCard.card_number,\n\t\t\tkeywords\n\t\t};\n\t}\n);\n\n// --- RxDB Integration ---\n\nlet populateCalled = false; // Flag to ensure populate is called only once\n\nasync function populateCardsIfEmpty(db: MyDatabase): Promise<void> {\n\tif (populateCalled) return;\n\tpopulateCalled = true;\n\n\ttry {\n\t\tconst cardCount = await db.cards.count().exec();\n\t\tif (cardCount === 0) {\n\t\t\tconsole.log('[RxDB] Card database is empty. Seeding data...');\n\t\t\t// The 'processedCards' variable holds the data from the JSON, already transformed.\n\t\t\tawait db.cards.bulkInsert(processedCards);\n\t\t\tconsole.log('[RxDB] Card data successfully seeded.');\n\t\t} else {\n\t\t\tconsole.log('[RxDB] Card data already exists.');\n\t\t}\n\t} catch (error) {\n\t\tconsole.error('[RxDB] Error during card population or count:', error);\n\t\tthrow error; // Re-throw to ensure cardsReadyPromise rejects\n\t}\n}\n\n// Promise to ensure DB is initialized and cards are potentially populated\nexport const cardsReadyPromise: Promise<void> = new Promise(async (resolve, reject) => {\n\ttry {\n\t\tconst db = await dbPromise;\n\t\tawait populateCardsIfEmpty(db);\n\t\tresolve();\n\t} catch (error) {\n\t\t// Error is already logged by either initializeDb or populateCardsIfEmpty\n\t\t// console.error(\"[RxDB] Failed to initialize database or populate cards:\", error);\n\t\treject(error); // Ensure this promise rejects if previous steps failed\n\t}\n});\n\nexport async function getAllCards(): Promise<AlteredCard[]> {\n\tawait cardsReadyPromise;\n\tconst db = await dbPromise; // dbPromise should be resolved if cardsReadyPromise is\n\ttry {\n\t\tconst allCardDocs = await db.cards.find().exec();\n\t\treturn allCardDocs.map((doc) => doc.toJSON());\n\t} catch (error) {\n\t\tconsole.error('[RxDB] Error fetching all cards:', error);\n\t\tthrow error; // Propagate error to UI\n\t}\n}\n\nexport async function getCardById(id: string): Promise<AlteredCard | null> {\n\tawait cardsReadyPromise;\n\tconst db = await dbPromise;\n\ttry {\n\t\tconst cardDoc = await db.cards.findOne(id).exec();\n\t\treturn cardDoc ? cardDoc.toJSON() : null;\n\t} catch (error) {\n\t\tconsole.error(`[RxDB] Error fetching card by ID ${id}:`, error);\n\t\tthrow error; // Propagate error to UI\n\t}\n}\n\n// Keep these lookups loading from static JSON for now as per instructions\nexport const factionsLookup = typedRawCardData.lookup_tables.factions;\nexport const raritiesLookup = typedRawCardData.lookup_tables.rarities;\nexport const cardTypesLookup = typedRawCardData.lookup_tables.card_types;\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/data/mockCards.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/ActionHandler.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'expeditionId' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 42,
				"column": 3,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 42,
				"endColumn": 15
			},
			{
				"ruleId": "no-case-declarations",
				"severity": 2,
				"message": "Unexpected lexical declaration in case block.",
				"line": 122,
				"column": 5,
				"nodeType": "VariableDeclaration",
				"messageId": "unexpected",
				"endLine": 122,
				"endColumn": 54,
				"suggestions": [
					{
						"messageId": "addBrackets",
						"fix": {
							"range": [4363, 4724],
							"text": "{ const targetExpedition = player.zones.expedition;\n\t\t\t\tif (!targetExpedition) {\n\t\t\t\t\tthis.gsm.moveEntity(\n\t\t\t\t\t\tobjectInLimbo.objectId,\n\t\t\t\t\t\tthis.gsm.state.sharedZones.limbo,\n\t\t\t\t\t\tplayer.zones.hand,\n\t\t\t\t\t\tplayerId\n\t\t\t\t\t);\n\t\t\t\t\tthrow new Error(`Target expedition for player ${playerId} not found.`);\n\t\t\t\t}\n\t\t\t\tfinalDestinationZone = targetExpedition;\n\t\t\t\tbreak; }"
						},
						"desc": "Add {} brackets around the case block."
					}
				]
			},
			{
				"ruleId": "no-case-declarations",
				"severity": 2,
				"message": "Unexpected lexical declaration in case block.",
				"line": 153,
				"column": 5,
				"nodeType": "VariableDeclaration",
				"messageId": "unexpected",
				"endLine": 153,
				"endColumn": 72,
				"suggestions": [
					{
						"messageId": "addBrackets",
						"fix": {
							"range": [5383, 5550],
							"text": "{ const isFleeting = objectInLimbo.statuses.has(StatusType.Fleeting);\n\t\t\t\tfinalDestinationZone = isFleeting ? player.zones.discardPile : player.zones.reserve;\n\t\t\t\tbreak; }"
						},
						"desc": "Add {} brackets around the case block."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 3,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { GameStateManager } from './GameStateManager';\nimport type { TurnManager } from './TurnManager';\nimport type { ReactionManager } from './ReactionManager';\nimport { CostProcessor } from './CostProcessor';\nimport { EffectResolver } from './EffectResolver';\nimport type { IZone } from './types/zones';\nimport type { ICardInstance } from './types/cards';\nimport type { ICost } from './types/abilities';\nimport { CardType, StatusType, ZoneIdentifier, PermanentZoneType, GamePhase } from './types/enums';\nimport { isGameObject } from './types/objects';\nimport type { IGameObject } from './types/objects';\n\n/**\n * Handles high-level player actions, orchestrating the various managers\n * and processors to ensure rules are followed.\n */\nexport class ActionHandler {\n\tprivate gsm: GameStateManager;\n\tprivate turnManager: TurnManager;\n\tprivate reactionManager: ReactionManager;\n\tprivate costProcessor: CostProcessor;\n\tprivate effectResolver: EffectResolver;\n\n\tconstructor(gsm: GameStateManager, turnManager: TurnManager, reactionManager: ReactionManager) {\n\t\tthis.gsm = gsm;\n\t\tthis.turnManager = turnManager;\n\t\tthis.reactionManager = reactionManager;\n\t\tthis.effectResolver = new EffectResolver(gsm);\n\t\tthis.costProcessor = new CostProcessor(gsm);\n\t}\n\n\t/**\n\t * Executes the complex process of a player playing a card from their hand.\n\t * Follows the procedure outlined in Rule 5.1.2.\n\t * @param playerId The ID of the player performing the action.\n\t * @param cardInstanceId The ID of the card instance in the player's hand.\n\t * @param expeditionId The target expedition, if the card is a Character or Expedition Permanent.\n\t */\n\tpublic async tryPlayCardFromHand(\n\t\tplayerId: string,\n\t\tcardInstanceId: string,\n\t\texpeditionId?: string\n\t): Promise<void> {\n\t\tconsole.log(\n\t\t\t`[ActionHandler] Player ${playerId} is attempting to play card ${cardInstanceId} from hand.`\n\t\t);\n\n\t\t// --- 1. Validation and Declaration of Intent ---\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player || this.gsm.state.currentPlayerId !== playerId) {\n\t\t\tthrow new Error(`It is not ${playerId}'s turn.`);\n\t\t}\n\n\t\tconst cardInstance = player.zones.hand.findById(cardInstanceId) as ICardInstance;\n\t\tif (!cardInstance) {\n\t\t\tthrow new Error(`Card ${cardInstanceId} not found in player's hand.`);\n\t\t}\n\n\t\tconst definition = this.gsm.getCardDefinition(cardInstance.definitionId);\n\t\tif (!definition) {\n\t\t\tthrow new Error(`Card definition not found for ${cardInstance.definitionId}.`);\n\t\t}\n\n\t\tconst cost: ICost = { mana: definition.handCost };\n\n\t\tif (!this.costProcessor.canPay(playerId, cost)) {\n\t\t\tthrow new Error(`Player ${playerId} cannot pay the costs for ${definition.name}.`);\n\t\t}\n\t\tconsole.log(`[ActionHandler] Intent to play ${definition.name} is valid.`);\n\n\t\t// --- 2. Move to Limbo (Rule 5.1.2.g) ---\n\t\tconst limboMoveResult = this.gsm.moveEntity(\n\t\t\tcardInstance.instanceId,\n\t\t\tplayer.zones.hand,\n\t\t\tthis.gsm.state.sharedZones.limbo,\n\t\t\tplayerId\n\t\t);\n\t\tif (!limboMoveResult) {\n\t\t\tthrow new Error(`Card ${cardInstance.instanceId} could not be moved to Limbo.`);\n\t\t}\n\t\tconst limboMovePayload = {\n\t\t\tentity: limboMoveResult,\n\t\t\tfrom: player.zones.hand,\n\t\t\tto: this.gsm.state.sharedZones.limbo\n\t\t};\n\t\tthis.reactionManager.checkForTriggers('entityMoved', limboMovePayload);\n\t\tawait this.reactionManager.processReactions();\n\n\t\tconst objectInLimboId = isGameObject(limboMoveResult)\n\t\t\t? limboMoveResult.objectId\n\t\t\t: limboMoveResult.instanceId;\n\t\tconst objectInLimbo = this.gsm.state.sharedZones.limbo.findById(objectInLimboId);\n\n\t\tif (!objectInLimbo || !isGameObject(objectInLimbo)) {\n\t\t\tconsole.warn(\n\t\t\t\t`[ActionHandler] Card ${definition.name} was removed from Limbo by a reaction before it could resolve. Aborting action.`\n\t\t\t);\n\t\t\tthis.turnManager.advanceTurn();\n\t\t\treturn;\n\t\t}\n\n\t\t// --- 3. Pay Costs (Rule 5.1.2.h) ---\n\t\tif (!this.costProcessor.canPay(playerId, cost)) {\n\t\t\tconsole.error(\n\t\t\t\t`[ActionHandler] Cost became unpayable after reactions. Returning card to hand.`\n\t\t\t);\n\t\t\tthis.gsm.moveEntity(\n\t\t\t\tobjectInLimbo.objectId,\n\t\t\t\tthis.gsm.state.sharedZones.limbo,\n\t\t\t\tplayer.zones.hand,\n\t\t\t\tplayerId\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tthis.costProcessor.pay(playerId, cost);\n\t\tconsole.log(`[ActionHandler] Costs for ${definition.name} paid.`);\n\n\t\t// --- 4. Resolution (Rule 5.1.2.i) ---\n\t\tlet finalDestinationZone: IZone;\n\t\tswitch (definition.type) {\n\t\t\tcase CardType.Character:\n\t\t\t\tconst targetExpedition = player.zones.expedition;\n\t\t\t\tif (!targetExpedition) {\n\t\t\t\t\tthis.gsm.moveEntity(\n\t\t\t\t\t\tobjectInLimbo.objectId,\n\t\t\t\t\t\tthis.gsm.state.sharedZones.limbo,\n\t\t\t\t\t\tplayer.zones.hand,\n\t\t\t\t\t\tplayerId\n\t\t\t\t\t);\n\t\t\t\t\tthrow new Error(`Target expedition for player ${playerId} not found.`);\n\t\t\t\t}\n\t\t\t\tfinalDestinationZone = targetExpedition;\n\t\t\t\tbreak;\n\n\t\t\tcase CardType.Permanent:\n\t\t\t\tif (definition.permanentZoneType === PermanentZoneType.Landmark) {\n\t\t\t\t\tfinalDestinationZone = player.zones.landmarkZone;\n\t\t\t\t} else if (definition.permanentZoneType === PermanentZoneType.Expedition) {\n\t\t\t\t\tfinalDestinationZone = player.zones.expedition;\n\t\t\t\t} else {\n\t\t\t\t\tthis.gsm.moveEntity(\n\t\t\t\t\t\tobjectInLimbo.objectId,\n\t\t\t\t\t\tthis.gsm.state.sharedZones.limbo,\n\t\t\t\t\t\tplayer.zones.hand,\n\t\t\t\t\t\tplayerId\n\t\t\t\t\t);\n\t\t\t\t\tthrow new Error(`Unknown permanent zone type for ${definition.name}.`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CardType.Spell:\n\t\t\t\t// Rule 2.4.6.e / 5.2.4.b: Fleeting spells are discarded instead of going to Reserve.\n\t\t\t\tconst isFleeting = objectInLimbo.statuses.has(StatusType.Fleeting);\n\t\t\t\tfinalDestinationZone = isFleeting ? player.zones.discardPile : player.zones.reserve;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis.gsm.moveEntity(\n\t\t\t\t\tobjectInLimbo.objectId,\n\t\t\t\t\tthis.gsm.state.sharedZones.limbo,\n\t\t\t\t\tplayer.zones.hand,\n\t\t\t\t\tplayerId\n\t\t\t\t);\n\t\t\t\tthrow new Error(`Unknown card type resolution: ${definition.type}.`);\n\t\t}\n\t\tconst finalMoveResult = this.gsm.moveEntity(\n\t\t\tobjectInLimbo.objectId,\n\t\t\tthis.gsm.state.sharedZones.limbo,\n\t\t\tfinalDestinationZone,\n\t\t\tplayerId\n\t\t);\n\n\t\t// Rule 7.4.1.b / 5.2.4.b: A non-Fleeting spell with Cooldown enters Reserve exhausted.\n\t\tif (finalMoveResult && isGameObject(finalMoveResult) && definition.type === CardType.Spell) {\n\t\t\tconst hasCooldown = definition.abilities.some((a) => a.keyword === 'Cooldown');\n\t\t\tif (hasCooldown && finalDestinationZone.zoneType === ZoneIdentifier.Reserve) {\n\t\t\t\tfinalMoveResult.statuses.add(StatusType.Exhausted);\n\t\t\t\tconsole.log(\n\t\t\t\t\t`[ActionHandler] Spell ${definition.name} entered Reserve exhausted due to Cooldown.`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`[ActionHandler] ${definition.name} is moving from Limbo to ${finalDestinationZone.zoneType}.`\n\t\t);\n\t\tconsole.log(`[ActionHandler] Action to play ${definition.name} is complete.`);\n\n\t\t// --- 5. End of Turn Effect ---\n\t\tthis.turnManager.advanceTurn();\n\t}\n\n\tpublic async tryExpand(playerId: string, cardInstanceId: string): Promise<void> {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) throw new Error(`Player ${playerId} not found.`);\n\t\tif (this.gsm.state.currentPhase !== GamePhase.Morning) {\n\t\t\tthrow new Error('Expand can only be performed during the Morning phase.');\n\t\t}\n\t\tif (player.hasExpandedThisTurn) {\n\t\t\tthrow new Error('You have already expanded this turn.');\n\t\t}\n\n\t\tconst cardToExpand = player.zones.hand.findById(cardInstanceId);\n\t\tif (!cardToExpand) {\n\t\t\tthrow new Error(`Card ${cardInstanceId} not found in hand.`);\n\t\t}\n\n\t\tconsole.log(`[ActionHandler] Player ${playerId} is expanding card ${cardInstanceId}.`);\n\n\t\tconst manaObject = this.gsm.moveEntity(\n\t\t\tcardInstanceId,\n\t\t\tplayer.zones.hand,\n\t\t\tplayer.zones.manaZone,\n\t\t\tplayerId\n\t\t) as IGameObject;\n\t\tif (manaObject) {\n\t\t\t// Rule 4.2.1.e: The Mana Orb enters ready.\n\t\t\tif (manaObject.statuses.has(StatusType.Exhausted)) {\n\t\t\t\tmanaObject.statuses.delete(StatusType.Exhausted);\n\t\t\t\tconsole.log(`[ActionHandler] Mana Orb ${manaObject.objectId} was made ready.`);\n\t\t\t}\n\t\t}\n\t\tplayer.hasExpandedThisTurn = true;\n\t}\n\n\tpublic async trySkipExpand(playerId: string): Promise<void> {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) throw new Error(`Player ${playerId} not found.`);\n\t\tif (this.gsm.state.currentPhase !== GamePhase.Morning) {\n\t\t\tthrow new Error('Can only skip expand during the Morning phase.');\n\t\t}\n\t\tif (player.hasExpandedThisTurn) {\n\t\t\tthrow new Error('You have already made your expand decision this turn.');\n\t\t}\n\n\t\tconsole.log(`[ActionHandler] Player ${playerId} has skipped their expand action.`);\n\t\tplayer.hasExpandedThisTurn = true;\n\t}\n\t/**\n\t * Handles a player passing their turn.\n\t * @param playerId The ID of the player passing.\n\t */\n\tpublic async tryPass(playerId: string): Promise<void> {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player || this.gsm.state.currentPlayerId !== playerId) {\n\t\t\tthrow new Error(`It is not ${playerId}'s turn to pass.`);\n\t\t}\n\t\tif (player.hasPassedTurn) {\n\t\t\tthrow new Error(`Player ${playerId} has already passed.`);\n\t\t}\n\n\t\tconsole.log(`[ActionHandler] Player ${playerId} passes the turn.`);\n\t\tthis.turnManager.playerPasses(playerId);\n\t\tthis.turnManager.advanceTurn();\n\t}\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/AdvancedTriggerHandler.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/CardPlaySystem.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 17,
				"column": 15,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 17,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [524, 527], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [524, 527], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { GameStateManager } from './GameStateManager';\nimport type { EventBus } from './EventBus';\nimport {\n\tZoneIdentifier,\n\tGamePhase,\n\tCardType,\n\tStatusType,\n\tKeywordAbility,\n\tPermanentZoneType\n} from './types/enums';\nimport type { IGameObject, ICardInstance } from './types/objects'; // Assuming ICardInstance and IGameObject are relevant\n\n// Define CardPlayOptions here for now, or move to a central types file later\nexport interface CardPlayOptions {\n\ttargetIds?: string[];\n\tmode?: number | string;\n\tchosenCost?: any;\n\texpeditionChoice?: 'hero' | 'companion';\n\tfromZone: ZoneIdentifier; // e.g., ZoneIdentifier.Hand, ZoneIdentifier.Reserve\n}\n\nexport class CardPlaySystem {\n\tprivate gsm: GameStateManager;\n\tprivate eventBus: EventBus;\n\n\tconstructor(gameStateManager: GameStateManager, eventBus: EventBus) {\n\t\tthis.gsm = gameStateManager;\n\t\tthis.eventBus = eventBus;\n\t\t// If GameStateManager needs a reference back:\n\t\t// this.gsm.cardPlaySystem = this;\n\t}\n\n\t/**\n\t * Initiates playing a card according to Rule 5.1.2.\n\t */\n\tpublic async playCard(\n\t\tplayerId: string,\n\t\tcardInstanceId: string,\n\t\toptions: CardPlayOptions\n\t): Promise<void> {\n\t\tconsole.log(\n\t\t\t`[CardPlaySystem] Player ${playerId} attempts to play card ${cardInstanceId} from ${options.fromZone} with options:`,\n\t\t\toptions\n\t\t);\n\n\t\tconst player = this.gsm.getPlayer(playerId); // Assumes gsm.getPlayer() exists\n\t\tif (!player) {\n\t\t\tconsole.error(`[CardPlaySystem] Player ${playerId} not found.`);\n\t\t\tthis.eventBus.publish('cardPlayFailed', {\n\t\t\t\tplayerId,\n\t\t\t\tcardInstanceId,\n\t\t\t\toptions,\n\t\t\t\terror: 'Player not found'\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconst sourceZoneObject = this.gsm.getZoneByIdentifier(options.fromZone, playerId);\n\t\tif (!sourceZoneObject) {\n\t\t\tconsole.error(\n\t\t\t\t`[CardPlaySystem] Source zone ${options.fromZone} not found for player ${playerId}.`\n\t\t\t);\n\t\t\tthis.eventBus.publish('cardPlayFailed', {\n\t\t\t\tplayerId,\n\t\t\t\tcardInstanceId,\n\t\t\t\toptions,\n\t\t\t\terror: `Source zone ${options.fromZone} not found`\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconst cardInstance = sourceZoneObject.findById(cardInstanceId) as\n\t\t\t| ICardInstance\n\t\t\t| IGameObject\n\t\t\t| undefined; // Assuming findById returns the entity\n\t\tif (!cardInstance) {\n\t\t\tconsole.error(\n\t\t\t\t`[CardPlaySystem] Card ${cardInstanceId} not found in player ${playerId}'s ${options.fromZone}.`\n\t\t\t);\n\t\t\tthis.eventBus.publish('cardPlayFailed', {\n\t\t\t\tplayerId,\n\t\t\t\tcardInstanceId,\n\t\t\t\toptions,\n\t\t\t\terror: `Card ${cardInstanceId} not found in ${options.fromZone}`\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tconst cardDefinition = this.gsm.getCardDefinition(cardInstance.definitionId);\n\t\tif (!cardDefinition) {\n\t\t\tconsole.error(\n\t\t\t\t`[CardPlaySystem] Card definition ${cardInstance.definitionId} not found for card ${cardInstanceId}.`\n\t\t\t);\n\t\t\tthis.eventBus.publish('cardPlayFailed', {\n\t\t\t\tplayerId,\n\t\t\t\tcardInstanceId,\n\t\t\t\toptions,\n\t\t\t\terror: `Card definition ${cardInstance.definitionId} not found`\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Legality Checks (Rule 5.1.2.f - though some checks are done earlier, Rule 5.1.1)\n\t\tif (this.gsm.state.currentPlayerId !== playerId) {\n\t\t\tconsole.error(`[CardPlaySystem] Legality Check Failed: Not player ${playerId}'s turn.`);\n\t\t\tthis.eventBus.publish('cardPlayFailed', {\n\t\t\t\tplayerId,\n\t\t\t\tcardInstanceId,\n\t\t\t\tdefinitionId: cardDefinition.id,\n\t\t\t\toptions,\n\t\t\t\terror: \"Not player's turn\"\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tif (this.gsm.state.currentPhase !== GamePhase.Afternoon) {\n\t\t\tconsole.error(\n\t\t\t\t`[CardPlaySystem] Legality Check Failed: Can only play cards in Afternoon phase. Current: ${this.gsm.state.currentPhase}`\n\t\t\t);\n\t\t\tthis.eventBus.publish('cardPlayFailed', {\n\t\t\t\tplayerId,\n\t\t\t\tcardInstanceId,\n\t\t\t\tdefinitionId: cardDefinition.id,\n\t\t\t\toptions,\n\t\t\t\terror: 'Not Afternoon phase'\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\t// Basic ownership check for cards from hand/reserve\n\t\tif (options.fromZone === ZoneIdentifier.Hand || options.fromZone === ZoneIdentifier.Reserve) {\n\t\t\tif (cardInstance.ownerId !== playerId) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t`[CardPlaySystem] Legality Check Failed: Player ${playerId} does not own card ${cardInstanceId}.`\n\t\t\t\t);\n\t\t\t\tthis.eventBus.publish('cardPlayFailed', {\n\t\t\t\t\tplayerId,\n\t\t\t\t\tcardInstanceId,\n\t\t\t\t\tdefinitionId: cardDefinition.id,\n\t\t\t\t\toptions,\n\t\t\t\t\terror: 'Player does not own card'\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// TODO: More legality checks: Can play from zone? Targets valid? Modes valid? etc.\n\n\t\tconsole.log(\n\t\t\t`[CardPlaySystem] Player ${playerId} declared intent to play ${cardDefinition.name} (ID: ${cardInstanceId}). Targets: ${options.targetIds}, Mode: ${options.mode}`\n\t\t);\n\n\t\t// Move to Limbo (Rule 5.1.2.g)\n\t\tconst limboZone = this.gsm.state.sharedZones.limbo;\n\t\tconst limboCardObject = this.gsm.moveEntity(\n\t\t\tcardInstanceId,\n\t\t\tsourceZoneObject,\n\t\t\tlimboZone,\n\t\t\tplayerId\n\t\t) as IGameObject | null;\n\n\t\tif (!limboCardObject) {\n\t\t\tconsole.error(`[CardPlaySystem] Failed to move card ${cardInstanceId} to Limbo.`);\n\t\t\t// eventBus publish handled by moveEntity or subsequent failures\n\t\t\treturn;\n\t\t}\n\t\tconsole.log(\n\t\t\t`[CardPlaySystem] Card ${cardDefinition.name} (Limbo ID: ${limboCardObject.id}) moved to Limbo.`\n\t\t);\n\n\t\t// Fleeting Status Application (Rules 5.2.1.b, 5.2.2.b, 5.2.3 remark, 5.2.4.a)\n\t\tlet appliedFleeting = false;\n\t\tif (options.fromZone === ZoneIdentifier.Reserve) {\n\t\t\tif (\n\t\t\t\t!(\n\t\t\t\t\tlimboCardObject.type === CardType.Permanent &&\n\t\t\t\t\tlimboCardObject.permanentZoneType === PermanentZoneType.Landmark\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tthis.gsm.statusHandler.applyStatusEffect(limboCardObject, StatusType.Fleeting);\n\t\t\t\tconsole.log(\n\t\t\t\t\t`[CardPlaySystem] Applied Fleeting to ${limboCardObject.name} (played from Reserve).`\n\t\t\t\t);\n\t\t\t\tappliedFleeting = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!appliedFleeting && limboCardObject.type === CardType.Spell) {\n\t\t\t// Check for intrinsic Fleeting keyword on the spell definition\n\t\t\tif (\n\t\t\t\tcardDefinition.abilities.some(\n\t\t\t\t\t(ab) => ab.keyword === KeywordAbility.Fleeting && ab.abilityType === 'passive'\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// Make sure it's a passive keyword\n\t\t\t\tthis.gsm.statusHandler.applyStatusEffect(limboCardObject, StatusType.Fleeting);\n\t\t\t\tconsole.log(\n\t\t\t\t\t`[CardPlaySystem] Applied Fleeting to Spell ${limboCardObject.name} (intrinsic keyword).`\n\t\t\t\t);\n\t\t\t}\n\t\t\t// TODO: Rule 5.2.4.a.3 - Passive ability grants/loses Fleeting (requires passive ability system)\n\t\t}\n\n\t\t// TODO: Rule 5.1.2.h: Pay Costs\n\t\tconsole.log(`[CardPlaySystem] TODO: Implement Pay Costs for ${limboCardObject.name}.`);\n\n\t\t// TODO: Rule 5.1.2.i: Resolve Card (Move to final zone, process effects)\n\t\tconsole.log(`[CardPlaySystem] TODO: Implement Resolve Card for ${limboCardObject.name}.`);\n\n\t\t// For now, publish a generic event. This will be refined once costs/resolution are added.\n\t\tthis.eventBus.publish('cardPlayed', {\n\t\t\tplayerId,\n\t\t\tcardId: limboCardObject.id, // Using limbo object ID\n\t\t\tdefinitionId: cardDefinition.id,\n\t\t\toptions,\n\t\t\tmessage: `${cardDefinition.name} play process initiated and moved to Limbo.`\n\t\t});\n\t}\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/CostProcessor.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/EffectProcessor.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 12,
				"column": 33,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 12,
				"endColumn": 36,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [478, 481], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [478, 481], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 477,
				"column": 32,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 477,
				"endColumn": 35,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [15081, 15084], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [15081, 15084], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 477,
				"column": 52,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 477,
				"endColumn": 55,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [15101, 15104], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [15101, 15104], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 487,
				"column": 12,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 487,
				"endColumn": 15,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [15352, 15355], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [15352, 15355], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 588,
				"column": 70,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 588,
				"endColumn": 73,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [18987, 18990], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [18987, 18990], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 5,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { GameStateManager } from './GameStateManager';\nimport type { IGameObject } from './types/objects';\nimport type { IEffect, IEffectStep } from './types/abilities';\nimport { CounterType, StatusType, ZoneIdentifier } from './types/enums';\nimport { isGameObject } from './types/objects';\n\n/**\n * Processes effect resolution with all core effect verbs\n * Rule 7.3 - Keyword Actions and core game effects\n */\nexport class EffectProcessor {\n\tprivate currentTriggerPayload: any | null = null;\n\n\tconstructor(private gsm: GameStateManager) {}\n\n\t/**\n\t * Resolves a complete effect with all its steps\n\t * Rule 1.2.6 - Effects are changes to the game state\n\t */\n\tpublic async resolveEffect(effect: IEffect, optionalCasterObject?: IGameObject): Promise<void> {\n\t\tconst sourceIdForLog = effect.sourceObjectId || optionalCasterObject?.id || 'unknown source';\n\t\tconsole.log(\n\t\t\t`[EffectProcessor] Resolving effect from ${sourceIdForLog} with ${effect.steps.length} steps. Trigger: ${effect._triggerPayload ? JSON.stringify(effect._triggerPayload) : 'none'}`\n\t\t);\n\n\t\tthis.currentTriggerPayload = effect._triggerPayload || null;\n\n\t\tlet sourceObjectForContext: IGameObject | undefined | null = optionalCasterObject;\n\t\tif (effect.sourceObjectId) {\n\t\t\tconst mainSource = this.gsm.getObject(effect.sourceObjectId);\n\t\t\tif (mainSource) {\n\t\t\t\tsourceObjectForContext = mainSource;\n\t\t\t} else {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[EffectProcessor] Could not find sourceObjectId ${effect.sourceObjectId} from effect for ${sourceIdForLog}.`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tfor (const step of effect.steps) {\n\t\t\t\ttry {\n\t\t\t\t\tawait this.resolveEffectStep(step, sourceObjectForContext);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t`[EffectProcessor] Error resolving step ${JSON.stringify(step)} for effect from ${sourceIdForLog}:`,\n\t\t\t\t\t\terror\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.currentTriggerPayload = null;\n\t\t}\n\t}\n\n\t/**\n\t * Resolves a single effect step based on its verb\n\t */\n\tprivate async resolveEffectStep(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\t// Skip optional effects if conditions not met\n\t\tif (step.isOptional && !this.shouldExecuteOptionalEffect(step)) {\n\t\t\tconsole.log(`[EffectProcessor] Skipping optional effect: ${step.verb}`);\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`[EffectProcessor] Executing ${step.verb} for source ${sourceObjectForContext?.name || 'system'}`\n\t\t);\n\n\t\tswitch (step.verb.toLowerCase()) {\n\t\t\tcase 'draw':\n\t\t\t\tawait this.effectDraw(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tcase 'discard':\n\t\t\t\tawait this.effectDiscard(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tcase 'resupply':\n\t\t\t\tawait this.effectResupply(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tcase 'moveforward':\n\t\t\tcase 'move_forward':\n\t\t\t\tawait this.effectMoveForward(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tcase 'movebackward':\n\t\t\tcase 'move_backward':\n\t\t\t\tawait this.effectMoveBackward(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tcase 'create':\n\t\t\t\tawait this.effectCreate(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tcase 'augment':\n\t\t\t\tawait this.effectAugment(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tcase 'exchange':\n\t\t\t\tawait this.effectExchange(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tcase 'gaincounter':\n\t\t\tcase 'gain_counter':\n\t\t\t\tawait this.effectGainCounter(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tcase 'losecounter':\n\t\t\tcase 'lose_counter':\n\t\t\t\tawait this.effectLoseCounter(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tcase 'gainstatus':\n\t\t\tcase 'gain_status':\n\t\t\t\tawait this.effectGainStatus(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tcase 'losestatus':\n\t\t\tcase 'lose_status':\n\t\t\t\tawait this.effectLoseStatus(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tcase 'moveto':\n\t\t\tcase 'move_to':\n\t\t\t\tawait this.effectMoveTo(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tcase 'ready':\n\t\t\t\tawait this.effectReady(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tcase 'exhaust':\n\t\t\t\tawait this.effectExhaust(step, sourceObjectForContext);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn(`[EffectProcessor] Unknown effect verb: ${step.verb}`);\n\t\t}\n\t}\n\n\t/**\n\t * Rule 7.3.1 - Draw: Each player draws cards equal to the number specified\n\t */\n\tprivate async effectDraw(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\tconst targets = this.resolveTargets(step.targets, sourceObjectForContext);\n\t\tconst count = step.parameters?.count || 1;\n\n\t\tfor (const target of targets) {\n\t\t\tif (typeof target === 'string') {\n\t\t\t\t// Target is a player ID\n\t\t\t\tawait this.gsm.drawCards(target, count);\n\t\t\t\tconsole.log(`[EffectProcessor] Player ${target} drew ${count} cards`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Rule 7.3.2 - Discard: Players discard specified cards\n\t */\n\tprivate async effectDiscard(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\tconst targets = this.resolveTargets(step.targets, sourceObjectForContext);\n\t\tconst count = step.parameters?.count || 1;\n\n\t\tfor (const target of targets) {\n\t\t\tif (typeof target === 'string') {\n\t\t\t\tconst player = this.gsm.getPlayer(target);\n\t\t\t\tif (!player) continue;\n\n\t\t\t\t// Discard cards from hand\n\t\t\t\tconst handCards = player.zones.hand.getAll().slice(0, count);\n\t\t\t\tfor (const card of handCards) {\n\t\t\t\t\tconst cardId = isGameObject(card) ? card.objectId : card.instanceId;\n\t\t\t\t\tthis.gsm.moveEntity(cardId, player.zones.hand, player.zones.discardPileZone, target);\n\t\t\t\t}\n\t\t\t\tconsole.log(`[EffectProcessor] Player ${target} discarded ${handCards.length} cards`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Rule 7.3.3 - Resupply: Move cards from discard pile to reserve\n\t */\n\tprivate async effectResupply(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\tconst targets = this.resolveTargets(step.targets, sourceObjectForContext);\n\t\tconst count = step.parameters?.count || 1;\n\n\t\tfor (const target of targets) {\n\t\t\tif (typeof target === 'string') {\n\t\t\t\tconst player = this.gsm.getPlayer(target);\n\t\t\t\tif (!player) continue;\n\n\t\t\t\tconst discardCards = player.zones.discardPileZone.getAll().slice(0, count);\n\t\t\t\tfor (const card of discardCards) {\n\t\t\t\t\tthis.gsm.moveEntity(\n\t\t\t\t\t\tisGameObject(card) ? card.objectId : card.instanceId,\n\t\t\t\t\t\tplayer.zones.discardPileZone,\n\t\t\t\t\t\tplayer.zones.reserve,\n\t\t\t\t\t\ttarget\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconsole.log(`[EffectProcessor] Player ${target} resupplied ${discardCards.length} cards`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Rule 7.3.4 - Move Forward: Expeditions move forward\n\t */\n\tprivate async effectMoveForward(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\tconst targets = this.resolveTargets(step.targets, sourceObjectForContext);\n\t\tconst distance = step.parameters?.distance || 1;\n\n\t\tfor (const target of targets) {\n\t\t\tif (typeof target === 'string') {\n\t\t\t\tconst player = this.gsm.getPlayer(target);\n\t\t\t\tif (!player) continue;\n\n\t\t\t\t// Move both expeditions forward\n\t\t\t\tplayer.heroExpedition.position += distance;\n\t\t\t\tplayer.companionExpedition.position += distance;\n\t\t\t\tconsole.log(`[EffectProcessor] Player ${target} expeditions moved forward ${distance}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Rule 7.3.5 - Move Backward: Expeditions move backward\n\t */\n\tprivate async effectMoveBackward(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\tconst targets = this.resolveTargets(step.targets, sourceObjectForContext);\n\t\tconst distance = step.parameters?.distance || 1;\n\n\t\tfor (const target of targets) {\n\t\t\tif (typeof target === 'string') {\n\t\t\t\tconst player = this.gsm.getPlayer(target);\n\t\t\t\tif (!player) continue;\n\n\t\t\t\t// Move both expeditions backward (minimum 0)\n\t\t\t\tplayer.heroExpedition.position = Math.max(0, player.heroExpedition.position - distance);\n\t\t\t\tplayer.companionExpedition.position = Math.max(\n\t\t\t\t\t0,\n\t\t\t\t\tplayer.companionExpedition.position - distance\n\t\t\t\t);\n\t\t\t\tconsole.log(`[EffectProcessor] Player ${target} expeditions moved backward ${distance}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Rule 7.3.6 - Create: Create tokens or emblems\n\t */\n\tprivate async effectCreate(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\tconst targets = this.resolveTargets(step.targets, sourceObjectForContext);\n\t\t// const tokenType = step.parameters?.tokenType || 'Character'; // More specific: definitionId\n\t\tconst count = step.parameters?.count || 1;\n\t\tconst definitionId = step.parameters?.definitionId; // This is crucial\n\n\t\tif (!definitionId) {\n\t\t\tconsole.warn('[EffectProcessor] Create effect called without definitionId.');\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const target of targets) {\n\t\t\tif (typeof target === 'string') {\n\t\t\t\tconst player = this.gsm.getPlayer(target);\n\t\t\t\tif (!player) continue;\n\n\t\t\t\t// TODO: Create token objects\n\t\t\t\tconsole.log(`[EffectProcessor] Created ${count} tokens (${definitionId}) for ${target}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Rule 7.3.7 - Augment: Give objects new abilities\n\t */\n\tprivate async effectAugment(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\tconst targets = this.resolveTargets(step.targets, sourceObjectForContext);\n\t\tconst ability = step.parameters?.ability; // This should be a full IAbility object\n\n\t\tif (!ability) {\n\t\t\tconsole.warn('[EffectProcessor] Augment effect called without ability.');\n\t\t\treturn;\n\t\t}\n\t\tfor (const target of targets) {\n\t\t\tif (typeof target === 'object' && 'objectId' in target && ability) {\n\t\t\t\ttarget.abilities.push(ability);\n\t\t\t\tconsole.log(`[EffectProcessor] Augmented ${target.name} with new ability`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Rule 7.3.8 - Exchange: Swap objects between zones\n\t */\n\tprivate async effectExchange(\n\t\t_step: IEffectStep,\n\t\t_sourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\t// TODO: Implement object exchange logic based on parameters (e.g., targetA, targetB, zoneA, zoneB)\n\t\tconsole.log(`[EffectProcessor] Exchange not fully implemented`);\n\t}\n\n\t/**\n\t * Gain Counter: Add counters to objects\n\t */\n\tprivate async effectGainCounter(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\tconst targets = this.resolveTargets(step.targets, sourceObjectForContext);\n\t\tconst counterType = step.parameters?.counterType || CounterType.Boost;\n\t\tconst amount = step.parameters?.amount || 1;\n\n\t\tfor (const target of targets) {\n\t\t\tif (this.isTargetGameObject(target)) {\n\t\t\t\tconst current = target.counters.get(counterType) || 0;\n\t\t\t\ttarget.counters.set(counterType, current + amount);\n\t\t\t\tconsole.log(`[EffectProcessor] ${target.name} gained ${amount} ${counterType} counters`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Lose Counter: Remove counters from objects\n\t */\n\tprivate async effectLoseCounter(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\tconst targets = this.resolveTargets(step.targets, sourceObjectForContext);\n\t\tconst counterType = step.parameters?.counterType || CounterType.Boost;\n\t\tconst amount = step.parameters?.amount || 1;\n\n\t\tfor (const target of targets) {\n\t\t\tif (this.isTargetGameObject(target)) {\n\t\t\t\tconst current = target.counters.get(counterType) || 0;\n\t\t\t\ttarget.counters.set(counterType, Math.max(0, current - amount));\n\t\t\t\tconsole.log(`[EffectProcessor] ${target.name} lost ${amount} ${counterType} counters`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gain Status: Add status effects to objects\n\t */\n\tprivate async effectGainStatus(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\tconst targets = this.resolveTargets(step.targets, sourceObjectForContext);\n\t\tconst statusType = step.parameters?.statusType;\n\t\tif (!statusType) {\n\t\t\tconsole.warn('[EffectProcessor] GainStatus effect called without statusType.');\n\t\t\treturn;\n\t\t}\n\t\tfor (const target of targets) {\n\t\t\tif (this.isTargetGameObject(target) && statusType) {\n\t\t\t\ttarget.statuses.add(statusType);\n\t\t\t\tconsole.log(`[EffectProcessor] ${target.name} gained ${statusType} status`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Lose Status: Remove status effects from objects\n\t */\n\tprivate async effectLoseStatus(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\tconst targets = this.resolveTargets(step.targets, sourceObjectForContext);\n\t\tconst statusType = step.parameters?.statusType;\n\t\tif (!statusType) {\n\t\t\tconsole.warn('[EffectProcessor] LoseStatus effect called without statusType.');\n\t\t\treturn;\n\t\t}\n\t\tfor (const target of targets) {\n\t\t\tif (this.isTargetGameObject(target) && statusType) {\n\t\t\t\ttarget.statuses.delete(statusType);\n\t\t\t\tconsole.log(`[EffectProcessor] ${target.name} lost ${statusType} status`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Move To: Move objects to specified zones\n\t */\n\tprivate async effectMoveTo(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\tconst targets = this.resolveTargets(step.targets, sourceObjectForContext);\n\t\tconst destinationZoneType = step.parameters?.zone as ZoneIdentifier;\n\n\t\tif (!destinationZoneType) {\n\t\t\tconsole.warn('[EffectProcessor] MoveTo effect called without destination zone type.');\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const target of targets) {\n\t\t\tif (this.isTargetGameObject(target)) {\n\t\t\t\tconst currentZone = this.gsm.findZoneOfObject(target.objectId);\n\t\t\t\t// Determine target player for zone context. If 'self' was resolved to an object, use its controller.\n\t\t\t\t// If target is a player ID (e.g. from 'controller' target), use that.\n\t\t\t\t// Fallback to the target's own controller if it's an object.\n\t\t\t\tconst zoneOwnerId = typeof target === 'string' ? target : target.controllerId;\n\n\t\t\t\tconst destZone = this.findZoneByType(zoneOwnerId, destinationZoneType);\n\n\t\t\t\tif (currentZone && destZone) {\n\t\t\t\t\tthis.gsm.moveEntity(target.objectId, currentZone, destZone, target.controllerId); // Movement uses object's controller for ownership context\n\t\t\t\t\tconsole.log(`[EffectProcessor] Moved ${target.name} to ${destinationZoneType}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Ready: Remove Exhausted status\n\t */\n\tprivate async effectReady(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\tconst targets = this.resolveTargets(step.targets, sourceObjectForContext);\n\n\t\tfor (const target of targets) {\n\t\t\tif (this.isTargetGameObject(target)) {\n\t\t\t\ttarget.statuses.delete(StatusType.Exhausted);\n\t\t\t\tconsole.log(`[EffectProcessor] ${target.name} became ready`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Exhaust: Add Exhausted status\n\t */\n\tprivate async effectExhaust(\n\t\tstep: IEffectStep,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): Promise<void> {\n\t\tconst targets = this.resolveTargets(step.targets, sourceObjectForContext);\n\n\t\tfor (const target of targets) {\n\t\t\tif (this.isTargetGameObject(target)) {\n\t\t\t\ttarget.statuses.add(StatusType.Exhausted);\n\t\t\t\tconsole.log(`[EffectProcessor] ${target.name} became exhausted`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Type guard to check if a target is a game object\n\t */\n\tprivate isTargetGameObject(\n\t\ttarget: IGameObject | string | undefined | null\n\t): target is IGameObject {\n\t\treturn typeof target === 'object' && target !== null && 'objectId' in target;\n\t}\n\n\t/**\n\t * Helper to get a value from a nested object using a dot-separated path.\n\t * Example: getValueFromPath(payload, 'object.id')\n\t */\n\tprivate getValueFromPath(obj: any, path: string): any {\n\t\tif (!obj) return undefined;\n\t\tconst properties = path.split('.');\n\t\treturn properties.reduce((prev, curr) => prev && prev[curr], obj);\n\t}\n\n\t/**\n\t * Resolves effect targets based on target specification\n\t */\n\tprivate resolveTargets(\n\t\ttargets: any,\n\t\tsourceObjectForContext?: IGameObject | null\n\t): (IGameObject | string)[] {\n\t\tif (!targets) return [];\n\n\t\tif (typeof targets === 'string') {\n\t\t\tswitch (targets.toLowerCase()) {\n\t\t\t\tcase 'self':\n\t\t\t\t\treturn sourceObjectForContext ? [sourceObjectForContext] : [];\n\t\t\t\tcase 'controller':\n\t\t\t\t\treturn sourceObjectForContext ? [sourceObjectForContext.controllerId] : [];\n\t\t\t\t// TODO: Add 'opponent', 'all_players', 'all_objects_in_zone' etc.\n\t\t\t\tdefault: {\n\t\t\t\t\t// Assume it might be a specific objectId or playerId if it's a string not matching keywords\n\t\t\t\t\tconst objById = this.gsm.getObject(targets);\n\t\t\t\t\tif (objById) return [objById];\n\t\t\t\t\t// Could be a player ID if not an object ID\n\t\t\t\t\tif (this.gsm.getPlayer(targets)) return [targets];\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[EffectProcessor] Unresolved string target that is not 'self', 'controller', a known object ID, or a player ID: ${targets}`\n\t\t\t\t\t);\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (typeof targets === 'object' && targets.type) {\n\t\t\tswitch (targets.type.toLowerCase()) {\n\t\t\t\tcase 'fromtrigger':\n\t\t\t\t\tif (targets.path && this.currentTriggerPayload) {\n\t\t\t\t\t\tconst value = this.getValueFromPath(this.currentTriggerPayload, targets.path);\n\t\t\t\t\t\tif (value === undefined) {\n\t\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t\t`[EffectProcessor] Path '${targets.path}' yielded undefined from trigger payload:`,\n\t\t\t\t\t\t\t\tthis.currentTriggerPayload\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\t\t\t// Assume it's an ID\n\t\t\t\t\t\t\tconst objFromPayloadId = this.gsm.getObject(value);\n\t\t\t\t\t\t\treturn objFromPayloadId ? [objFromPayloadId] : [value]; // Return ID if object not found, could be player ID\n\t\t\t\t\t\t} else if (this.isTargetGameObject(value)) {\n\t\t\t\t\t\t\t// If payload directly contains an object\n\t\t\t\t\t\t\treturn [value];\n\t\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\t\t// If payload path points to an array of items\n\t\t\t\t\t\t\treturn value\n\t\t\t\t\t\t\t\t.map((item) => {\n\t\t\t\t\t\t\t\t\tif (typeof item === 'string') {\n\t\t\t\t\t\t\t\t\t\tconst objItem = this.gsm.getObject(item);\n\t\t\t\t\t\t\t\t\t\treturn objItem ? objItem : item;\n\t\t\t\t\t\t\t\t\t} else if (this.isTargetGameObject(item)) {\n\t\t\t\t\t\t\t\t\t\treturn item;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.filter((item) => item !== null) as (IGameObject | string)[];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t`[EffectProcessor] Unhandled value type from trigger payload path ${targets.path}:`,\n\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t'[EffectProcessor] \"fromTrigger\" target type requires a path and active trigger payload.'\n\t\t\t\t\t);\n\t\t\t\t\treturn [];\n\t\t\t\tcase 'select': // Placeholder for more complex selections\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`[EffectProcessor] Complex target selection for type '${targets.type}' with criteria '${targets.criteria}' not yet fully implemented.`\n\t\t\t\t\t);\n\t\t\t\t\t// This would involve player choice, filtering objects based on criteria (e.g. targets.criteria)\n\t\t\t\t\treturn [];\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn(`[EffectProcessor] Unknown target object type: ${targets.type}`);\n\t\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\n\t\t// If targets is an array, assume it's an array of IDs or IGameObjects\n\t\tif (Array.isArray(targets)) {\n\t\t\treturn targets\n\t\t\t\t.map((t) => {\n\t\t\t\t\tif (typeof t === 'string') {\n\t\t\t\t\t\tconst obj = this.gsm.getObject(t);\n\t\t\t\t\t\treturn obj ? obj : t; // Return ID if not found (could be player ID)\n\t\t\t\t\t}\n\t\t\t\t\treturn t;\n\t\t\t\t})\n\t\t\t\t.filter((t) => t !== null && t !== undefined) as (IGameObject | string)[];\n\t\t}\n\n\t\tconsole.warn('[EffectProcessor] Unresolved target specification:', targets);\n\t\treturn [];\n\t}\n\n\t/**\n\t * Finds a zone by type for a player\n\t */\n\tprivate findZoneByType(playerId: string, zoneType: ZoneIdentifier): any {\n\t\t// Return type should be IZone | null\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) {\n\t\t\tconsole.warn(`[EffectProcessor] Player not found for findZoneByType: ${playerId}`);\n\t\t\treturn null;\n\t\t}\n\n\t\tswitch (zoneType) {\n\t\t\tcase ZoneIdentifier.Hand:\n\t\t\t\treturn player.zones.handZone;\n\t\t\tcase ZoneIdentifier.Reserve:\n\t\t\t\treturn player.zones.reserveZone;\n\t\t\tcase ZoneIdentifier.Expedition:\n\t\t\t\treturn player.zones.expeditionZone;\n\t\t\tcase ZoneIdentifier.Landmark:\n\t\t\t\treturn player.zones.landmarkZone;\n\t\t\tcase ZoneIdentifier.Discard:\n\t\t\t\treturn player.zones.discardPileZone;\n\t\t\tcase ZoneIdentifier.Mana:\n\t\t\t\treturn player.zones.manaZone;\n\t\t\tcase ZoneIdentifier.Hero:\n\t\t\t\treturn player.zones.heroZone;\n\t\t\tcase ZoneIdentifier.Limbo:\n\t\t\t\treturn this.gsm.state.sharedZones.limbo;\n\t\t\tcase ZoneIdentifier.Adventure:\n\t\t\t\treturn this.gsm.state.sharedZones.adventureZone;\n\t\t\tdefault:\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[EffectProcessor] Unknown or unhandled zone type for findZoneByType: ${zoneType}`\n\t\t\t\t);\n\t\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Determines if optional effects should execute\n\t */\n\tprivate shouldExecuteOptionalEffect(_step: IEffectStep): boolean {\n\t\t// TODO: Add player choice mechanism for optional effects\n\t\t// For now, always execute optional effects\n\t\treturn true;\n\t}\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/EffectResolver.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 148,
				"column": 39,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 148,
				"endColumn": 54
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { GameStateManager } from './GameStateManager';\nimport type { IEffect, IEffectStep } from './types/abilities';\nimport { CounterType, StatusType, ZoneIdentifier } from './types/enums';\nimport type { IGameObject } from './types/objects';\n\nexport class EffectResolver {\n\tconstructor(private gsm: GameStateManager) {}\n\tpublic resolve(effect: IEffect) {\n\t\tconsole.log(`[EffectResolver] Resolving effect from source ${effect.sourceObjectId}`);\n\t\tfor (const step of effect.steps) {\n\t\t\tthis.resolveStep(step, effect.sourceObjectId);\n\t\t}\n\t}\n\n\tprivate resolveStep(step: IEffectStep, sourceObjectId?: string) {\n\t\tlet targets: IGameObject[] = [];\n\n\t\t// This block will grow as more target types are supported.\n\t\tif (step.targets === 'self' && sourceObjectId) {\n\t\t\tconst selfObject = this.gsm.getObject(sourceObjectId);\n\t\t\tif (selfObject) targets.push(selfObject);\n\t\t}\n\n\t\t// Rule 1.2.6.f / 6.5.h: If part of an effect cannot happen (e.g., no valid targets), the rest still happens.\n\t\tif (targets.length === 0 && step.targets !== 'controller') {\n\t\t\t// controller/player targets are handled differently\n\t\t\tconsole.warn(`[EffectResolver] No valid targets found for verb ${step.verb}`);\n\t\t\t// Do not return for some verbs that can have no targets, like 'draw'\n\t\t\tif (step.verb !== 'draw' && step.verb !== 'createToken') return; // Example\n\t\t}\n\n\t\tswitch (step.verb) {\n\t\t\tcase 'gainStatus': {\n\t\t\t\tconst statusToGain = step.parameters?.status as StatusType;\n\t\t\t\tif (!statusToGain) {\n\t\t\t\t\tconsole.error(\"Effect 'gainStatus' missing status parameter.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttargets.forEach((target) => {\n\t\t\t\t\t// Rule 2.4.1.f: An object that already has a status cannot gain that status.\n\t\t\t\t\tif (target.statuses.has(statusToGain)) {\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`[EffectResolver] Object ${target.objectId} already has status ${statusToGain}.`\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.statuses.add(statusToGain);\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`[EffectResolver] Object ${target.objectId} ('${target.name}') gained status: ${statusToGain}`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.gsm.eventBus.publish('statusGained', {\n\t\t\t\t\t\t\ttargetId: target.objectId,\n\t\t\t\t\t\t\tstatus: statusToGain\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Implement counter modification verbs\n\t\t\tcase 'gainCounter': {\n\t\t\t\t// Rule 2.5.f / 7.3.12\n\t\t\t\tconst type = step.parameters?.type as CounterType;\n\t\t\t\tconst amount = (step.parameters?.amount as number) ?? 1;\n\t\t\t\tif (!type) {\n\t\t\t\t\tconsole.error(\"Effect 'gainCounter' missing type parameter.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttargets.forEach((target) => {\n\t\t\t\t\tconst currentAmount = target.counters.get(type) || 0;\n\t\t\t\t\ttarget.counters.set(type, currentAmount + amount);\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`[EffectResolver] Object ${target.objectId} gained ${amount} ${type} counter(s). Now has ${currentAmount + amount}.`\n\t\t\t\t\t);\n\t\t\t\t\tthis.gsm.eventBus.publish('counterGained', { targetId: target.objectId, type, amount });\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'removeCounter': {\n\t\t\t\t// Rule 2.5.g\n\t\t\t\tconst type = step.parameters?.type as CounterType;\n\t\t\t\tconst amount = (step.parameters?.amount as number) ?? 1;\n\t\t\t\tif (!type) {\n\t\t\t\t\tconsole.error(\"Effect 'removeCounter' missing type parameter.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttargets.forEach((target) => {\n\t\t\t\t\tconst currentAmount = target.counters.get(type) || 0;\n\t\t\t\t\tif (currentAmount === 0) return;\n\t\t\t\t\tconst newAmount = Math.max(0, currentAmount - amount);\n\t\t\t\t\tif (newAmount > 0) {\n\t\t\t\t\t\ttarget.counters.set(type, newAmount);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget.counters.delete(type);\n\t\t\t\t\t}\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`[EffectResolver] Object ${target.objectId} lost ${amount} ${type} counter(s). Now has ${newAmount}.`\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'doubleCounters': {\n\t\t\t\t// Rule 7.3.6\n\t\t\t\tconst type = step.parameters?.type as CounterType;\n\t\t\t\tif (!type) {\n\t\t\t\t\tconsole.error(\"Effect 'doubleCounters' missing type parameter.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttargets.forEach((target) => {\n\t\t\t\t\tconst currentAmount = target.counters.get(type) || 0;\n\t\t\t\t\tif (currentAmount > 0) {\n\t\t\t\t\t\ttarget.counters.set(type, currentAmount * 2);\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`[EffectResolver] Doubled ${type} counters on ${target.objectId}. Now has ${currentAmount * 2}.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'sacrifice': {\n\t\t\t\t// Rule 7.3.25\n\t\t\t\ttargets.forEach((target) => {\n\t\t\t\t\tconst fromZone = this.gsm.findZoneOfObject(target.objectId);\n\t\t\t\t\tif (\n\t\t\t\t\t\tfromZone &&\n\t\t\t\t\t\t(fromZone.zoneType === ZoneIdentifier.Expedition ||\n\t\t\t\t\t\t\tfromZone.zoneType === ZoneIdentifier.Landmark)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst owner = this.gsm.getPlayer(target.ownerId);\n\t\t\t\t\t\tif (owner) {\n\t\t\t\t\t\t\tthis.gsm.moveEntity(\n\t\t\t\t\t\t\t\ttarget.objectId,\n\t\t\t\t\t\t\t\tfromZone,\n\t\t\t\t\t\t\t\towner.zones.discardPileZone,\n\t\t\t\t\t\t\t\ttarget.controllerId\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconsole.log(`[EffectResolver] Object ${target.objectId} was sacrificed.`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'exchangeBoosts': {\n\t\t\t\t// Hypothetical verb for Rule 7.3.8\n\t\t\t\t// Needs to target two characters.\n\t\t\t\t// Logic to calculate the difference in boost counters and swap them.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'draw': {\n\t\t\t\tconst player = this.gsm.getPlayer(sourceObjectId!); // Simplification, target might be 'controller'\n\t\t\t\tconst amount = (step.parameters?.amount as number) ?? 1;\n\t\t\t\tif (player) {\n\t\t\t\t\tthis.gsm.drawCards(player.id, amount);\n\t\t\t\t\tconsole.log(`[EffectResolver] Player ${player.id} drew ${amount} card(s).`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'augment': {\n\t\t\t\t// Rule 7.3.3\n\t\t\t\tconst type = step.parameters?.type as CounterType;\n\t\t\t\tif (!type) {\n\t\t\t\t\tconsole.error(\"Effect 'augment' missing type parameter.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttargets.forEach((target) => {\n\t\t\t\t\tconst currentAmount = target.counters.get(type) || 0;\n\t\t\t\t\tif (currentAmount > 0) {\n\t\t\t\t\t\ttarget.counters.set(type, currentAmount + 1);\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`[EffectResolver] Augmented ${type} counter on ${target.objectId}. Now has ${currentAmount + 1}.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tconsole.warn(`[EffectResolver] Unknown verb: ${step.verb}`);\n\t\t}\n\t}\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/EventBus.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 22,
				"column": 51,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 22,
				"endColumn": 54,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [1030, 1033], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [1030, 1033], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 27,
				"column": 3,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 27,
				"endColumn": 35,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [1244, 1245], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 34,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 34,
				"endColumn": 36,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [1532, 1533], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 3,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { CounterType, GamePhase } from './types/enums';\nimport type { IGameObject } from './types/objects';\nimport type { ICardInstance } from './types/cards';\nimport type { IZone } from './types/zones';\n\ntype EventPayloads = {\n\tentityMoved: { entity: IGameObject | ICardInstance; from: IZone; to: IZone | null };\n\tentityCeasedToExist: { entity: IGameObject | ICardInstance; from: IZone };\n\tphaseChanged: { phase: GamePhase };\n\tturnAdvanced: { currentPlayerId: string };\n\tdayAdvanced: { dayNumber: number };\n\tmanaSpent: { playerId: string; amount: number };\n\tstatusGained: { targetId: string; status: string };\n\tafternoonEnded: Record<string, never>;\n\t// Add events for counter changes\n\tcounterGained: { targetId: string; type: CounterType; amount: number };\n\tcountersSpent: { sourceId: string; type: CounterType; amount: number };\n};\ntype EventType = keyof EventPayloads;\ntype EventHandler<T extends EventType> = (payload: EventPayloads[T]) => void;\nexport class EventBus {\n\tprivate subscribers: Map<EventType, EventHandler<any>[]> = new Map();\n\tsubscribe<T extends EventType>(eventType: T, handler: EventHandler<T>) {\n\t\tif (!this.subscribers.has(eventType)) {\n\t\t\tthis.subscribers.set(eventType, []);\n\t\t}\n\t\tthis.subscribers.get(eventType)!.push(handler);\n\t\tconsole.log(`[EventBus] Subscribed to ${eventType}`);\n\t}\n\n\tpublish<T extends EventType>(eventType: T, payload: EventPayloads[T]) {\n\t\tconsole.log(`[EventBus] Publishing: ${eventType}`, payload);\n\t\tif (this.subscribers.has(eventType)) {\n\t\t\tthis.subscribers.get(eventType)!.forEach((handler) => {\n\t\t\t\ttry {\n\t\t\t\t\thandler(payload);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(`Error in event handler for ${eventType}:`, error);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/GameStateManager.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'IExpeditionState' is defined but never used.",
				"line": 10,
				"column": 36,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 10,
				"endColumn": 52
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'KeywordAbility' is defined but never used.",
				"line": 12,
				"column": 23,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 12,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 40,
				"column": 23,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 40,
				"endColumn": 26,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [2003, 2006], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [2003, 2006], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 41,
				"column": 24,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 41,
				"endColumn": 27,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [2061, 2064], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [2061, 2064], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 113,
				"column": 35,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 113,
				"endColumn": 38,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [4706, 4709], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [4706, 4709], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 114,
				"column": 40,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 114,
				"endColumn": 43,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [4751, 4754], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [4751, 4754], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 126,
				"column": 36,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 126,
				"endColumn": 39,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [5066, 5069], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [5066, 5069], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 530,
				"column": 32,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 530,
				"endColumn": 35,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [17756, 17759], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [17756, 17759], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'expeditionType' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 707,
				"column": 3,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 707,
				"endColumn": 17
			},
			{
				"ruleId": "no-dupe-class-members",
				"severity": 2,
				"message": "Duplicate name 'getAllVisibleZones'.",
				"line": 862,
				"column": 2,
				"nodeType": "MethodDefinition",
				"messageId": "unexpected",
				"endLine": 882,
				"endColumn": 3
			}
		],
		"suppressedMessages": [],
		"errorCount": 4,
		"fatalErrorCount": 0,
		"warningCount": 6,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { IZone } from './types/zones';\nimport { ObjectFactory } from './ObjectFactory';\nimport { GamePhase, ZoneIdentifier, StatusType, CardType } from './types/enums';\nimport type { EventBus } from './EventBus';\nimport { GenericZone, HandZone, DiscardPileZone, LimboZone, DeckZone } from './Zone';\nimport type { IGameObject } from './types/objects';\nimport type { ICardInstance } from './types/cards';\nimport type { ZoneEntity } from './types/zones';\nimport { isGameObject } from './types/objects';\nimport type { IPlayer, IGameState, IExpeditionState, ITerrainStats } from './types/game';\nimport type { ICardDefinition } from './types/cards';\nimport { CounterType, KeywordAbility } from './types/enums';\nimport { KeywordAbilityHandler } from './KeywordAbilityHandler';\nimport { SupportAbilityHandler } from './SupportAbilityHandler';\nimport { AdvancedTriggerHandler } from './AdvancedTriggerHandler';\nimport { PlayerActionHandler } from './PlayerActionHandler';\nimport { EffectProcessor } from './EffectProcessor';\nimport { StatusEffectHandler } from './StatusEffectHandler';\nimport { ManaSystem } from './ManaSystem';\nimport { CardPlaySystem } from './CardPlaySystem';\nimport { TiebreakerSystem } from './TiebreakerSystem';\n// import { PassiveAbilityManager } from './PassiveAbilityManager'; // Removed\nimport { RuleAdjudicator } from './RuleAdjudicator';\n\nexport class GameStateManager {\n\tpublic state: IGameState;\n\tpublic objectFactory: ObjectFactory;\n\tpublic eventBus: EventBus;\n\tpublic keywordHandler: KeywordAbilityHandler;\n\tpublic supportHandler: SupportAbilityHandler;\n\tpublic triggerHandler: AdvancedTriggerHandler;\n\tpublic actionHandler: PlayerActionHandler;\n\tpublic effectProcessor: EffectProcessor;\n\tpublic statusHandler: StatusEffectHandler;\n\tpublic manaSystem: ManaSystem;\n\tpublic cardPlaySystem: CardPlaySystem;\n\tpublic tiebreakerSystem: TiebreakerSystem;\n\t// public passiveManager: PassiveAbilityManager; // Removed\n\tprivate ruleAdjudicator: RuleAdjudicator;\n\tpublic turnManager?: any; // Will be set by TurnManager\n\tpublic phaseManager?: any; // Will be set by PhaseManager\n\tprivate cardDefinitions: Map<string, ICardDefinition>;\n\n\tconstructor(playerIds: string[], cardDefinitions: ICardDefinition[], eventBus: EventBus) {\n\t\tthis.cardDefinitions = new Map(cardDefinitions.map((def) => [def.id, def]));\n\t\tthis.objectFactory = new ObjectFactory(this.cardDefinitions);\n\t\tthis.eventBus = eventBus;\n\t\tthis.keywordHandler = new KeywordAbilityHandler(this);\n\t\tthis.supportHandler = new SupportAbilityHandler(this);\n\t\tthis.triggerHandler = new AdvancedTriggerHandler(this);\n\t\tthis.actionHandler = new PlayerActionHandler(this);\n\t\tthis.effectProcessor = new EffectProcessor(this);\n\t\tthis.statusHandler = new StatusEffectHandler(this);\n\t\tthis.manaSystem = new ManaSystem(this);\n\t\tthis.cardPlaySystem = new CardPlaySystem(this); // Assuming CardPlaySystem constructor takes (gsm, eventBus)\n\t\tthis.tiebreakerSystem = new TiebreakerSystem(this);\n\t\t// this.passiveManager = new PassiveAbilityManager(this); // Removed\n\t\tthis.ruleAdjudicator = new RuleAdjudicator(this);\n\t\tthis.state = this.initializeGameState(playerIds);\n\t}\n\n\t/**\n\t * Rule 4.1: Game Setup Phase - Initialize game according to Altered rules\n\t */\n\tpublic async initializeGame(): Promise<void> {\n\t\tif (this.cardDefinitions.size === 0) {\n\t\t\tthrow new Error('No card definitions available');\n\t\t}\n\n\t\t// Rule 4.1.l: Start on Day 1, skip first Morning phase\n\t\tthis.state.currentDay = 1;\n\t\tthis.state.currentPhase = GamePhase.Noon;\n\t\tthis.state.firstMorningSkipped = true;\n\n\t\t// Rule 4.1.a-c: Initialize adventure zones and regions\n\t\tthis.initializeAdventureZones();\n\n\t\t// Initialize each player's game state\n\t\tfor (const [playerId, player] of this.state.players) {\n\t\t\tawait this.initializePlayerState(playerId, player);\n\t\t}\n\n\t\t// Rule 4.1: Determine first player (simplified for testing)\n\t\tthis.state.firstPlayerId = Array.from(this.state.players.keys())[0];\n\t\tthis.state.currentPlayerId = this.state.firstPlayerId;\n\n\t\t// Note: gameInitialized event not in EventPayloads, so skip for now\n\t\tconsole.log('[GSM] Game initialized with players:', Array.from(this.state.players.keys()));\n\t}\n\n\tprivate initializeAdventureZones(): void {\n\t\tconst adventureZone = this.state.sharedZones.adventure;\n\n\t\t// Rule 4.1.b: Create Hero and Companion regions\n\t\tconst heroRegion = {\n\t\t\tid: 'hero-region',\n\t\t\tinstanceId: 'hero-region',\n\t\t\ttype: 'HeroRegion',\n\t\t\tfaceDown: false,\n\t\t\tterrainType: 'neutral',\n\t\t\townerId: 'shared'\n\t\t};\n\n\t\tconst companionRegion = {\n\t\t\tid: 'companion-region',\n\t\t\tinstanceId: 'companion-region',\n\t\t\ttype: 'CompanionRegion',\n\t\t\tfaceDown: false,\n\t\t\tterrainType: 'neutral',\n\t\t\townerId: 'shared'\n\t\t};\n\n\t\tadventureZone.add(heroRegion as any);\n\t\tadventureZone.add(companionRegion as any);\n\n\t\t// Rule 4.1.c: Place 3 face-down Tumult cards between regions\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\tconst tumultCard = {\n\t\t\t\tid: `tumult-${i}`,\n\t\t\t\tinstanceId: `tumult-${i}`,\n\t\t\t\ttype: 'TumultCard',\n\t\t\t\tfaceDown: true,\n\t\t\t\tterrainType: 'tumult',\n\t\t\t\townerId: 'shared'\n\t\t\t};\n\t\t\tadventureZone.add(tumultCard as any);\n\t\t}\n\t}\n\n\tprivate async initializePlayerState(playerId: string, player: IPlayer): Promise<void> {\n\t\t// Rule 4.1.h: Heroes should be revealed and placed in Hero zones\n\t\tthis.placeHeroInZone(playerId);\n\n\t\t// Rule 4.1.i: Shuffle deck\n\t\tthis.initializePlayerDeck(playerId);\n\n\t\t// Rule 4.1.j: Draw 6 cards\n\t\tawait this.drawCards(playerId, 6);\n\n\t\t// Rule 4.1.k: Start with 3 Mana Orbs face-down and ready\n\t\tthis.initializeManaOrbs(playerId);\n\n\t\t// Rule 4.1: Initialize expedition state\n\t\tplayer.expeditionState = {\n\t\t\theroPosition: 0,\n\t\t\tcompanionPosition: 0,\n\t\t\theroActive: true,\n\t\t\tcompanionActive: true,\n\t\t\theroMovedThisTurn: false,\n\t\t\tcompanionMovedThisTurn: false,\n\t\t\theroStats: { forest: 0, mountain: 0, water: 0 },\n\t\t\tcompanionStats: { forest: 0, mountain: 0, water: 0 }\n\t\t};\n\t}\n\n\tprivate placeHeroInZone(playerId: string): void {\n\t\tconst player = this.getPlayer(playerId);\n\t\tif (!player) return;\n\n\t\t// Find a hero card definition\n\t\tconst heroDefinition = Array.from(this.cardDefinitions.values()).find(\n\t\t\t(def) => def.type === CardType.Hero\n\t\t);\n\n\t\tif (heroDefinition) {\n\t\t\tconst hero = this.objectFactory.createCard(heroDefinition.id, playerId);\n\t\t\thero.faceDown = false; // Heroes are revealed\n\t\t\tplayer.zones.heroZone.add(hero);\n\t\t}\n\t}\n\n\tprivate initializePlayerDeck(playerId: string): void {\n\t\tconst player = this.getPlayer(playerId);\n\t\tif (!player) return;\n\n\t\t// Add some cards to deck for testing\n\t\tconst cardDefinitions = Array.from(this.cardDefinitions.values())\n\t\t\t.filter((def) => def.type !== CardType.Hero)\n\t\t\t.slice(0, 30); // Take first 30 non-hero cards\n\n\t\tcardDefinitions.forEach((def) => {\n\t\t\tconst cardInstance = this.objectFactory.createCardInstance(def.id, playerId);\n\t\t\tplayer.zones.deckZone.add(cardInstance);\n\t\t});\n\t}\n\n\tprivate initializeManaOrbs(playerId: string): void {\n\t\tconst player = this.getPlayer(playerId);\n\t\tif (!player) return;\n\n\t\t// Rule 4.1.k: 3 Mana Orbs face-down and ready\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\tconst basicCard = Array.from(this.cardDefinitions.values())[0];\n\t\t\tif (basicCard) {\n\t\t\t\tconst manaOrb = this.objectFactory.createCard(basicCard.id, playerId);\n\t\t\t\tmanaOrb.faceDown = true;\n\t\t\t\tmanaOrb.type = CardType.ManaOrb; // Rule 3.2.9.c\n\t\t\t\tmanaOrb.statuses.delete(StatusType.Exhausted); // Ready\n\t\t\t\tplayer.zones.manaZone.add(manaOrb);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate initializeGameState(playerIds: string[]): IGameState {\n\t\tconst players = new Map<string, IPlayer>();\n\n\t\t// Create shared zones first\n\t\tconst sharedZones = {\n\t\t\tadventure: new GenericZone('shared-adventure', ZoneIdentifier.Adventure, 'visible'),\n\t\t\texpedition: new GenericZone(\n\t\t\t\t'shared-expedition-deprecated',\n\t\t\t\tZoneIdentifier.Expedition,\n\t\t\t\t'visible'\n\t\t\t),\n\t\t\tlimbo: new LimboZone()\n\t\t};\n\n\t\tplayerIds.forEach((pid) => {\n\t\t\tconst handZone = new HandZone(`${pid}-hand`, pid);\n\t\t\tconst reserveZone = new GenericZone(`${pid}-reserve`, ZoneIdentifier.Reserve, 'visible', pid);\n\t\t\tconst expeditionZone = new GenericZone(\n\t\t\t\t`${pid}-expedition`,\n\t\t\t\tZoneIdentifier.Expedition,\n\t\t\t\t'visible',\n\t\t\t\tpid\n\t\t\t);\n\n\t\t\tplayers.set(pid, {\n\t\t\t\tid: pid,\n\t\t\t\tzones: {\n\t\t\t\t\tdeckZone: new DeckZone(`${pid}-deck`, pid),\n\t\t\t\t\thandZone: handZone,\n\t\t\t\t\tdiscardPileZone: new DiscardPileZone(`${pid}-discard`, pid),\n\t\t\t\t\tmanaZone: new GenericZone(`${pid}-mana`, ZoneIdentifier.Mana, 'visible', pid),\n\t\t\t\t\treserveZone: reserveZone,\n\t\t\t\t\tlandmarkZone: new GenericZone(`${pid}-landmark`, ZoneIdentifier.Landmark, 'visible', pid),\n\t\t\t\t\theroZone: new GenericZone(`${pid}-hero`, ZoneIdentifier.Hero, 'visible', pid),\n\t\t\t\t\texpeditionZone: expeditionZone,\n\t\t\t\t\tlimboZone: sharedZones.limbo, // Reference to shared limbo zone\n\t\t\t\t\thand: handZone, // Alias for test compatibility\n\t\t\t\t\treserve: reserveZone, // Alias for test compatibility\n\t\t\t\t\texpedition: expeditionZone // Alias for test compatibility\n\t\t\t\t},\n\t\t\t\theroExpedition: { position: 0, canMove: true, hasMoved: false },\n\t\t\t\tcompanionExpedition: { position: 0, canMove: true, hasMoved: false },\n\t\t\t\thasPassedTurn: false,\n\t\t\t\thasExpandedThisTurn: false\n\t\t\t});\n\t\t});\n\n\t\treturn {\n\t\t\tplayers,\n\t\t\tsharedZones,\n\t\t\tcurrentPhase: GamePhase.Setup,\n\t\t\tcurrentPlayerId: playerIds[0],\n\t\t\tfirstPlayerId: playerIds[0],\n\t\t\tcurrentDay: 1,\n\t\t\tdayNumber: 1,\n\t\t\tfirstMorningSkipped: false,\n\t\t\tgameEnded: false,\n\t\t\ttiebreakerMode: false,\n\t\t\tactionHistory: []\n\t\t};\n\t}\n\n\tpublic resetExpandFlags(): void {\n\t\tfor (const player of this.state.players.values()) {\n\t\t\tplayer.hasExpandedThisTurn = false;\n\t\t}\n\t\tconsole.log('[GSM] Reset expand flags for all players.');\n\t}\n\n\tpublic initializeBoard(\n\t\tplayerDeckDefinitionsMap: Map<string, ICardDefinition[]>,\n\t\tstartingHandSize: number,\n\t\tinitialManaOrbs: number\n\t) {\n\t\tthis.state.players.forEach((player, playerId) => {\n\t\t\tconst deckDefinitions = playerDeckDefinitionsMap.get(playerId);\n\t\t\tif (!deckDefinitions) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst heroDefinition = deckDefinitions.find((def) => def.type === CardType.Hero);\n\t\t\tif (!heroDefinition) {\n\t\t\t\tconsole.error(`Player ${playerId}'s deck must contain exactly one Hero. Hero not found.`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst heroTempInstance = this.objectFactory.createCardInstance(heroDefinition.id, playerId);\n\t\t\tconst heroGameObject = this.objectFactory.createGameObject(\n\t\t\t\theroTempInstance,\n\t\t\t\tplayerId\n\t\t\t) as IGameObject;\n\n\t\t\tif (heroDefinition.startingCounters) {\n\t\t\t\theroGameObject.counters = new Map(heroDefinition.startingCounters);\n\t\t\t}\n\n\t\t\tplayer.zones.heroZone.add(heroGameObject);\n\n\t\t\tconst nonHeroDeckDefinitions = deckDefinitions.filter((def) => def.type !== CardType.Hero);\n\t\t\tconst deckCardInstances: ICardInstance[] = nonHeroDeckDefinitions.map((def) => {\n\t\t\t\treturn this.objectFactory.createCardInstance(def.id, playerId);\n\t\t\t});\n\n\t\t\tconst deckZone = player.zones.deck as DeckZone;\n\t\t\tdeckCardInstances.forEach((cardInstance) => deckZone.add(cardInstance));\n\t\t\tdeckZone.shuffle();\n\n\t\t\tconst topCardInstances = deckZone.getAll().slice(0, initialManaOrbs);\n\n\t\t\tfor (const cardInstance of topCardInstances) {\n\t\t\t\tconst cardId = isGameObject(cardInstance) ? cardInstance.objectId : cardInstance.instanceId;\n\t\t\t\tconst manaObject = this.moveEntity(\n\t\t\t\t\tcardId,\n\t\t\t\t\tdeckZone,\n\t\t\t\t\tplayer.zones.manaZone,\n\t\t\t\t\tplayerId\n\t\t\t\t) as IGameObject;\n\n\t\t\t\tif (manaObject && manaObject.statuses.has(StatusType.Exhausted)) {\n\t\t\t\t\tmanaObject.statuses.delete(StatusType.Exhausted);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.drawCards(playerId, startingHandSize);\n\t\t});\n\t}\n\n\tpublic moveEntity(\n\t\tentityId: string,\n\t\tfromZone: IZone,\n\t\ttoZone: IZone,\n\t\tcontrollerId: string\n\t): IGameObject | ICardInstance | null {\n\t\tconsole.log(\n\t\t\t`[GameStateManager.moveEntity] Attempting to move entityId: ${entityId} from zone: ${fromZone.id}`\n\t\t);\n\t\tconsole.log(\n\t\t\t`[GameStateManager.moveEntity] Keys in fromZone ${fromZone.id}:`,\n\t\t\tArray.from(fromZone.entities.keys())\n\t\t);\n\t\tconst sourceEntity = fromZone.remove(entityId);\n\t\tif (!sourceEntity) {\n\t\t\tconsole.error(\n\t\t\t\t`[GameStateManager.moveEntity] Entity ${entityId} really not found in zone ${fromZone.id}.`\n\t\t\t);\n\t\t\tthrow new Error(`Entity ${entityId} not found in zone ${fromZone.id}.`);\n\t\t}\n\n\t\tconst definition = this.getCardDefinition(sourceEntity.definitionId);\n\t\tif (!definition) throw new Error(`Definition not found for ${sourceEntity.definitionId}`);\n\n\t\tif (definition.type === CardType.Token && fromZone.zoneType === ZoneIdentifier.Expedition) {\n\t\t\tthis.eventBus.publish('entityCeasedToExist', { entity: sourceEntity, from: fromZone });\n\t\t\treturn null;\n\t\t}\n\n\t\tlet finalDestinationZone = toZone;\n\t\tif (toZone.ownerId && toZone.ownerId !== sourceEntity.ownerId) {\n\t\t\tconst owner = this.getPlayer(sourceEntity.ownerId);\n\t\t\tif (!owner) throw new Error(`Owner ${sourceEntity.ownerId} of entity ${entityId} not found.`);\n\t\t\tconst correctZone = Object.values(owner.zones).find((z) => z.zoneType === toZone.zoneType);\n\t\t\tif (!correctZone)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Cannot find zone of type ${toZone.zoneType} for owner ${sourceEntity.ownerId}`\n\t\t\t\t);\n\t\t\tfinalDestinationZone = correctZone;\n\t\t}\n\n\t\t// --- REPLACE THIS ENTIRE BLOCK ---\n\t\tconst countersToKeep = new Map<CounterType, number>();\n\t\tconst sourceGameObject = isGameObject(sourceEntity) ? sourceEntity : undefined;\n\t\tconst isMovingToLosingZone =\n\t\t\tfinalDestinationZone.zoneType === ZoneIdentifier.DiscardPile ||\n\t\t\tfinalDestinationZone.visibility === 'hidden';\n\n\t\tif (sourceGameObject && !isMovingToLosingZone) {\n\t\t\tconst fromZoneIsExpeditionOrLandmark = [\n\t\t\t\tZoneIdentifier.Expedition,\n\t\t\t\tZoneIdentifier.Landmark\n\t\t\t].includes(fromZone.zoneType);\n\t\t\tconst fromZoneIsReserveOrLimbo = [ZoneIdentifier.Reserve, ZoneIdentifier.Limbo].includes(\n\t\t\t\tfromZone.zoneType\n\t\t\t);\n\n\t\t\tif (fromZoneIsReserveOrLimbo) {\n\t\t\t\t// Rule 2.5.k: Objects from Reserve/Limbo keep counters (unless going to discard/hidden)\n\t\t\t\tfor (const [type, amount] of sourceGameObject.counters.entries()) {\n\t\t\t\t\tcountersToKeep.set(type, amount);\n\t\t\t\t}\n\t\t\t} else if (fromZoneIsExpeditionOrLandmark) {\n\t\t\t\tconst isMovingToReserve = finalDestinationZone.zoneType === ZoneIdentifier.Reserve;\n\t\t\t\t// Rule 7.4.6.b: Check for Seasoned keyword when moving to Reserve\n\t\t\t\tconst isSeasoned = sourceGameObject.abilities.some((a) => a.keyword === 'Seasoned');\n\n\t\t\t\tif (isSeasoned && isMovingToReserve) {\n\t\t\t\t\tconst boostCount = sourceGameObject.counters.get(CounterType.Boost);\n\t\t\t\t\tif (boostCount && boostCount > 0) {\n\t\t\t\t\t\tcountersToKeep.set(CounterType.Boost, boostCount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet newEntity: ZoneEntity;\n\t\tif (finalDestinationZone.visibility === 'visible') {\n\t\t\tnewEntity = this.objectFactory.createGameObject(sourceEntity, controllerId, countersToKeep);\n\t\t} else {\n\t\t\tnewEntity = isGameObject(sourceEntity)\n\t\t\t\t? this.objectFactory.createCardInstance(sourceEntity.definitionId, sourceEntity.ownerId)\n\t\t\t\t: sourceEntity;\n\t\t}\n\n\t\tfinalDestinationZone.add(newEntity);\n\n\t\t// Process keyword abilities and triggers for the move\n\t\tif (isGameObject(newEntity)) {\n\t\t\tthis.keywordHandler.processKeywordOnLeavePlay(newEntity, fromZone, finalDestinationZone);\n\t\t\tthis.triggerHandler.processMovementTriggers(newEntity, fromZone, finalDestinationZone);\n\t\t\t// After existing handlers, apply passive abilities\n\t\t\tthis.ruleAdjudicator.applyAllPassiveAbilities();\n\t\t}\n\n\t\tthis.eventBus.publish('entityMoved', {\n\t\t\tentity: newEntity,\n\t\t\tfrom: fromZone,\n\t\t\tto: finalDestinationZone\n\t\t});\n\t\treturn newEntity;\n\t}\n\n\tpublic getCardDefinition(id: string): ICardDefinition | undefined {\n\t\treturn this.cardDefinitions.get(id);\n\t}\n\n\tpublic getObject(id: string): IGameObject | undefined {\n\t\tfor (const zone of this.getAllVisibleZones()) {\n\t\t\tconst entity = zone.findById(id);\n\t\t\tif (entity && isGameObject(entity)) {\n\t\t\t\treturn entity;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic findZoneOfObject(objectId: string): IZone | undefined {\n\t\tfor (const zone of this.getAllVisibleZones()) {\n\t\t\tif (zone.findById(objectId)) {\n\t\t\t\treturn zone;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate *getAllVisibleZones(): Generator<IZone> {\n\t\tfor (const player of this.state.players.values()) {\n\t\t\tyield player.zones.discardPile;\n\t\t\tyield player.zones.manaZone;\n\t\t\tyield player.zones.reserve;\n\t\t\tyield player.zones.landmarkZone;\n\t\t\tyield player.zones.heroZone;\n\t\t\tyield player.zones.expedition;\n\t\t}\n\t\tyield this.state.sharedZones.adventure;\n\t\tyield this.state.sharedZones.limbo;\n\t}\n\n\tpublic getPlayer(id: string): IPlayer | undefined {\n\t\treturn this.state.players.get(id);\n\t}\n\n\tpublic getPlayerIds(): string[] {\n\t\treturn Array.from(this.state.players.keys());\n\t}\n\n\tpublic setCurrentPhase(phase: GamePhase) {\n\t\tthis.state.currentPhase = phase;\n\t\tthis.eventBus.publish('phaseChanged', { phase });\n\n\t\t// Process \"At [Phase]\" triggers\n\t\tthis.triggerHandler.processPhaseTriggersForPhase(phase);\n\t}\n\n\t/**\n\t * Sets the game winner and ends the game\n\t */\n\tpublic setGameWinner(playerId: string): void {\n\t\tthis.state.gameEnded = true;\n\t\tthis.state.winner = playerId;\n\t\tconsole.log('[GSM] Game ended, winner:', playerId);\n\t}\n\n\t/**\n\t * Enters tiebreaker mode according to Rule 4.3\n\t */\n\tpublic enterTiebreakerMode(): void {\n\t\tthis.state.tiebreakerMode = true;\n\n\t\t// Rule 4.3.e: Replace adventure with Arena containing all terrain types\n\t\tconst adventureZone = this.state.sharedZones.adventure;\n\t\tadventureZone.clear();\n\n\t\t// Arena has V, M, O terrain regions\n\t\tconst arenaRegions = [\n\t\t\t{\n\t\t\t\tid: 'arena-forest',\n\t\t\t\tinstanceId: 'arena-forest',\n\t\t\t\ttype: 'ArenaRegion',\n\t\t\t\tterrainType: 'forest',\n\t\t\t\townerId: 'shared'\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'arena-mountain',\n\t\t\t\tinstanceId: 'arena-mountain',\n\t\t\t\ttype: 'ArenaRegion',\n\t\t\t\tterrainType: 'mountain',\n\t\t\t\townerId: 'shared'\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'arena-water',\n\t\t\t\tinstanceId: 'arena-water',\n\t\t\t\ttype: 'ArenaRegion',\n\t\t\t\tterrainType: 'water',\n\t\t\t\townerId: 'shared'\n\t\t\t}\n\t\t];\n\n\t\tarenaRegions.forEach((region) => {\n\t\t\tadventureZone.add(region as any);\n\t\t});\n\n\t\tconsole.log('[GSM] Tiebreaker mode started');\n\t}\n\n\t/**\n\t * Moves a card between zones with validation\n\t */\n\tpublic moveCard(\n\t\tcardId: string,\n\t\tfromZone: ZoneIdentifier,\n\t\ttoZone: ZoneIdentifier,\n\t\tplayerId: string\n\t): void {\n\t\tconst player = this.getPlayer(playerId);\n\t\tif (!player) {\n\t\t\tthrow new Error(`Player ${playerId} not found`);\n\t\t}\n\n\t\tconst fromZoneObj = this.getZoneByIdentifier(fromZone, playerId);\n\t\tconst toZoneObj = this.getZoneByIdentifier(toZone, playerId);\n\n\t\tif (!fromZoneObj || !toZoneObj) {\n\t\t\tthrow new Error('Invalid zone identifier');\n\t\t}\n\n\t\tconst card = fromZoneObj.getAll().find((c) => c.id === cardId);\n\t\tif (!card) {\n\t\t\tthrow new Error(`Card ${cardId} not found in ${fromZone}`);\n\t\t}\n\n\t\tthis.moveEntity(cardId, fromZoneObj, toZoneObj, playerId);\n\t}\n\n\tprivate getZoneByIdentifier(zoneId: ZoneIdentifier, playerId: string): IZone | undefined {\n\t\tconst player = this.getPlayer(playerId);\n\t\tif (!player) return undefined;\n\n\t\tswitch (zoneId) {\n\t\t\tcase ZoneIdentifier.Hand:\n\t\t\t\treturn player.zones.handZone;\n\t\t\tcase ZoneIdentifier.Deck:\n\t\t\t\treturn player.zones.deckZone;\n\t\t\tcase ZoneIdentifier.Discard:\n\t\t\t\treturn player.zones.discardPileZone;\n\t\t\tcase ZoneIdentifier.Mana:\n\t\t\t\treturn player.zones.manaZone;\n\t\t\tcase ZoneIdentifier.Reserve:\n\t\t\t\treturn player.zones.reserveZone;\n\t\t\tcase ZoneIdentifier.Landmark:\n\t\t\t\treturn player.zones.landmarkZone;\n\t\t\tcase ZoneIdentifier.Hero:\n\t\t\t\treturn player.zones.heroZone;\n\t\t\tcase ZoneIdentifier.Expedition:\n\t\t\t\treturn player.zones.expeditionZone;\n\t\t\tcase ZoneIdentifier.Limbo:\n\t\t\t\treturn this.state.sharedZones.limbo;\n\t\t\tcase ZoneIdentifier.Adventure:\n\t\t\t\treturn this.state.sharedZones.adventure;\n\t\t\tdefault:\n\t\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Handles the Prepare daily effect during the Morning phase.\n\t * Rule 4.2.1.c: Readies all exhausted cards and objects.\n\t */\n\tpublic async preparePhase(): Promise<void> {\n\t\tconsole.log('[GSM] Beginning Prepare phase.');\n\t\t// Use status handler for comprehensive prepare phase processing\n\t\tthis.statusHandler.processStatusEffectsDuringPhase('morning');\n\t}\n\n\t/**\n\t * Handles the Rest daily effect during the Night phase.\n\t * Rule 4.2.5.b\n\t */\n\tpublic async restPhase() {\n\t\tconsole.log('[GSM] Beginning Rest phase.');\n\n\t\tfor (const player of this.state.players.values()) {\n\t\t\tconst expeditionZone = player.zones.expeditionZone;\n\t\t\tconst charactersToProcess = expeditionZone\n\t\t\t\t.getAll()\n\t\t\t\t.filter((e) => isGameObject(e) && e.type === CardType.Character) as IGameObject[];\n\n\t\t\t// Check if any expedition moved forward this turn\n\t\t\tconst anyExpeditionMoved =\n\t\t\t\tplayer.heroExpedition.hasMoved || player.companionExpedition.hasMoved;\n\n\t\t\tfor (const char of charactersToProcess) {\n\t\t\t\t// Use status handler to check all status interactions\n\t\t\t\tconst statusResults = this.statusHandler.checkStatusInteraction(char, 'rest');\n\n\t\t\t\t// Check if status effects prevent going to Reserve\n\t\t\t\tif (statusResults.anchored || statusResults.asleep) {\n\t\t\t\t\tcontinue; // Status prevents movement to Reserve\n\t\t\t\t}\n\n\t\t\t\t// Check for Eternal keyword (Rule 7.4.3)\n\t\t\t\tif (this.keywordHandler.isEternal(char)) {\n\t\t\t\t\tcontinue; // Eternal characters don't go to Reserve\n\t\t\t\t}\n\n\t\t\t\t// Only characters in expeditions that moved go to Reserve\n\t\t\t\tif (anyExpeditionMoved) {\n\t\t\t\t\tlet destinationZone;\n\n\t\t\t\t\tif (statusResults.fleetingDestination === 'discard') {\n\t\t\t\t\t\tdestinationZone = player.zones.discardPileZone;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestinationZone = player.zones.reserveZone;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.moveEntity(char.objectId, expeditionZone, destinationZone, char.controllerId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handles the Clean-up daily effect during the Night phase.\n\t * Rule 4.2.5.c: Players discard/sacrifice down to their limits.\n\t */\n\tpublic async cleanupPhase(): Promise<void> {\n\t\tconsole.log('[GSM] Beginning Clean-up phase.');\n\t\tfor (const player of this.state.players.values()) {\n\t\t\tconst hero = player.zones.heroZone.getAll()[0] as IGameObject | undefined;\n\t\t\tconst reserveLimit = hero?.baseCharacteristics.reserveLimit ?? 2;\n\t\t\tconst landmarkLimit = hero?.baseCharacteristics.landmarkLimit ?? 2;\n\n\t\t\t// Clean-up Reserve\n\t\t\tconst reserveZone = player.zones.reserveZone;\n\t\t\twhile (reserveZone.getCount() > reserveLimit) {\n\t\t\t\t// TODO: Add player choice. For now, discard the last card.\n\t\t\t\tconst cardToDiscard = reserveZone.getAll().pop() as IGameObject;\n\t\t\t\tif (cardToDiscard) {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`[GSM] ${player.id} is over reserve limit, discarding ${cardToDiscard.name}.`\n\t\t\t\t\t);\n\t\t\t\t\tthis.moveEntity(\n\t\t\t\t\t\tcardToDiscard.objectId,\n\t\t\t\t\t\treserveZone,\n\t\t\t\t\t\tplayer.zones.discardPileZone,\n\t\t\t\t\t\tplayer.id\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clean-up Landmarks (Sacrifice)\n\t\t\tconst landmarkZone = player.zones.landmarkZone;\n\t\t\twhile (landmarkZone.getCount() > landmarkLimit) {\n\t\t\t\t// TODO: Add player choice. For now, sacrifice the last card.\n\t\t\t\tconst cardToSacrifice = landmarkZone.getAll().pop() as IGameObject;\n\t\t\t\tif (cardToSacrifice) {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`[GSM] ${player.id} is over landmark limit, sacrificing ${cardToSacrifice.name}.`\n\t\t\t\t\t);\n\t\t\t\t\tthis.moveEntity(\n\t\t\t\t\t\tcardToSacrifice.objectId,\n\t\t\t\t\t\tlandmarkZone,\n\t\t\t\t\t\tplayer.zones.discardPileZone,\n\t\t\t\t\t\tplayer.id\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the terrain statistics for an expedition\n\t * Rule 4.2.4, 7.1.2\n\t */\n\tpublic calculateExpeditionStats(\n\t\tplayerId: string,\n\t\texpeditionType: 'hero' | 'companion'\n\t): ITerrainStats {\n\t\tconst player = this.getPlayer(playerId);\n\t\tif (!player) return { forest: 0, mountain: 0, water: 0 };\n\n\t\tconst expeditionZone = player.zones.expeditionZone;\n\t\tconst stats: ITerrainStats = { forest: 0, mountain: 0, water: 0 };\n\n\t\tfor (const entity of expeditionZone.getAll()) {\n\t\t\tif (isGameObject(entity) && entity.type === CardType.Character) {\n\t\t\t\t// Skip if Character has Asleep status during Progress (Rule 2.4.3)\n\t\t\t\tif (entity.statuses.has(StatusType.Asleep)) continue;\n\n\t\t\t\t// Get base statistics\n\t\t\t\tconst entityStats = entity.currentCharacteristics.statistics;\n\t\t\t\tif (entityStats) {\n\t\t\t\t\tstats.forest += entityStats.forest || 0;\n\t\t\t\t\tstats.mountain += entityStats.mountain || 0;\n\t\t\t\t\tstats.water += entityStats.water || 0;\n\t\t\t\t}\n\n\t\t\t\t// Add boost counters (Rule 2.5.1.b)\n\t\t\t\tconst boostCount = entity.counters.get(CounterType.Boost) || 0;\n\t\t\t\tstats.forest += boostCount;\n\t\t\t\tstats.mountain += boostCount;\n\t\t\t\tstats.water += boostCount;\n\t\t\t}\n\t\t}\n\n\t\treturn stats;\n\t}\n\n\t/**\n\t * Handles the Progress daily effect during Dusk phase\n\t * Rule 4.2.4.c-j\n\t */\n\tpublic async progressPhase(): Promise<void> {\n\t\tconsole.log('[GSM] Beginning Progress phase.');\n\n\t\tfor (const player of this.state.players.values()) {\n\t\t\t// Reset movement flags\n\t\t\tplayer.heroExpedition.hasMoved = false;\n\t\t\tplayer.companionExpedition.hasMoved = false;\n\t\t\tplayer.heroExpedition.canMove = true;\n\t\t\tplayer.companionExpedition.canMove = true;\n\n\t\t\t// Check for Defender keyword (Rule 7.4.2)\n\t\t\tconst movementRestrictions = this.keywordHandler.checkDefenderRestrictions(player.id);\n\t\t\tplayer.heroExpedition.canMove = movementRestrictions.hero;\n\t\t\tplayer.companionExpedition.canMove = movementRestrictions.companion;\n\n\t\t\tif (!player.heroExpedition.canMove || !player.companionExpedition.canMove) {\n\t\t\t\tconsole.log(`[GSM] Player ${player.id} expeditions cannot move due to Defender.`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Calculate expedition statistics\n\t\t\tconst heroStats = this.calculateExpeditionStats(player.id, 'hero');\n\t\t\tconst companionStats = this.calculateExpeditionStats(player.id, 'companion');\n\n\t\t\t// Find opponent (for 2-player game)\n\t\t\tconst opponents = Array.from(this.state.players.values()).filter((p) => p.id !== player.id);\n\n\t\t\tfor (const opponent of opponents) {\n\t\t\t\tconst oppHeroStats = this.calculateExpeditionStats(opponent.id, 'hero');\n\t\t\t\tconst oppCompanionStats = this.calculateExpeditionStats(opponent.id, 'companion');\n\n\t\t\t\t// Hero expedition vs opponent hero expedition\n\t\t\t\tif (this.expeditionShouldMove(heroStats, oppHeroStats) && player.heroExpedition.canMove) {\n\t\t\t\t\tplayer.heroExpedition.position++;\n\t\t\t\t\tplayer.heroExpedition.hasMoved = true;\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`[GSM] Player ${player.id} hero expedition moved to position ${player.heroExpedition.position}`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Companion expedition vs opponent companion expedition\n\t\t\t\tif (\n\t\t\t\t\tthis.expeditionShouldMove(companionStats, oppCompanionStats) &&\n\t\t\t\t\tplayer.companionExpedition.canMove\n\t\t\t\t) {\n\t\t\t\t\tplayer.companionExpedition.position++;\n\t\t\t\t\tplayer.companionExpedition.hasMoved = true;\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t`[GSM] Player ${player.id} companion expedition moved to position ${player.companionExpedition.position}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Determines if an expedition should move forward based on statistics comparison\n\t * Rule 4.2.4.e: \"An expedition moves forward if it has a greater positive total for at least one terrain\"\n\t */\n\tprivate expeditionShouldMove(myStats: ITerrainStats, opponentStats: ITerrainStats): boolean {\n\t\tconst myForest = Math.max(0, myStats.forest);\n\t\tconst myMountain = Math.max(0, myStats.mountain);\n\t\tconst myWater = Math.max(0, myStats.water);\n\n\t\tconst oppForest = Math.max(0, opponentStats.forest);\n\t\tconst oppMountain = Math.max(0, opponentStats.mountain);\n\t\tconst oppWater = Math.max(0, opponentStats.water);\n\n\t\treturn myForest > oppForest || myMountain > oppMountain || myWater > oppWater;\n\t}\n\n\tpublic async drawCards(playerId: string, count: number): Promise<void> {\n\t\tconst player = this.getPlayer(playerId);\n\t\tif (!player) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst deck = player.zones.deckZone as DeckZone;\n\t\tconst hand = player.zones.handZone;\n\t\tconst discardPile = player.zones.discardPileZone;\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tif (deck.getCount() === 0) {\n\t\t\t\tif (discardPile.getCount() > 0) {\n\t\t\t\t\tconst discardedEntities = discardPile.getAll();\n\t\t\t\t\tdiscardedEntities.forEach((e) => {\n\t\t\t\t\t\tconst entityId = isGameObject(e) ? e.objectId : e.instanceId;\n\t\t\t\t\t\tdiscardPile.remove(entityId);\n\t\t\t\t\t});\n\n\t\t\t\t\tconst cardsToReshuffle: ICardInstance[] = discardedEntities.map((e) => {\n\t\t\t\t\t\treturn isGameObject(e)\n\t\t\t\t\t\t\t? this.objectFactory.createCardInstance(e.definitionId, e.ownerId)\n\t\t\t\t\t\t\t: (e as ICardInstance);\n\t\t\t\t\t});\n\n\t\t\t\t\tdeck.addBottom(cardsToReshuffle);\n\t\t\t\t\tdeck.shuffle();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (deck.getCount() === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst cardToDraw = deck.removeTop();\n\t\t\tif (cardToDraw) {\n\t\t\t\t// Convert to game object when moving to visible zone (hand)\n\t\t\t\tconst gameObject = this.objectFactory.createGameObject(cardToDraw, playerId);\n\t\t\t\tgameObject.faceDown = false; // Cards in hand are face-up for owner\n\t\t\t\thand.add(gameObject);\n\t\t\t\tthis.eventBus.publish('entityMoved', { entity: gameObject, from: deck, to: hand });\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get all visible zones across all players and shared zones\n\t */\n\tpublic getAllVisibleZones(): IZone[] {\n\t\tconst zones: IZone[] = [];\n\n\t\t// Add shared zones\n\t\tObject.values(this.state.sharedZones).forEach((zone) => {\n\t\t\tif (zone && zone.visibility === 'visible' && zone.getAll) {\n\t\t\t\tzones.push(zone);\n\t\t\t}\n\t\t});\n\n\t\t// Add player zones\n\t\tfor (const player of this.state.players.values()) {\n\t\t\tObject.values(player.zones).forEach((zone) => {\n\t\t\t\tif (zone && zone.visibility === 'visible' && zone.getAll) {\n\t\t\t\t\tzones.push(zone);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn zones;\n\t}\n\n\t/**\n\t * Checks victory conditions after Night phase\n\t * Rule 4.2.5.d, 4.3 - Victory and tiebreaker conditions\n\t */\n\tpublic checkVictoryConditions(): string | null {\n\t\tconsole.log('[GSM] Checking victory conditions.');\n\n\t\t// Check if we're in tiebreaker mode\n\t\tif (this.tiebreakerSystem.isInTiebreakerMode()) {\n\t\t\treturn this.tiebreakerSystem.processTiebreakerProgress();\n\t\t}\n\n\t\t// Normal victory condition check with tiebreaker support\n\t\treturn this.tiebreakerSystem.checkForTiebreaker();\n\t}\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/KeywordAbilityHandler.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'CounterType' is defined but never used.",
				"line": 4,
				"column": 38,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 4,
				"endColumn": 49
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'zone' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 18,
				"column": 56,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 18,
				"endColumn": 60
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'cost' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 56,
				"column": 69,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 56,
				"endColumn": 73
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 56,
				"column": 75,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 56,
				"endColumn": 78,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [1719, 1722], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [1719, 1722], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'toughValue' is assigned a value but never used.",
				"line": 65,
				"column": 9,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 65,
				"endColumn": 19
			}
		],
		"suppressedMessages": [],
		"errorCount": 4,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { IGameObject } from './types/objects';\nimport type { GameStateManager } from './GameStateManager';\nimport type { IZone } from './types/zones';\nimport { KeywordAbility, StatusType, CounterType, CardType } from './types/enums';\nimport { isGameObject } from './types/objects';\n\n/**\n * Handles all keyword ability mechanics\n * Rules 7.4.1 through 7.4.7\n */\nexport class KeywordAbilityHandler {\n\tconstructor(private gsm: GameStateManager) {}\n\n\t/**\n\t * Processes keyword abilities when an object enters play\n\t * Rule 7.4 - Keywords are passive abilities\n\t */\n\tpublic processKeywordOnEnterPlay(object: IGameObject, zone: IZone): void {\n\t\tfor (const ability of object.abilities) {\n\t\t\tif (!ability.isKeyword || !ability.keyword) continue;\n\n\t\t\tswitch (ability.keyword) {\n\t\t\t\tcase KeywordAbility.Gigantic:\n\t\t\t\t\tthis.handleGiganticEnterPlay(object);\n\t\t\t\t\tbreak;\n\t\t\t\t// Other keywords don't have enter play effects\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Processes keyword abilities when an object leaves play\n\t */\n\tpublic processKeywordOnLeavePlay(object: IGameObject, fromZone: IZone, toZone: IZone): void {\n\t\tfor (const ability of object.abilities) {\n\t\t\tif (!ability.isKeyword || !ability.keyword) continue;\n\n\t\t\tswitch (ability.keyword) {\n\t\t\t\tcase KeywordAbility.Cooldown:\n\t\t\t\t\tthis.handleCooldownLeavePlay(object, fromZone, toZone);\n\t\t\t\t\tbreak;\n\t\t\t\tcase KeywordAbility.Seasoned:\n\t\t\t\t\tthis.handleSeasonedLeavePlay(object, fromZone, toZone);\n\t\t\t\t\tbreak;\n\t\t\t\tcase KeywordAbility.Gigantic:\n\t\t\t\t\tthis.handleGiganticLeavePlay(object);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if an object can be targeted by an opponent's effect\n\t * Rule 7.4.7 - Tough keyword\n\t */\n\tpublic canTargetWithTough(object: IGameObject, controller: string, cost: any): boolean {\n\t\tconst toughAbility = object.abilities.find(\n\t\t\t(a) => a.isKeyword && a.keyword === KeywordAbility.Tough\n\t\t);\n\n\t\tif (!toughAbility || object.controllerId === controller) {\n\t\t\treturn true; // No Tough or same controller\n\t\t}\n\n\t\tconst toughValue = toughAbility.keywordValue || 0;\n\t\t// TODO: Check if opponent can pay the additional cost\n\t\t// For now, return true (assuming they can pay)\n\t\treturn true;\n\t}\n\n\t/**\n\t * Handles Cooldown keyword (Rule 7.4.1)\n\t * When a Spell with Cooldown goes to Reserve after resolution, it becomes exhausted\n\t */\n\tprivate handleCooldownLeavePlay(object: IGameObject, fromZone: IZone, toZone: IZone): void {\n\t\tif (object.type === 'Sort' && toZone.zoneType === 'Reserve') {\n\t\t\t// Spell going to Reserve\n\t\t\tobject.statuses.add(StatusType.Exhausted);\n\t\t\tconsole.log(`[KeywordHandler] ${object.name} gained Exhausted from Cooldown`);\n\t\t}\n\t}\n\n\t/**\n\t * Handles Seasoned keyword (Rule 7.4.6)\n\t * If a Seasoned object moves from Expedition to Reserve, it keeps its boosts\n\t */\n\tprivate handleSeasonedLeavePlay(object: IGameObject, fromZone: IZone, toZone: IZone): void {\n\t\tif (fromZone.zoneType === 'Expedition' && toZone.zoneType === 'Reserve') {\n\t\t\t// The moveEntity method in GameStateManager already handles this\n\t\t\t// by checking for Seasoned and preserving boost counters\n\t\t\tconsole.log(`[KeywordHandler] ${object.name} keeps boosts due to Seasoned`);\n\t\t}\n\t}\n\n\t/**\n\t * Handles Gigantic keyword enter play (Rule 7.4.4)\n\t * A Gigantic object is present in both expeditions of its controller\n\t */\n\tprivate handleGiganticEnterPlay(object: IGameObject): void {\n\t\t// TODO: Implement Gigantic logic\n\t\t// This is complex as it affects how the object appears in both expeditions\n\t\tconsole.log(`[KeywordHandler] ${object.name} is Gigantic - present in both expeditions`);\n\t}\n\n\t/**\n\t * Handles Gigantic keyword leave play\n\t */\n\tprivate handleGiganticLeavePlay(object: IGameObject): void {\n\t\t// TODO: Implement Gigantic leave logic\n\t\tconsole.log(`[KeywordHandler] Gigantic ${object.name} leaves both expeditions`);\n\t}\n\n\t/**\n\t * Checks if expeditions can move (Defender keyword check)\n\t * Rule 7.4.2 - An expedition containing a Character with Defender cannot move forward\n\t */\n\tpublic checkDefenderRestrictions(playerId: string): { hero: boolean; companion: boolean } {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) return { hero: true, companion: true };\n\n\t\tconst expeditionChars = player.zones.expeditionZone\n\t\t\t.getAll()\n\t\t\t.filter((e) => isGameObject(e) && e.type === CardType.Character) as IGameObject[];\n\n\t\tlet defenderPresent = false;\n\t\tfor (const char of expeditionChars) {\n\t\t\tif (char.currentCharacteristics.hasDefender === true) {\n\t\t\t\tdefenderPresent = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Fallback: check base abilities if characteristic not set\n\t\t\t// (e.g., if RuleAdjudicator hasn't run or missed it for some reason,\n\t\t\t// or for systems that might query this before full adjudication)\n\t\t\tif (char.abilities.some((ability) => ability.keyword === KeywordAbility.Defender)) {\n\t\t\t\tdefenderPresent = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\thero: !defenderPresent, // If defender is present, hero movement is restricted (false)\n\t\t\tcompanion: !defenderPresent // Same for companion\n\t\t};\n\t}\n\n\t/**\n\t * Processes Scout keyword when playing from hand\n\t * Rule 7.4.5 - Can pay X as alternative cost and gains \"Send me to Reserve\" ability\n\t */\n\tpublic processScoutPlay(object: IGameObject, paidScoutCost: boolean): void {\n\t\tif (!paidScoutCost) return;\n\n\t\tconst scoutAbility = object.abilities.find(\n\t\t\t(a) => a.isKeyword && a.keyword === KeywordAbility.Scout\n\t\t);\n\n\t\tif (scoutAbility) {\n\t\t\t// TODO: Add the \"Send me to Reserve\" quick action ability\n\t\t\tconsole.log(`[KeywordHandler] ${object.name} gains Scout quick action`);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if a character should not go to Reserve during Rest\n\t * Rule 7.4.3 - Eternal characters are not sent to Reserve during Rest\n\t */\n\tpublic isEternal(object: IGameObject): boolean {\n\t\t// First, check the characteristics applied by RuleAdjudicator\n\t\tif (object.currentCharacteristics.isEternal === true) {\n\t\t\treturn true;\n\t\t}\n\t\t// Fallback: check the base abilities array if the characteristic isn't set\n\t\t// (e.g., if RuleAdjudicator hasn't run or missed it for some reason,\n\t\t// or for systems that might query this before full adjudication)\n\t\treturn object.abilities.some(\n\t\t\t(ability) => ability.keyword === KeywordAbility.Eternal // Removed isKeyword check for broader compatibility\n\t\t);\n\t}\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/ManaSystem.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'TerrainType' is defined but never used.",
				"line": 4,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 4,
				"endColumn": 21
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'movedCard' is assigned a value but never used.",
				"line": 262,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 262,
				"endColumn": 19
			}
		],
		"suppressedMessages": [],
		"errorCount": 2,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { GameStateManager } from './GameStateManager';\nimport type { IGameObject } from './types/objects';\nimport type { ITerrainStats } from './types/game';\nimport { TerrainType, StatusType, CardType, CounterType } from './types/enums';\nimport { isGameObject } from './types/objects';\n\n/**\n * Handles terrain-based mana providing system\n * Rule 2.2.10 - Character statistics provide terrain-based mana\n */\nexport class ManaSystem {\n\tconstructor(private gsm: GameStateManager) {}\n\n\t/**\n\t * Gets available mana for a player including terrain bonuses\n\t * Rule 2.2.10 - Characters provide terrain-based mana through their statistics\n\t */\n\tpublic getAvailableMana(playerId: string): ManaPool {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) {\n\t\t\treturn { total: 0, forest: 0, mountain: 0, water: 0, orbs: 0 };\n\t\t}\n\n\t\t// Base mana from Mana Orbs\n\t\tconst baseMana = this.getManaFromOrbs(playerId);\n\n\t\t// Terrain mana from Characters in expedition and hero zones\n\t\tconst terrainMana = this.getTerrainManaFromCharacters(playerId);\n\n\t\treturn {\n\t\t\ttotal: baseMana + terrainMana.forest + terrainMana.mountain + terrainMana.water,\n\t\t\tforest: terrainMana.forest,\n\t\t\tmountain: terrainMana.mountain,\n\t\t\twater: terrainMana.water,\n\t\t\torbs: baseMana\n\t\t};\n\t}\n\n\t/**\n\t * Gets base mana from ready Mana Orbs\n\t * Rule 3.2.9.e - Mana orbs can be exhausted to provide mana\n\t */\n\tpublic getManaFromOrbs(playerId: string): number {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) return 0;\n\n\t\tlet availableOrbs = 0;\n\n\t\tfor (const entity of player.zones.manaZone.getAll()) {\n\t\t\tif (isGameObject(entity) && !entity.statuses.has(StatusType.Exhausted)) {\n\t\t\t\tavailableOrbs++;\n\t\t\t}\n\t\t}\n\n\t\treturn availableOrbs;\n\t}\n\n\t/**\n\t * Gets terrain-based mana from Characters\n\t * Rule 2.2.10 - Character statistics provide terrain mana\n\t */\n\tpublic getTerrainManaFromCharacters(playerId: string): ITerrainStats {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) {\n\t\t\treturn { forest: 0, mountain: 0, water: 0 };\n\t\t}\n\n\t\tconst terrainMana: ITerrainStats = { forest: 0, mountain: 0, water: 0 };\n\n\t\t// Check hero zone - Heroes and Characters provide terrain mana\n\t\tfor (const entity of player.zones.heroZone.getAll()) {\n\t\t\tif (\n\t\t\t\tisGameObject(entity) &&\n\t\t\t\t(entity.type === CardType.Hero || entity.type === CardType.Character)\n\t\t\t) {\n\t\t\t\tconst heroStats = this.getCharacterTerrainStats(entity);\n\t\t\t\tthis.addTerrainStats(terrainMana, heroStats);\n\t\t\t}\n\t\t}\n\n\t\t// Check expedition zone - Characters provide terrain mana\n\t\tfor (const entity of player.zones.expeditionZone.getAll()) {\n\t\t\tif (isGameObject(entity) && entity.type === CardType.Character) {\n\t\t\t\tconst charStats = this.getCharacterTerrainStats(entity);\n\t\t\t\tthis.addTerrainStats(terrainMana, charStats);\n\t\t\t}\n\t\t}\n\n\t\t// Check landmark zone for Permanents that might provide mana\n\t\tfor (const entity of player.zones.landmarkZone.getAll()) {\n\t\t\tif (isGameObject(entity) && entity.type === CardType.Permanent) {\n\t\t\t\tconst permStats = this.getCharacterTerrainStats(entity);\n\t\t\t\tthis.addTerrainStats(terrainMana, permStats);\n\t\t\t}\n\t\t}\n\n\t\treturn terrainMana;\n\t}\n\n\t/**\n\t * Gets terrain statistics from a character/object\n\t */\n\tprivate getCharacterTerrainStats(object: IGameObject): ITerrainStats {\n\t\t// Get base statistics from the definition via object factory\n\t\tconst definition = this.gsm.getCardDefinition(object.definitionId);\n\t\tconst baseStats = definition?.statistics || { forest: 0, mountain: 0, water: 0 };\n\t\tconst stats: ITerrainStats = { ...baseStats };\n\n\t\t// Add boost counters to all terrain types (Rule 2.5.1.b)\n\t\tconst boostCount = object.counters.get(CounterType.Boost) || 0;\n\t\tstats.forest += boostCount;\n\t\tstats.mountain += boostCount;\n\t\tstats.water += boostCount;\n\n\t\treturn stats;\n\t}\n\n\t/**\n\t * Adds terrain stats together\n\t */\n\tprivate addTerrainStats(target: ITerrainStats, source: ITerrainStats): void {\n\t\ttarget.forest += source.forest;\n\t\ttarget.mountain += source.mountain;\n\t\ttarget.water += source.water;\n\t}\n\n\t/**\n\t * Checks if player can pay a cost with specific terrain requirements\n\t * Extended mana system with terrain-specific costs\n\t */\n\tpublic canPayTerrainCost(playerId: string, cost: TerrainCost): boolean {\n\t\tconst availableMana = this.getAvailableMana(playerId);\n\n\t\t// Check if we have enough total mana\n\t\tconst totalRequired = cost.generic + cost.forest + cost.mountain + cost.water;\n\t\tif (availableMana.total < totalRequired) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check terrain-specific requirements\n\t\tif (cost.forest > availableMana.forest) return false;\n\t\tif (cost.mountain > availableMana.mountain) return false;\n\t\tif (cost.water > availableMana.water) return false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Pays a terrain-specific cost\n\t */\n\tpublic async payTerrainCost(playerId: string, cost: TerrainCost): Promise<void> {\n\t\tif (!this.canPayTerrainCost(playerId, cost)) {\n\t\t\tthrow new Error(`Cannot pay terrain cost: ${JSON.stringify(cost)}`);\n\t\t}\n\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) throw new Error(`Player ${playerId} not found`);\n\n\t\t// For now, exhaust mana orbs equal to total cost\n\t\t// TODO: Implement more sophisticated terrain-specific payment\n\t\tconst totalCost = cost.generic + cost.forest + cost.mountain + cost.water;\n\t\tlet remainingCost = totalCost;\n\n\t\tfor (const entity of player.zones.manaZone.getAll()) {\n\t\t\tif (remainingCost <= 0) break;\n\n\t\t\tif (isGameObject(entity) && !entity.statuses.has(StatusType.Exhausted)) {\n\t\t\t\tthis.gsm.statusHandler.applyStatusEffect(entity, StatusType.Exhausted);\n\t\t\t\tremainingCost--;\n\t\t\t\tconsole.log(`[ManaSystem] Exhausted mana orb for terrain cost`);\n\t\t\t}\n\t\t}\n\n\t\tif (remainingCost > 0) {\n\t\t\tthrow new Error(`Could not pay full terrain cost`);\n\t\t}\n\t}\n\n\t/**\n\t * Gets terrain mana breakdown for display\n\t */\n\tpublic getManaBreakdown(playerId: string): ManaBreakdown {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) {\n\t\t\treturn {\n\t\t\t\torbs: { ready: 0, exhausted: 0 },\n\t\t\t\tcharacters: { forest: 0, mountain: 0, water: 0 },\n\t\t\t\ttotal: { forest: 0, mountain: 0, water: 0, generic: 0 }\n\t\t\t};\n\t\t}\n\n\t\t// Count mana orbs\n\t\tlet readyOrbs = 0;\n\t\tlet exhaustedOrbs = 0;\n\t\tfor (const entity of player.zones.manaZone.getAll()) {\n\t\t\tif (isGameObject(entity)) {\n\t\t\t\tif (entity.statuses.has(StatusType.Exhausted)) {\n\t\t\t\t\texhaustedOrbs++;\n\t\t\t\t} else {\n\t\t\t\t\treadyOrbs++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Get character terrain stats\n\t\tconst characterMana = this.getTerrainManaFromCharacters(playerId);\n\n\t\treturn {\n\t\t\torbs: { ready: readyOrbs, exhausted: exhaustedOrbs },\n\t\t\tcharacters: characterMana,\n\t\t\ttotal: {\n\t\t\t\tforest: characterMana.forest,\n\t\t\t\tmountain: characterMana.mountain,\n\t\t\t\twater: characterMana.water,\n\t\t\t\tgeneric: readyOrbs\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Converts terrain cost to generic mana cost for simple payment\n\t */\n\tpublic terrainCostToGeneric(cost: TerrainCost): number {\n\t\treturn cost.generic + cost.forest + cost.mountain + cost.water;\n\t}\n\n\t/**\n\t * Creates a terrain cost from a simple mana cost\n\t */\n\tpublic createGenericTerrainCost(amount: number): TerrainCost {\n\t\treturn {\n\t\t\tgeneric: amount,\n\t\t\tforest: 0,\n\t\t\tmountain: 0,\n\t\t\twater: 0\n\t\t};\n\t}\n\n\t/**\n\t * Rule 3.2.9.b: Add a card to mana zone face-down and exhausted\n\t */\n\tpublic addCardToMana(playerId: string, cardId: string): boolean {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) return false;\n\n\t\t// Find the card in player's hand - try multiple ID fields\n\t\tconst handCard = player.zones.handZone.getAll().find((c) => {\n\t\t\tif (isGameObject(c)) {\n\t\t\t\treturn c.objectId === cardId || c.id === cardId || c.definitionId === cardId;\n\t\t\t} else {\n\t\t\t\treturn c.instanceId === cardId || c.id === cardId || c.definitionId === cardId;\n\t\t\t}\n\t\t});\n\n\t\tif (!handCard) return false;\n\n\t\t// Use the correct entity ID for movement\n\t\tconst entityId = isGameObject(handCard) ? handCard.objectId : handCard.instanceId;\n\n\t\t// Move card to mana zone via GameStateManager\n\t\ttry {\n\t\t\tconst movedCard = this.gsm.moveEntity(\n\t\t\t\tentityId,\n\t\t\t\tplayer.zones.handZone,\n\t\t\t\tplayer.zones.manaZone,\n\t\t\t\tplayerId\n\t\t\t);\n\n\t\t\t// Apply Rule 3.2.9.b and 3.2.9.c to the moved card\n\t\t\t// Always search for the card in mana zone since moveEntity creates a new object\n\t\t\tconst cardInMana = player.zones.manaZone.getAll().find((c) => {\n\t\t\t\tif (isGameObject(c)) {\n\t\t\t\t\treturn c.definitionId === handCard.definitionId;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\n\t\t\tif (isGameObject(cardInMana)) {\n\t\t\t\tcardInMana.faceDown = true; // Rule 3.2.9.b\n\t\t\t\tcardInMana.statuses.add(StatusType.Exhausted); // Rule 3.2.9.b\n\t\t\t\tcardInMana.type = CardType.ManaOrb; // Rule 3.2.9.c\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to add card to mana:', error);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Rule 3.2.9.e: Convert mana by exhausting one orb to ready another\n\t */\n\tpublic convertMana(playerId: string, sourceOrbId: string, targetOrbId: string): boolean {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) return false;\n\n\t\tconst manaZone = player.zones.manaZone;\n\t\tconst sourceOrb = manaZone\n\t\t\t.getAll()\n\t\t\t.find((c) => (isGameObject(c) ? c.objectId : c.instanceId) === sourceOrbId);\n\t\tconst targetOrb = manaZone\n\t\t\t.getAll()\n\t\t\t.find((c) => (isGameObject(c) ? c.objectId : c.instanceId) === targetOrbId);\n\n\t\tif (!isGameObject(sourceOrb) || !isGameObject(targetOrb)) return false;\n\t\tif (sourceOrb.statuses.has(StatusType.Exhausted)) return false; // Source must be ready\n\n\t\t// Exhaust source, ready target\n\t\tsourceOrb.statuses.add(StatusType.Exhausted);\n\t\ttargetOrb.statuses.delete(StatusType.Exhausted);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Rule 3.2.9.f: Pay X mana by exhausting X Mana Orbs\n\t */\n\tpublic payMana(playerId: string, amount: number): { success: boolean; error?: string } {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) return { success: false, error: 'Player not found' };\n\n\t\tconst availableMana = this.getManaFromOrbs(playerId);\n\t\tif (availableMana < amount) {\n\t\t\treturn { success: false, error: 'Insufficient mana' };\n\t\t}\n\n\t\t// Exhaust the required number of ready orbs\n\t\tlet remaining = amount;\n\t\tconst manaOrbs = player.zones.manaZone.getAll();\n\n\t\tfor (const orb of manaOrbs) {\n\t\t\tif (remaining <= 0) break;\n\t\t\tif (isGameObject(orb) && !orb.statuses.has(StatusType.Exhausted)) {\n\t\t\t\torb.statuses.add(StatusType.Exhausted);\n\t\t\t\tremaining--;\n\t\t\t}\n\t\t}\n\n\t\treturn { success: true };\n\t}\n\n\t/**\n\t * Check if player can pay a specific cost\n\t */\n\tpublic canPayCost(\n\t\tplayerId: string,\n\t\tcost: { total: number; forest: number; mountain: number; water: number }\n\t): boolean {\n\t\tconst availableMana = this.getAvailableMana(playerId);\n\n\t\treturn (\n\t\t\tavailableMana.total >= cost.total &&\n\t\t\tavailableMana.forest >= cost.forest &&\n\t\t\tavailableMana.mountain >= cost.mountain &&\n\t\t\tavailableMana.water >= cost.water\n\t\t);\n\t}\n\n\t/**\n\t * Pay a complex cost with terrain requirements\n\t */\n\tpublic payComplexCost(\n\t\tplayerId: string,\n\t\tcost: { total: number; forest: number; mountain: number; water: number }\n\t): {\n\t\tsuccess: boolean;\n\t\tpayment?: { forestUsed: number; mountainUsed: number; waterUsed: number; orbsUsed: number };\n\t\terror?: string;\n\t} {\n\t\tif (!this.canPayCost(playerId, cost)) {\n\t\t\treturn { success: false, error: 'Insufficient mana' };\n\t\t}\n\n\t\t// For simplicity, use orbs for generic cost\n\t\tconst genericCost = cost.total - cost.forest - cost.mountain - cost.water;\n\t\tconst payResult = this.payMana(playerId, genericCost);\n\n\t\tif (!payResult.success) {\n\t\t\treturn { success: false, error: payResult.error };\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tpayment: {\n\t\t\t\tforestUsed: cost.forest,\n\t\t\t\tmountainUsed: cost.mountain,\n\t\t\t\twaterUsed: cost.water,\n\t\t\t\torbsUsed: genericCost\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Pay generic cost using available mana\n\t */\n\tpublic payGenericCost(\n\t\tplayerId: string,\n\t\tcost: { total: number; forest: number; mountain: number; water: number }\n\t): { success: boolean; error?: string } {\n\t\treturn this.payMana(playerId, cost.total);\n\t}\n\n\t/**\n\t * Rule 4.2.1.e: Expand - add card from hand to mana\n\t */\n\tpublic expandMana(playerId: string, cardId: string): { success: boolean; error?: string } {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) return { success: false, error: 'Player not found' };\n\n\t\tif (player.hasExpandedThisTurn) {\n\t\t\treturn { success: false, error: 'Already expanded this turn' };\n\t\t}\n\n\t\t// Find the card in hand using the correct ID field\n\t\tconst handCard = player.zones.handZone.getAll().find((c) => {\n\t\t\tif (isGameObject(c)) {\n\t\t\t\treturn c.objectId === cardId || c.id === cardId;\n\t\t\t} else {\n\t\t\t\treturn c.instanceId === cardId || c.id === cardId;\n\t\t\t}\n\t\t});\n\n\t\tif (!handCard) {\n\t\t\treturn { success: false, error: 'Card not found in hand' };\n\t\t}\n\n\t\t// Use the correct ID for the move operation\n\t\tconst entityId = isGameObject(handCard) ? handCard.objectId : handCard.instanceId;\n\t\tconst result = this.addCardToMana(playerId, entityId);\n\t\tif (result) {\n\t\t\tplayer.hasExpandedThisTurn = true;\n\t\t\treturn { success: true };\n\t\t}\n\n\t\treturn { success: false, error: 'Failed to expand' };\n\t}\n}\n\nexport interface ManaPool {\n\ttotal: number;\n\tforest: number;\n\tmountain: number;\n\twater: number;\n\torbs: number;\n}\n\nexport interface TerrainCost {\n\tgeneric: number; // Can be paid with any mana\n\tforest: number; // Must be paid with Forest mana\n\tmountain: number; // Must be paid with Mountain mana\n\twater: number; // Must be paid with Water mana\n}\n\nexport interface ManaBreakdown {\n\torbs: {\n\t\tready: number;\n\t\texhausted: number;\n\t};\n\tcharacters: ITerrainStats;\n\ttotal: {\n\t\tforest: number;\n\t\tmountain: number;\n\t\twater: number;\n\t\tgeneric: number;\n\t};\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/ObjectFactory.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 103,
				"column": 19,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 103,
				"endColumn": 22,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [3277, 3280], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [3277, 3280], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { ICardDefinition, ICardInstance } from './types/cards';\nimport type { IGameObject, IEmblemObject } from './types/objects';\nimport { CardType, CounterType, StatusType } from './types/enums';\nimport type { IAbility, IEffect } from './types/abilities';\nimport { isGameObject } from './types/objects';\n\n/**\n * Responsible for creating new instances of game objects.\n * This is central to enforcing the \"New Zone, New Object\" Golden Rule.\n * Rule 1.4.4, 2.1.d\n */\nexport class ObjectFactory {\n\tprivate static nextId = 0;\n\tprivate static nextTimestamp = 0;\n\n\tprivate cardDefinitions: Map<string, ICardDefinition>;\n\n\tconstructor(definitions: Map<string, ICardDefinition>) {\n\t\tthis.cardDefinitions = definitions;\n\t}\n\n\tpublic static createUniqueId(): string {\n\t\treturn `instance-${this.nextId++}`;\n\t}\n\n\tpublic static getNewTimestamp(): number {\n\t\treturn this.nextTimestamp++;\n\t}\n\n\tpublic createCardInstance(definitionId: string, ownerId: string): ICardInstance {\n\t\tif (!this.cardDefinitions.has(definitionId)) {\n\t\t\tthrow new Error(`Card definition not found: ${definitionId}`);\n\t\t}\n\t\treturn {\n\t\t\tinstanceId: ObjectFactory.createUniqueId(),\n\t\t\tdefinitionId,\n\t\t\townerId\n\t\t};\n\t}\n\n\t/**\n\t * Creates a game object directly from a card definition\n\t * Convenience method for testing and game initialization\n\t */\n\tpublic createCard(definitionId: string, ownerId: string): IGameObject {\n\t\tconst cardInstance = this.createCardInstance(definitionId, ownerId);\n\t\treturn this.createGameObject(cardInstance, ownerId);\n\t}\n\n\tpublic createGameObject(\n\t\tsource: ICardInstance | IGameObject,\n\t\tcontrollerId: string,\n\t\tinitialCounters?: Map<CounterType, number> // Allow specifying initial counters\n\t): IGameObject {\n\t\tconst definition = this.cardDefinitions.get(source.definitionId);\n\t\tif (!definition) {\n\t\t\tthrow new Error(`Card definition not found: ${source.definitionId}`);\n\t\t}\n\n\t\tconst baseCharacteristics = { ...definition };\n\n\t\tconst instantiatedAbilities = definition.abilities.map((ability) => ({ ...ability }));\n\n\t\tconst newObject: IGameObject = {\n\t\t\tid: (source as ICardInstance).instanceId || ObjectFactory.createUniqueId(), // Ensure 'id' is populated\n\t\t\tobjectId: ObjectFactory.createUniqueId(),\n\t\t\tdefinitionId: source.definitionId,\n\t\t\tname: definition.name,\n\t\t\ttype: definition.type,\n\t\t\tsubTypes: definition.subTypes,\n\t\t\tbaseCharacteristics,\n\t\t\tcurrentCharacteristics: { ...baseCharacteristics },\n\t\t\townerId: source.ownerId,\n\t\t\tcontrollerId: controllerId,\n\t\t\ttimestamp: ObjectFactory.getNewTimestamp(),\n\t\t\tstatuses: new Set<StatusType>(),\n\t\t\tcounters: new Map<CounterType, number>(), // Default to empty map\n\t\t\tabilities: []\n\t\t};\n\n\t\t// Apply initial counters if provided by the GameStateManager.\n\t\tif (initialCounters) {\n\t\t\tnewObject.counters = new Map(initialCounters);\n\t\t}\n\n\t\t// Correctly copy statuses from the source if it was an object (e.g., in Limbo/Reserve).\n\t\tif (isGameObject(source)) {\n\t\t\tnewObject.statuses = new Set(source.statuses);\n\t\t}\n\n\t\tnewObject.abilities = instantiatedAbilities.map((ability) => ({\n\t\t\t...ability,\n\t\t\tsourceObjectId: newObject.objectId,\n\t\t\teffect: { ...ability.effect, sourceObjectId: newObject.objectId }\n\t\t}));\n\n\t\treturn newObject;\n\t}\n\n\tpublic createReactionEmblem(\n\t\tsourceAbility: IAbility,\n\t\tsourceObject: IGameObject,\n\t\ttriggerPayload: any\n\t): IEmblemObject {\n\t\tif (!sourceAbility.sourceObjectId) {\n\t\t\tthrow new Error('Cannot create emblem from an ability not bound to an object.');\n\t\t}\n\n\t\t// Bind the trigger payload and original source to the effect for later resolution\n\t\tconst boundEffect: IEffect = {\n\t\t\t...sourceAbility.effect,\n\t\t\tsourceObjectId: sourceObject.objectId,\n\t\t\t_triggerPayload: triggerPayload\n\t\t};\n\n\t\tconst emblem: IEmblemObject = {\n\t\t\tobjectId: ObjectFactory.createUniqueId(),\n\t\t\tdefinitionId: `emblem-reaction-${sourceAbility.abilityId}`,\n\t\t\tname: `Reaction: ${sourceAbility.text}`,\n\t\t\ttype: CardType.Emblem,\n\t\t\temblemSubType: 'Reaction', // Rule 2.2.2.m\n\t\t\tbaseCharacteristics: {},\n\t\t\tcurrentCharacteristics: {},\n\t\t\townerId: sourceObject.ownerId,\n\t\t\tcontrollerId: sourceObject.controllerId,\n\t\t\ttimestamp: ObjectFactory.getNewTimestamp(),\n\t\t\tstatuses: new Set(),\n\t\t\tcounters: new Map(),\n\t\t\tabilities: [],\n\t\t\tboundEffect: boundEffect\n\t\t};\n\n\t\treturn emblem;\n\t}\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/PhaseManager.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/PlayerActionHandler.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 81,
				"column": 35,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 81,
				"endColumn": 49
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 81,
				"column": 51,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 81,
				"endColumn": 63
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 86,
				"column": 45,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 86,
				"endColumn": 62
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 86,
				"column": 64,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 86,
				"endColumn": 86
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'playerId' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 268,
				"column": 35,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 268,
				"endColumn": 43
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 4,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { GameStateManager } from './GameStateManager';\nimport type { IGameObject, ICardInstance } from './types/objects';\nimport { GamePhase, CardType, StatusType } from './types/enums';\nimport { isGameObject } from './types/objects';\n\n/**\n * Handles player actions during Afternoon turns\n * Rule 4.2.3 - Afternoon turn structure\n */\nexport class PlayerActionHandler {\n\tconstructor(private gsm: GameStateManager) {}\n\n\t/**\n\t * Gets available actions for a player during their turn\n\t * Rule 4.2.3.d - Players can play a card, play a quick action, or pass\n\t */\n\tpublic getAvailableActions(playerId: string): PlayerAction[] {\n\t\tif (this.gsm.state.currentPhase !== GamePhase.Afternoon) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (this.gsm.state.currentPlayerId !== playerId) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst actions: PlayerAction[] = [];\n\n\t\t// Always can pass\n\t\tactions.push({\n\t\t\ttype: 'pass',\n\t\t\tdescription: 'Pass turn'\n\t\t});\n\n\t\t// Check playable cards from hand\n\t\tconst playableCards = this.getPlayableCardsFromHand(playerId);\n\t\tfor (const card of playableCards) {\n\t\t\tactions.push({\n\t\t\t\ttype: 'playCard',\n\t\t\t\tcardId: card.instanceId,\n\t\t\t\tzone: 'hand',\n\t\t\t\tdescription: `Play ${card.definitionId} from hand`\n\t\t\t});\n\t\t}\n\n\t\t// Check playable cards from reserve\n\t\tconst playableFromReserve = this.getPlayableCardsFromReserve(playerId);\n\t\tfor (const card of playableFromReserve) {\n\t\t\tactions.push({\n\t\t\t\ttype: 'playCard',\n\t\t\t\tcardId: card.objectId,\n\t\t\t\tzone: 'reserve',\n\t\t\t\tdescription: `Play ${card.name} from reserve`\n\t\t\t});\n\t\t}\n\n\t\t// Check available quick actions\n\t\tconst quickActions = this.getAvailableQuickActions(playerId);\n\t\tfor (const action of quickActions) {\n\t\t\tactions.push(action);\n\t\t}\n\n\t\treturn actions;\n\t}\n\n\t/**\n\t * Executes a player action\n\t * Rule 4.2.3.e - After action, turn continues or ends based on action type\n\t */\n\tpublic async executeAction(playerId: string, action: PlayerAction): Promise<boolean> {\n\t\tif (this.gsm.state.currentPlayerId !== playerId) {\n\t\t\tthrow new Error(`Not ${playerId}'s turn`);\n\t\t}\n\n\t\tswitch (action.type) {\n\t\t\tcase 'pass':\n\t\t\t\tthis.gsm.turnManager.playerPasses(playerId);\n\t\t\t\tconsole.log(`[PlayerAction] ${playerId} passed their turn`);\n\t\t\t\treturn true; // Turn ends\n\n\t\t\tcase 'playCard':\n\t\t\t\tawait this.playCard(playerId, action.cardId!, action.zone!);\n\t\t\t\tconsole.log(`[PlayerAction] ${playerId} played a card`);\n\t\t\t\treturn true; // Turn ends after playing a card\n\n\t\t\tcase 'quickAction':\n\t\t\t\tawait this.executeQuickAction(playerId, action.abilityId!, action.sourceObjectId!);\n\t\t\t\tconsole.log(`[PlayerAction] ${playerId} used a quick action`);\n\t\t\t\treturn false; // Turn continues after quick action\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown action type: ${action.type}`);\n\t\t}\n\t}\n\n\t/**\n\t * Gets cards that can be played from hand\n\t * Rule 5.1.1, 5.2 - Card playing requirements\n\t */\n\tprivate getPlayableCardsFromHand(playerId: string): ICardInstance[] {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) return [];\n\n\t\tconst playableCards: ICardInstance[] = [];\n\n\t\tfor (const card of player.zones.hand.getAll()) {\n\t\t\tif (this.canPlayCardFromHand(playerId, card as ICardInstance)) {\n\t\t\t\tplayableCards.push(card as ICardInstance);\n\t\t\t}\n\t\t}\n\n\t\treturn playableCards;\n\t}\n\n\t/**\n\t * Gets cards that can be played from reserve\n\t * Rule 2.4.5.c-d - Playing from Reserve\n\t */\n\tprivate getPlayableCardsFromReserve(playerId: string): IGameObject[] {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) return [];\n\n\t\tconst playableCards: IGameObject[] = [];\n\n\t\tfor (const entity of player.zones.reserveZone.getAll()) {\n\t\t\tif (isGameObject(entity) && this.canPlayCardFromReserve(playerId, entity)) {\n\t\t\t\tplayableCards.push(entity);\n\t\t\t}\n\t\t}\n\n\t\treturn playableCards;\n\t}\n\n\t/**\n\t * Checks if a card can be played from hand\n\t */\n\tprivate canPlayCardFromHand(playerId: string, card: ICardInstance): boolean {\n\t\tconst definition = this.gsm.getCardDefinition(card.definitionId);\n\t\tif (!definition) return false;\n\n\t\t// Check if player can pay hand cost\n\t\treturn this.canPayManaCost(playerId, definition.handCost);\n\t}\n\n\t/**\n\t * Checks if a card can be played from reserve\n\t * Rule 2.4.5.c-d\n\t */\n\tprivate canPlayCardFromReserve(playerId: string, object: IGameObject): boolean {\n\t\t// Can't play exhausted cards from reserve\n\t\tif (object.statuses.has(StatusType.Exhausted)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst definition = this.gsm.getCardDefinition(object.definitionId);\n\t\tif (!definition) return false;\n\n\t\t// Check if player can pay reserve cost\n\t\treturn this.canPayManaCost(playerId, definition.reserveCost);\n\t}\n\n\t/**\n\t * Checks if player can pay mana cost\n\t * Rule 1.2.5.e - Mana cost paid by exhausting Mana Orbs\n\t */\n\tprivate canPayManaCost(playerId: string, cost: number): boolean {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) return false;\n\n\t\t// Count ready mana orbs\n\t\tlet readyManaOrbs = 0;\n\t\tfor (const entity of player.zones.manaZone.getAll()) {\n\t\t\tif (isGameObject(entity) && !entity.statuses.has(StatusType.Exhausted)) {\n\t\t\t\treadyManaOrbs++;\n\t\t\t}\n\t\t}\n\n\t\treturn readyManaOrbs >= cost;\n\t}\n\n\t/**\n\t * Plays a card from specified zone\n\t */\n\tprivate async playCard(playerId: string, cardId: string, fromZone: string): Promise<void> {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) throw new Error(`Player ${playerId} not found`);\n\n\t\tlet sourceZone;\n\t\tlet isFromReserve = false;\n\n\t\tswitch (fromZone) {\n\t\t\tcase 'hand':\n\t\t\t\tsourceZone = player.zones.hand;\n\t\t\t\tbreak;\n\t\t\tcase 'reserve':\n\t\t\t\tsourceZone = player.zones.reserve;\n\t\t\t\tisFromReserve = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Cannot play card from zone: ${fromZone}`);\n\t\t}\n\n\t\tconst card = sourceZone.findById(cardId);\n\t\tif (!card) throw new Error(`Card ${cardId} not found in ${fromZone}`);\n\n\t\tconst definition = this.gsm.getCardDefinition(card.definitionId);\n\t\tif (!definition) throw new Error(`Definition not found for ${card.definitionId}`);\n\n\t\t// Pay cost\n\t\tconst cost = isFromReserve ? definition.reserveCost : definition.handCost;\n\t\tawait this.payManaCost(playerId, cost);\n\n\t\t// Determine destination zone based on card type\n\t\tlet destinationZone;\n\t\tswitch (definition.type) {\n\t\t\tcase CardType.Character:\n\t\t\t\tdestinationZone = player.zones.expedition;\n\t\t\t\tbreak;\n\t\t\tcase CardType.Permanent:\n\t\t\t\tdestinationZone =\n\t\t\t\t\tdefinition.permanentZoneType === 'Landmark'\n\t\t\t\t\t\t? player.zones.landmarkZone\n\t\t\t\t\t\t: player.zones.expedition;\n\t\t\t\tbreak;\n\t\t\tcase CardType.Spell:\n\t\t\t\t// Spells resolve and may go to Reserve or discard\n\t\t\t\tdestinationZone = player.zones.reserve; // Simplified\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Cannot play card type: ${definition.type}`);\n\t\t}\n\n\t\t// Move card\n\t\tthis.gsm.moveEntity(cardId, sourceZone, destinationZone, playerId);\n\n\t\t// Handle Fleeting status for cards played from Reserve\n\t\tif (isFromReserve && isGameObject(card)) {\n\t\t\tcard.statuses.add(StatusType.Fleeting);\n\t\t}\n\t}\n\n\t/**\n\t * Pays mana cost by exhausting mana orbs\n\t */\n\tprivate async payManaCost(playerId: string, cost: number): Promise<void> {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) throw new Error(`Player ${playerId} not found`);\n\n\t\tlet remainingCost = cost;\n\n\t\tfor (const entity of player.zones.manaZone.getAll()) {\n\t\t\tif (remainingCost <= 0) break;\n\n\t\t\tif (isGameObject(entity) && !entity.statuses.has(StatusType.Exhausted)) {\n\t\t\t\tentity.statuses.add(StatusType.Exhausted);\n\t\t\t\tremainingCost--;\n\t\t\t\tconsole.log(`[PlayerAction] Exhausted mana orb for ${playerId}`);\n\t\t\t}\n\t\t}\n\n\t\tif (remainingCost > 0) {\n\t\t\tthrow new Error(`Insufficient mana: needed ${cost}, could only pay ${cost - remainingCost}`);\n\t\t}\n\t}\n\n\t/**\n\t * Gets available quick actions\n\t */\n\tprivate getAvailableQuickActions(playerId: string): PlayerAction[] {\n\t\t// TODO: Implement quick action detection\n\t\t// Check support abilities, object abilities, etc.\n\t\treturn [];\n\t}\n\n\t/**\n\t * Executes a quick action\n\t */\n\tprivate async executeQuickAction(\n\t\tplayerId: string,\n\t\tabilityId: string,\n\t\tsourceObjectId: string\n\t): Promise<void> {\n\t\t// TODO: Implement quick action execution\n\t\tconsole.log(`[PlayerAction] Executing quick action ${abilityId} from ${sourceObjectId}`);\n\t}\n}\n\nexport interface PlayerAction {\n\ttype: 'playCard' | 'quickAction' | 'pass';\n\tcardId?: string;\n\tzone?: string;\n\tabilityId?: string;\n\tsourceObjectId?: string;\n\tdescription: string;\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/ReactionManager.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 27,
				"column": 54,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 27,
				"endColumn": 57,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [1134, 1137], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [1134, 1137], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 89,
				"column": 84,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 89,
				"endColumn": 87,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [3417, 3420], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [3417, 3420], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 2,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { GameStateManager } from './GameStateManager';\nimport type { ObjectFactory } from './ObjectFactory';\nimport type { IGameObject, IEmblemObject } from './types/objects';\nimport { isGameObject } from './types/objects';\nimport type { EffectResolver } from './EffectResolver';\nimport { CardType, StatusType, ZoneIdentifier } from './types/enums';\nimport { AbilityType, type IAbility } from './types/abilities';\n\nexport class ReactionManager {\n\tprivate gsm: GameStateManager;\n\tprivate objectFactory: ObjectFactory;\n\tprivate effectResolver: EffectResolver;\n\n\tconstructor(gsm: GameStateManager, objectFactory: ObjectFactory, effectResolver: EffectResolver) {\n\t\tthis.gsm = gsm;\n\t\tthis.objectFactory = objectFactory;\n\t\tthis.effectResolver = effectResolver;\n\t}\n\n\t/**\n\t * Scans all objects for reactions that are triggered by a given event.\n\t * Creates Emblem-Reaction objects in Limbo for each triggered reaction.\n\t * Rule 6.3.g, 6.3.d, 6.3.e\n\t * @param eventType The type of event that occurred (e.g., 'entityMoved').\n\t * @param payload The data associated with the event.\n\t */\n\tpublic checkForTriggers(eventType: string, payload: any): void {\n\t\t// --- Part 1: Non-Self-Move Reactions (Rule 6.3.e) ---\n\t\t// These reactions must exist and have an active ability *before* the event.\n\t\tconst allObjects = this.getAllGameObjects();\n\t\tfor (const object of allObjects) {\n\t\t\tconst zone = this.gsm.findZoneOfObject(object.objectId);\n\t\t\tif (!zone) continue;\n\n\t\t\tfor (const ability of object.abilities) {\n\t\t\t\tif (ability.abilityType !== AbilityType.Reaction || ability.isSelfMove) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Check if the ability itself is active based on its location (Rule 2.2.11.g, i, j)\n\t\t\t\tlet isAbilityActive = false;\n\t\t\t\tconst isInPlay = [\n\t\t\t\t\tZoneIdentifier.Expedition,\n\t\t\t\t\tZoneIdentifier.Landmark,\n\t\t\t\t\tZoneIdentifier.Hero\n\t\t\t\t].includes(zone.zoneType);\n\t\t\t\tconst isInReserve = zone.zoneType === ZoneIdentifier.Reserve;\n\n\t\t\t\tif (isInPlay && !ability.isSupportAbility) {\n\t\t\t\t\tisAbilityActive = true;\n\t\t\t\t}\n\t\t\t\tif (isInReserve && ability.isSupportAbility && !object.statuses.has(StatusType.Exhausted)) {\n\t\t\t\t\tisAbilityActive = true;\n\t\t\t\t}\n\n\t\t\t\tif (isAbilityActive && ability.trigger?.eventType === eventType) {\n\t\t\t\t\tif (ability.trigger.condition(payload, object, this.gsm)) {\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`[ReactionManager] TRIGGERED (Non-Self-Move): Ability \"${ability.text}\" on ${object.name} (${object.objectId})`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.createAndAddEmblem(ability, object, payload);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// --- Part 2: Self-Move Reactions (Rule 6.3.d) ---\n\t\t// These reactions are checked on the object *after* it has moved.\n\t\t// Their abilities activate regardless of the new zone (the trigger condition itself is the filter).\n\t\tif (eventType === 'entityMoved' && isGameObject(payload.entity)) {\n\t\t\tconst newObject = payload.entity;\n\t\t\tfor (const ability of newObject.abilities) {\n\t\t\t\tif (\n\t\t\t\t\tability.abilityType === AbilityType.Reaction &&\n\t\t\t\t\tability.isSelfMove &&\n\t\t\t\t\tability.trigger?.eventType === eventType\n\t\t\t\t) {\n\t\t\t\t\tif (ability.trigger.condition(payload, newObject, this.gsm)) {\n\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t`[ReactionManager] TRIGGERED (Self-Move): Ability \"${ability.text}\" on ${newObject.name} (${newObject.objectId})`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.createAndAddEmblem(ability, newObject, payload);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate createAndAddEmblem(ability: IAbility, sourceObject: IGameObject, payload: any): void {\n\t\tconst emblem = this.objectFactory.createReactionEmblem(ability, sourceObject, payload);\n\t\tthis.gsm.state.sharedZones.limbo.add(emblem);\n\t\tconsole.log(`[ReactionManager] Created Emblem-Reaction ${emblem.objectId} in Limbo.`);\n\t}\n\n\t/**\n\t * Processes all currently pending Emblem-Reactions in Limbo,\n\t * following initiative order until none are left.\n\t * Rule 4.4\n\t */\n\tpublic async processReactions(): Promise<void> {\n\t\tlet reactionsInLimbo = this.getReactionsInLimbo();\n\t\tif (reactionsInLimbo.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`[ReactionManager] Starting reaction processing loop with ${reactionsInLimbo.length} pending reaction(s).`\n\t\t);\n\n\t\twhile (reactionsInLimbo.length > 0) {\n\t\t\t// In a multi-player game, we would cycle through players in initiative order.\n\t\t\t// For now, we assume the current player resolves all their reactions first.\n\t\t\tconst initiativePlayerId = this.gsm.state.currentPlayerId;\n\t\t\tconst playerReactions = reactionsInLimbo.filter((r) => r.controllerId === initiativePlayerId);\n\n\t\t\tif (playerReactions.length === 0) {\n\t\t\t\t// This can happen if the other player has reactions but the current player doesn't.\n\t\t\t\t// A full implementation would advance to the next player in initiative order.\n\t\t\t\tconsole.log(\n\t\t\t\t\t`[ReactionManager] Player ${initiativePlayerId} has no reactions to resolve. Breaking loop for now.`\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Player chooses one to resolve. For now, we take the first.\n\t\t\tconst reactionToResolve = playerReactions[0];\n\t\t\tconsole.log(\n\t\t\t\t`[ReactionManager] Player ${initiativePlayerId} resolves: \"${reactionToResolve.name}\"`\n\t\t\t);\n\n\t\t\tthis.effectResolver.resolve(reactionToResolve.boundEffect);\n\t\t\tthis.gsm.state.sharedZones.limbo.remove(reactionToResolve.objectId); // Reaction ceases to exist (Rule 5.4.d)\n\n\t\t\t// After one reaction resolves, we must check for new reactions triggered by it.\n\t\t\t// This is a recursive or iterative process. For simplicity, we just re-fetch the list.\n\t\t\treactionsInLimbo = this.getReactionsInLimbo();\n\t\t}\n\n\t\tconsole.log(`[ReactionManager] Reaction processing loop finished.`);\n\t}\n\n\tprivate getReactionsInLimbo(): IEmblemObject[] {\n\t\tconst limboEntities = this.gsm.state.sharedZones.limbo.getAll();\n\t\treturn limboEntities.filter(\n\t\t\t(e): e is IEmblemObject =>\n\t\t\t\tisGameObject(e) &&\n\t\t\t\te.type === CardType.Emblem &&\n\t\t\t\t(e as IEmblemObject).emblemSubType === 'Reaction'\n\t\t);\n\t}\n\n\tprivate getAllGameObjects(): IGameObject[] {\n\t\tconst objects: IGameObject[] = [];\n\t\tthis.gsm.state.players.forEach((player) => {\n\t\t\t// In-Play zones\n\t\t\tobjects.push(...player.zones.expeditionZone.getAll().filter(isGameObject));\n\t\t\tobjects.push(...player.zones.landmarkZone.getAll().filter(isGameObject));\n\t\t\tobjects.push(...player.zones.heroZone.getAll().filter(isGameObject));\n\t\t\t// Reserve zone (for support abilities)\n\t\t\tobjects.push(...player.zones.reserveZone.getAll().filter(isGameObject));\n\t\t});\n\t\treturn objects;\n\t}\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/RuleAdjudicator.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'allCurrentAbilities' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 47,
				"column": 3,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 47,
				"endColumn": 22
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 167,
				"column": 37,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 167,
				"endColumn": 54
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 168,
				"column": 37,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 168,
				"endColumn": 54
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 186,
				"column": 45,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 186,
				"endColumn": 72
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 196,
				"column": 38,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 196,
				"endColumn": 55
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 197,
				"column": 38,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 197,
				"endColumn": 55
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 204,
				"column": 46,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 204,
				"endColumn": 77
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 215,
				"column": 57,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 215,
				"endColumn": 60,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [8676, 8679], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [8676, 8679], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 236,
				"column": 70,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 236,
				"endColumn": 73,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [9554, 9557], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [9554, 9557], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 250,
				"column": 81,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 250,
				"endColumn": 84,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [10216, 10219], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [10216, 10219], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 251,
				"column": 37,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 251,
				"endColumn": 40,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [10265, 10268], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [10265, 10268], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 259,
				"column": 25,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 259,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [10478, 10481], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [10478, 10481], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'KeywordAbility' is not defined.",
				"line": 374,
				"column": 25,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 374,
				"endColumn": 39
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'KeywordAbility' is not defined.",
				"line": 374,
				"column": 63,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 374,
				"endColumn": 77
			}
		],
		"suppressedMessages": [],
		"errorCount": 3,
		"fatalErrorCount": 0,
		"warningCount": 11,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "// src/engine/RuleAdjudicator.ts (New File)\n\nimport type { GameStateManager } from './GameStateManager';\nimport type { IGameObject } from './types/objects';\nimport type { IAbility } from './types/abilities';\n\nexport class RuleAdjudicator {\n\tconstructor(private gsm: GameStateManager) {}\n\n\t/**\n\t * Re-evaluates and applies all passive abilities in the game.\n\t * This should be called after any event modifies the game state.\n\t * Implements Rule 2.3.\n\t */\n\tpublic applyAllPassiveAbilities(): void {\n\t\tconst allObjects = this.getAllPlayObjects();\n\n\t\t// 1. Reset all objects to their base characteristics\n\t\tallObjects.forEach((obj) => {\n\t\t\tobj.currentCharacteristics = { ...obj.baseCharacteristics };\n\t\t});\n\n\t\t// 2. Gather all passive abilities\n\t\t// Ensure each ability has its sourceObjectId correctly set to the current object's ID\n\t\t// This is critical because obj.abilities might be derived from definitions or prior states.\n\t\tconst allPassiveAbilities = allObjects.flatMap((obj) => {\n\t\t\treturn obj.abilities\n\t\t\t\t.filter((a) => a.abilityType === 'passive')\n\t\t\t\t.map((a) => ({ ...a, sourceObjectId: obj.objectId }));\n\t\t});\n\n\t\t// 3. Sort abilities based on dependency and then timestamp (Rule 2.3.3)\n\t\t//    This is a complex step. You'll need to build a dependency graph.\n\t\tconst sortedAbilities = this.sortAbilitiesByDependency(allPassiveAbilities);\n\n\t\t// 4. Apply abilities in the sorted order\n\t\tfor (const ability of sortedAbilities) {\n\t\t\tthis.applyAbility(ability);\n\t\t}\n\n\t\tconsole.log('[RuleAdjudicator] Re-applied all passive abilities.');\n\t}\n\n\tprivate doesADependOnB(\n\t\tabilityA: IAbility,\n\t\tabilityB: IAbility,\n\t\tallCurrentAbilities: IAbility[]\n\t): boolean {\n\t\t// Rule 2.3.2: A depends on B if B's application could change A's existence, text, or how it applies.\n\t\tif (!abilityA.sourceObjectId || !abilityB.sourceObjectId) return false;\n\n\t\tconst sourceA = this.gsm.getObject(abilityA.sourceObjectId);\n\t\t// const sourceB = this.gsm.getObject(abilityB.sourceObjectId); // Not always needed directly\n\t\tif (!sourceA) return false;\n\n\t\tfor (const stepB of abilityB.effect.steps) {\n\t\t\tconst targetIdsOfB = this.gsm.effectProcessor.resolveTargetsForDependency(\n\t\t\t\tstepB.targets,\n\t\t\t\tabilityB.sourceObjectId,\n\t\t\t\tabilityB._triggerPayload\n\t\t\t);\n\n\t\t\t// 2.3.2.d: B removes or negates A\n\t\t\tif (stepB.verb === 'lose_ability' || stepB.verb === 'loseAbility') {\n\t\t\t\tif (targetIdsOfB.includes(sourceA.objectId)) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tstepB.parameters?.abilityId === abilityA.abilityId ||\n\t\t\t\t\t\tstepB.parameters?.allAbilities === true\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn true; // B removes A\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (stepB.verb === 'moveTo' || stepB.verb === 'move_to') {\n\t\t\t\t// B causes A's source to leave play\n\t\t\t\tif (targetIdsOfB.includes(sourceA.objectId)) {\n\t\t\t\t\tconst destZone = this.gsm.effectProcessor.findZoneByTypeForDependency(\n\t\t\t\t\t\tsourceA.controllerId,\n\t\t\t\t\t\tstepB.parameters?.zone\n\t\t\t\t\t);\n\t\t\t\t\tif (destZone && destZone.visibility === 'hidden') return true; // B moves source of A out of play\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2.3.2.e: B changes what A applies to (characteristics like type/subtype, or zone)\n\t\t\t// This is complex. Simple case: B changes type, A targets that type.\n\t\t\tif (abilityA.effect.targetCriteria?.type && stepB.verb === 'set_characteristic') {\n\t\t\t\t// e.g. A targets 'Goblin'\n\t\t\t\tif (targetIdsOfB.some((id) => id !== sourceA.objectId)) {\n\t\t\t\t\t// B affects objects other than A's source\n\t\t\t\t\tif (\n\t\t\t\t\t\tstepB.parameters?.characteristic === 'type' &&\n\t\t\t\t\t\tstepB.parameters?.value === abilityA.effect.targetCriteria.type\n\t\t\t\t\t) {\n\t\t\t\t\t\t// If B changes an object to become type X, and A targets type X.\n\t\t\t\t\t\t// Or if B changes an object from type X to something else.\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2.3.2.f: B changes what A does (modifies characteristics A's condition/effect relies on)\n\t\t\tif (targetIdsOfB.includes(sourceA.objectId)) {\n\t\t\t\t// B affects source of A\n\t\t\t\tif (stepB.verb === 'modify_statistics' || stepB.verb === 'set_characteristic') {\n\t\t\t\t\t// Example: A's condition: \"if power >= 5\". B modifies power.\n\t\t\t\t\t// Example: A's effect: \"draw X cards where X is power\". B modifies power.\n\t\t\t\t\t// This requires knowing what characteristics A *reads*. For now, assume any stat/char change is a potential dependency.\n\t\t\t\t\tif (\n\t\t\t\t\t\tstepB.parameters?.power ||\n\t\t\t\t\t\tstepB.parameters?.health ||\n\t\t\t\t\t\t(stepB.parameters?.characteristic &&\n\t\t\t\t\t\t\tabilityA.text.includes(stepB.parameters.characteristic))\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate sortAbilitiesByDependency(abilities: IAbility[]): IAbility[] {\n\t\tlet unappliedAbilities = [...abilities];\n\t\tconst sortedAbilities: IAbility[] = [];\n\t\tconst appliedTimestamps = new Set<number>(); // To handle Rule 2.3.3.d for ties\n\n\t\twhile (unappliedAbilities.length > 0) {\n\t\t\tlet freeAbilities: IAbility[] = [];\n\n\t\t\tfor (const abilityA of unappliedAbilities) {\n\t\t\t\tlet isFree = true;\n\t\t\t\tfor (const abilityB of unappliedAbilities) {\n\t\t\t\t\tif (abilityA === abilityB) continue;\n\n\t\t\t\t\tif (this.doesADependOnB(abilityA, abilityB, unappliedAbilities)) {\n\t\t\t\t\t\t// A depends on B. Is B dependent on A as well (circular)?\n\t\t\t\t\t\tif (!this.doesADependOnB(abilityB, abilityA, unappliedAbilities)) {\n\t\t\t\t\t\t\tisFree = false; // A depends on B, but B does not depend on A\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If B also depends on A, it's a circular dependency,\n\t\t\t\t\t\t// and they are considered \"free\" relative to each other for timestamp sorting.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isFree) {\n\t\t\t\t\tfreeAbilities.push(abilityA);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (freeAbilities.length === 0 && unappliedAbilities.length > 0) {\n\t\t\t\t// This should ideally not happen if dependency logic is correct,\n\t\t\t\t// but as a fallback, or if there's an unresolvable circular dependency\n\t\t\t\t// not handled by timestamp, we might break or add error handling.\n\t\t\t\t// For now, let's just add the remaining by timestamp to avoid infinite loops.\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'[RuleAdjudicator] No free abilities found, but unapplied abilities remain. Sorting rest by timestamp.',\n\t\t\t\t\tunappliedAbilities\n\t\t\t\t);\n\t\t\t\tfreeAbilities = [...unappliedAbilities];\n\t\t\t}\n\n\t\t\t// From the \"free\" abilities, select the one whose source object has the smallest timestamp. (Rule 2.3.3.c)\n\t\t\t// Handle ties using Rule 2.3.3.d (already applied abilities' timestamps) - this is complex.\n\t\t\t// For now, a simple timestamp sort.\n\t\t\tfreeAbilities.sort((a, b) => {\n\t\t\t\tconst objA = this.gsm.getObject(a.sourceObjectId!);\n\t\t\t\tconst objB = this.gsm.getObject(b.sourceObjectId!);\n\t\t\t\tif (!objA || !objB) return 0; // Should not happen if data is consistent\n\t\t\t\tif (objA.timestamp === objB.timestamp) {\n\t\t\t\t\t// Rule 2.3.3.d - if timestamps are equal, check if one source object's abilities\n\t\t\t\t\t// have already been applied. This part is tricky and might need more state.\n\t\t\t\t\t// For now, a simple secondary sort or arbitrary pick is fine.\n\t\t\t\t\t// A truly compliant solution would need to track which object's abilities\n\t\t\t\t\t// (even if different specific abilities) were chosen in previous steps.\n\t\t\t\t\t// This simplified version might not fully comply with 2.3.3.d for tie-breaking.\n\t\t\t\t\treturn 0; // Keep original order for now on ties, or implement a more robust tie-breaker\n\t\t\t\t}\n\t\t\t\treturn objA.timestamp - objB.timestamp;\n\t\t\t});\n\n\t\t\tif (freeAbilities.length > 0) {\n\t\t\t\tconst nextAbility = freeAbilities[0];\n\t\t\t\tsortedAbilities.push(nextAbility);\n\t\t\t\tunappliedAbilities = unappliedAbilities.filter((a) => a !== nextAbility);\n\t\t\t\tconst sourceObject = this.gsm.getObject(nextAbility.sourceObjectId!);\n\t\t\t\tif (sourceObject) {\n\t\t\t\t\tappliedTimestamps.add(sourceObject.timestamp);\n\t\t\t\t}\n\t\t\t} else if (unappliedAbilities.length > 0) {\n\t\t\t\t// If no ability was selected (e.g. freeAbilities was empty or became empty after filtering)\n\t\t\t\t// and there are still unapplied abilities, this indicates a potential issue\n\t\t\t\t// or a state where the current simplified dependency logic cannot proceed.\n\t\t\t\t// Fallback: Add the one with the smallest timestamp from remaining unapplied to prevent infinite loop.\n\t\t\t\tunappliedAbilities.sort((a, b) => {\n\t\t\t\t\tconst objA = this.gsm.getObject(a.sourceObjectId!);\n\t\t\t\t\tconst objB = this.gsm.getObject(b.sourceObjectId!);\n\t\t\t\t\tif (!objA || !objB) return 0;\n\t\t\t\t\treturn objA.timestamp - objB.timestamp;\n\t\t\t\t});\n\t\t\t\tconst fallbackAbility = unappliedAbilities.shift();\n\t\t\t\tif (fallbackAbility) {\n\t\t\t\t\tsortedAbilities.push(fallbackAbility);\n\t\t\t\t\tconst sourceObject = this.gsm.getObject(fallbackAbility.sourceObjectId!);\n\t\t\t\t\tif (sourceObject) {\n\t\t\t\t\t\tappliedTimestamps.add(sourceObject.timestamp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sortedAbilities;\n\t}\n\n\t// --- Helper methods for applying ability effects ---\n\tprivate _modifyStatistics(target: IGameObject, params: any): void {\n\t\tif (!target.currentCharacteristics.statistics) {\n\t\t\ttarget.currentCharacteristics.statistics = {\n\t\t\t\tforest: 0,\n\t\t\t\tmountain: 0,\n\t\t\t\twater: 0,\n\t\t\t\tpower: 0,\n\t\t\t\thealth: 0\n\t\t\t};\n\t\t}\n\t\tconst stats = target.currentCharacteristics.statistics;\n\t\tif (params.forest !== undefined) stats.forest = (stats.forest || 0) + params.forest;\n\t\tif (params.mountain !== undefined) stats.mountain = (stats.mountain || 0) + params.mountain;\n\t\tif (params.water !== undefined) stats.water = (stats.water || 0) + params.water;\n\t\tif (params.power !== undefined) stats.power = (stats.power || 0) + params.power;\n\t\tif (params.health !== undefined) stats.health = (stats.health || 0) + params.health;\n\t\tconsole.log(\n\t\t\t`[RuleAdjudicator] Modified stats for ${target.name}: P:${params.power}, H:${params.health}`\n\t\t);\n\t}\n\n\tprivate _grantKeyword(target: IGameObject, keyword: string, value?: any): void {\n\t\t// Assuming keyword is string for now\n\t\tif (!target.currentCharacteristics.keywords) target.currentCharacteristics.keywords = {};\n\t\ttarget.currentCharacteristics.keywords[keyword] = value !== undefined ? value : true;\n\t\tconsole.log(`[RuleAdjudicator] Granted keyword ${keyword} to ${target.name}`);\n\t}\n\n\tprivate _loseKeyword(target: IGameObject, keyword: string): void {\n\t\tif (target.currentCharacteristics.keywords) {\n\t\t\tdelete target.currentCharacteristics.keywords[keyword];\n\t\t\tconsole.log(`[RuleAdjudicator] Lost keyword ${keyword} from ${target.name}`);\n\t\t}\n\t}\n\n\tprivate _setCharacteristic(target: IGameObject, characteristic: string, value: any): void {\n\t\t(target.currentCharacteristics as any)[characteristic] = value;\n\t\tconsole.log(\n\t\t\t`[RuleAdjudicator] Set characteristic ${characteristic}=${value} for ${target.name}`\n\t\t);\n\t}\n\n\tprivate _grantAbility(\n\t\ttarget: IGameObject,\n\t\tnewAbilityDefinition: any /* IAbilityDefinition */\n\t): void {\n\t\t// This is complex: needs to instantiate an IAbility from IAbilityDefinition\n\t\t// and ensure it doesn't grant itself infinitely. For now, placeholder.\n\t\t// A proper implementation would add to a list of 'grantedAbilities' on currentCharacteristics.\n\t\tconsole.log(\n\t\t\t`[RuleAdjudicator] Placeholder: Granted ability defined by ${newAbilityDefinition.id} to ${target.name}`\n\t\t);\n\t\t// Example: if abilities are stored directly on currentCharacteristics (not typical for passive layers)\n\t\t// if (!target.currentCharacteristics.abilities) target.currentCharacteristics.abilities = [];\n\t\t// target.currentCharacteristics.abilities.push(this.gsm.objectFactory.createAbility(newAbilityDefinition, target.objectId));\n\t}\n\n\tprivate _loseAbility(target: IGameObject, abilityIdToLose: string): void {\n\t\t// Similar to grant, this is complex. Placeholder.\n\t\t// Would modify currentCharacteristics to mark an ability as lost/negated.\n\t\tconsole.log(\n\t\t\t`[RuleAdjudicator] Placeholder: Lost ability ${abilityIdToLose} from ${target.name}`\n\t\t);\n\t}\n\n\tprivate applyAbility(ability: IAbility): void {\n\t\tif (!ability.sourceObjectId) return;\n\t\tconst sourceObject = this.gsm.getObject(ability.sourceObjectId);\n\t\tif (!sourceObject) {\n\t\t\tconsole.warn(\n\t\t\t\t`[RuleAdjudicator] Source object ${ability.sourceObjectId} not found for ability ${ability.abilityId}`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!sourceObject.currentCharacteristics) {\n\t\t\tsourceObject.currentCharacteristics = { ...sourceObject.baseCharacteristics };\n\t\t}\n\n\t\tconsole.log(\n\t\t\t`[RuleAdjudicator] Applying passive ability ${ability.abilityId} from ${sourceObject.name} (${sourceObject.objectId})`\n\t\t);\n\n\t\tfor (const step of ability.effect.steps) {\n\t\t\t// Determine targets for this step. For many passives, target is 'self' (the sourceObject).\n\t\t\t// This part needs to be flexible if passives can target others.\n\t\t\t// For now, let's assume most passive steps implicitly target the sourceObject unless specified otherwise.\n\t\t\tlet targetsOfStep: IGameObject[] = [sourceObject];\n\t\t\tif (step.targets) {\n\t\t\t\t// A simple 'self' check, could be expanded\n\t\t\t\tif (step.targets === 'self') {\n\t\t\t\t\ttargetsOfStep = [sourceObject];\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: Implement more complex target resolution for passive effects if needed.\n\t\t\t\t\t// For now, if not 'self', it's unclear who the target is for a passive step.\n\t\t\t\t\t// Most passives modify their source.\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[RuleAdjudicator] Passive ability step has non-'self' target: ${step.targets}. Assuming 'self' for now.`\n\t\t\t\t\t);\n\t\t\t\t\ttargetsOfStep = [sourceObject];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const target of targetsOfStep) {\n\t\t\t\tif (!target.currentCharacteristics) {\n\t\t\t\t\t// Ensure target also has currentCharacteristics\n\t\t\t\t\ttarget.currentCharacteristics = { ...target.baseCharacteristics };\n\t\t\t\t}\n\t\t\t\tswitch (step.verb.toLowerCase()) {\n\t\t\t\t\tcase 'modify_statistics':\n\t\t\t\t\tcase 'modifystatistics':\n\t\t\t\t\t\tthis._modifyStatistics(target, step.parameters);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'grant_keyword':\n\t\t\t\t\tcase 'grantkeyword':\n\t\t\t\t\t\tif (step.parameters?.keyword) {\n\t\t\t\t\t\t\tthis._grantKeyword(target, step.parameters.keyword, step.parameters.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'lose_keyword':\n\t\t\t\t\tcase 'losekeyword':\n\t\t\t\t\t\tif (step.parameters?.keyword) {\n\t\t\t\t\t\t\tthis._loseKeyword(target, step.parameters.keyword);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'set_characteristic':\n\t\t\t\t\tcase 'setcharacteristic':\n\t\t\t\t\t\tif (step.parameters?.characteristic && step.parameters.value !== undefined) {\n\t\t\t\t\t\t\tthis._setCharacteristic(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tstep.parameters.characteristic,\n\t\t\t\t\t\t\t\tstep.parameters.value\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'grant_ability': // Assuming IAbilityDefinition is passed in parameters.ability\n\t\t\t\t\tcase 'grantability':\n\t\t\t\t\t\tif (step.parameters?.ability) {\n\t\t\t\t\t\t\tthis._grantAbility(target, step.parameters.ability);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'lose_ability':\n\t\t\t\t\tcase 'loseability':\n\t\t\t\t\t\tif (step.parameters?.abilityId) {\n\t\t\t\t\t\t\tthis._loseAbility(target, step.parameters.abilityId);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// Legacy keyword handling from original applyAbility (can be refactored to use steps)\n\t\t\t\t\tcase 'apply_keyword_gigantic':\n\t\t\t\t\t\tthis._grantKeyword(target, 'Gigantic');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'apply_keyword_defender':\n\t\t\t\t\t\tthis._grantKeyword(target, 'Defender');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'apply_keyword_eternal':\n\t\t\t\t\t\tthis._grantKeyword(target, 'Eternal');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Check if verb matches a known keyword directly for very simple passives\n\t\t\t\t\t\tif (Object.values(KeywordAbility).includes(step.verb as KeywordAbility)) {\n\t\t\t\t\t\t\tthis._grantKeyword(target, step.verb);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t\t`[RuleAdjudicator] Passive ability ${ability.abilityId} step verb '${step.verb}' has no specific application logic yet.`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getAllPlayObjects(): IGameObject[] {\n\t\tconst objects: IGameObject[] = [];\n\t\t// Iterate over the values (IPlayer objects) of the Map\n\t\tfor (const player of this.gsm.state.players.values()) {\n\t\t\t// Corrected to lowercase 'expedition' and 'landmark'\n\t\t\tif (player.zones.expedition) {\n\t\t\t\tobjects.push(...player.zones.expedition.getAll());\n\t\t\t}\n\t\t\tif (player.zones.landmarkZone) {\n\t\t\t\tobjects.push(...player.zones.landmarkZone.getAll());\n\t\t\t}\n\t\t}\n\t\treturn objects;\n\t}\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/StatusEffectHandler.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'ZoneIdentifier' is defined but never used.",
				"line": 3,
				"column": 32,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 3,
				"endColumn": 46
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 209,
				"column": 69,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 209,
				"endColumn": 72,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [6832, 6835], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [6832, 6835], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 210,
				"column": 18,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 210,
				"endColumn": 21,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [6855, 6858], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [6855, 6858], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'object' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 245,
				"column": 30,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 245,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'object' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 252,
				"column": 28,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 252,
				"endColumn": 34
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'object' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 259,
				"column": 31,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 259,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 266,
				"column": 43,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 266,
				"endColumn": 46,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [8373, 8376], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [8373, 8376], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 4,
		"fatalErrorCount": 0,
		"warningCount": 3,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { GameStateManager } from './GameStateManager';\nimport type { IGameObject } from './types/objects';\nimport { StatusType, CardType, ZoneIdentifier, CounterType } from './types/enums';\nimport { isGameObject } from './types/objects';\n\n/**\n * Handles all status effect mechanics and their interactions\n * Rules 2.4.2 through 2.4.6\n */\nexport class StatusEffectHandler {\n\tconstructor(private gsm: GameStateManager) {}\n\n\t/**\n\t * Applies status effect when object gains status\n\t * Rule 2.4 - Status effects modify object behavior\n\t */\n\tpublic applyStatusEffect(object: IGameObject, status: StatusType): void {\n\t\tobject.statuses.add(status);\n\t\tconsole.log(`[StatusHandler] ${object.name} gained ${status} status`);\n\n\t\t// Handle immediate effects of gaining status\n\t\tswitch (status) {\n\t\t\tcase StatusType.Boosted:\n\t\t\t\tthis.handleBoostedGained(object);\n\t\t\t\tbreak;\n\t\t\tcase StatusType.Fleeting:\n\t\t\t\tthis.handleFleetingGained(object);\n\t\t\t\tbreak;\n\t\t\t// Other statuses don't have immediate gain effects\n\t\t}\n\t}\n\n\t/**\n\t * Removes status effect and handles any removal effects\n\t */\n\tpublic removeStatusEffect(object: IGameObject, status: StatusType): void {\n\t\tif (!object.statuses.has(status)) return;\n\n\t\tobject.statuses.delete(status);\n\t\tconsole.log(`[StatusHandler] ${object.name} lost ${status} status`);\n\n\t\t// Handle effects of losing status\n\t\tswitch (status) {\n\t\t\tcase StatusType.Boosted:\n\t\t\t\tthis.handleBoostedLost(object);\n\t\t\t\tbreak;\n\t\t\t// Other statuses don't have removal effects\n\t\t}\n\t}\n\n\t/**\n\t * Rule 2.4.2 - Anchored: During Rest, Anchored Characters are not sent to Reserve\n\t * During Rest, Anchored objects lose Anchored.\n\t */\n\tpublic processAnchoredDuringRest(object: IGameObject): boolean {\n\t\tif (!object.statuses.has(StatusType.Anchored)) return false;\n\n\t\t// Remove Anchored status during Rest\n\t\tthis.removeStatusEffect(object, StatusType.Anchored);\n\n\t\t// Return true to indicate object should not go to Reserve\n\t\tconsole.log(`[StatusHandler] ${object.name} was Anchored, not going to Reserve`);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Rule 2.4.3 - Asleep: During Progress, Asleep Character statistics don't count\n\t * During Rest, Asleep objects are not sent to Reserve and lose Asleep.\n\t */\n\tpublic processAsleepDuringProgress(object: IGameObject): boolean {\n\t\tif (!object.statuses.has(StatusType.Asleep)) return false;\n\n\t\tconsole.log(`[StatusHandler] ${object.name} is Asleep, statistics don't count for Progress`);\n\t\treturn true; // Statistics should be ignored\n\t}\n\n\tpublic processAsleepDuringRest(object: IGameObject): boolean {\n\t\tif (!object.statuses.has(StatusType.Asleep)) return false;\n\n\t\t// Remove Asleep status during Rest\n\t\tthis.removeStatusEffect(object, StatusType.Asleep);\n\n\t\t// Return true to indicate object should not go to Reserve\n\t\tconsole.log(`[StatusHandler] ${object.name} was Asleep, not going to Reserve`);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Rule 2.4.4 - Boosted: Object is Boosted if it has at least one boost counter\n\t * Status changes automatically when boosts are added/removed\n\t */\n\tpublic updateBoostedStatus(object: IGameObject): void {\n\t\tconst boostCounters = object.counters.get(CounterType.Boost) || 0;\n\t\tconst hasBoosted = object.statuses.has(StatusType.Boosted);\n\n\t\tif (boostCounters > 0 && !hasBoosted) {\n\t\t\tthis.applyStatusEffect(object, StatusType.Boosted);\n\t\t} else if (boostCounters === 0 && hasBoosted) {\n\t\t\tthis.removeStatusEffect(object, StatusType.Boosted);\n\t\t}\n\t}\n\n\t/**\n\t * Rule 2.4.5 - Exhausted: Exhausted cards in Reserve cannot be played and have no support abilities\n\t * Objects that are not exhausted are \"ready\"\n\t */\n\tpublic canPlayFromReserve(object: IGameObject): boolean {\n\t\tif (object.statuses.has(StatusType.Exhausted)) {\n\t\t\tconsole.log(`[StatusHandler] Cannot play ${object.name} from Reserve - Exhausted`);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic hasSupportAbilities(object: IGameObject): boolean {\n\t\tif (object.statuses.has(StatusType.Exhausted)) {\n\t\t\tconsole.log(`[StatusHandler] ${object.name} has no support abilities - Exhausted`);\n\t\t\treturn false;\n\t\t}\n\t\treturn object.abilities.some((ability) => ability.isSupportAbility);\n\t}\n\n\t/**\n\t * Rule 2.4.6 - Fleeting: Cards played from Reserve gain Fleeting\n\t * Fleeting Characters/Permanents are discarded instead of going to Reserve\n\t */\n\tpublic applyFleetingOnPlayFromReserve(object: IGameObject): void {\n\t\tthis.applyStatusEffect(object, StatusType.Fleeting);\n\t\tconsole.log(`[StatusHandler] ${object.name} gained Fleeting from being played from Reserve`);\n\t}\n\n\tpublic processFleetingDuringRest(object: IGameObject): 'discard' | 'reserve' | 'stay' {\n\t\tif (!object.statuses.has(StatusType.Fleeting)) {\n\t\t\treturn 'reserve'; // Normal behavior\n\t\t}\n\n\t\t// Fleeting objects go to discard instead of Reserve\n\t\tconsole.log(`[StatusHandler] ${object.name} is Fleeting, going to discard instead of Reserve`);\n\t\treturn 'discard';\n\t}\n\n\t/**\n\t * Processes all status effects during phase transitions\n\t */\n\tpublic processStatusEffectsDuringPhase(phase: string): void {\n\t\tconsole.log(`[StatusHandler] Processing status effects for ${phase} phase`);\n\n\t\tswitch (phase.toLowerCase()) {\n\t\t\tcase 'morning':\n\t\t\t\tthis.processStatusEffectsDuringMorning();\n\t\t\t\tbreak;\n\t\t\tcase 'dusk':\n\t\t\t\tthis.processStatusEffectsDuringDusk();\n\t\t\t\tbreak;\n\t\t\tcase 'night':\n\t\t\t\tthis.processStatusEffectsDuringNight();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Morning phase status processing (during Prepare)\n\t * Rule 4.2.1.c - Ready all exhausted cards and objects\n\t */\n\tprivate processStatusEffectsDuringMorning(): void {\n\t\tfor (const zone of this.getAllVisibleZones()) {\n\t\t\tfor (const entity of zone.getAll()) {\n\t\t\t\tif (isGameObject(entity) && entity.statuses.has(StatusType.Exhausted)) {\n\t\t\t\t\tthis.removeStatusEffect(entity, StatusType.Exhausted);\n\t\t\t\t\tconsole.log(`[StatusHandler] ${entity.name} became ready during Prepare`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Dusk phase status processing (during Progress)\n\t */\n\tprivate processStatusEffectsDuringDusk(): void {\n\t\t// Status effects are checked during expedition progress calculation\n\t\t// This is handled in the Progress phase logic\n\t}\n\n\t/**\n\t * Night phase status processing (during Rest)\n\t */\n\tprivate processStatusEffectsDuringNight(): void {\n\t\tfor (const player of this.gsm.state.players.values()) {\n\t\t\tconst expeditionZone = player.zones.expeditionZone;\n\n\t\t\tfor (const entity of expeditionZone.getAll()) {\n\t\t\t\tif (isGameObject(entity) && entity.type === CardType.Character) {\n\t\t\t\t\t// Process Anchored and Asleep statuses\n\t\t\t\t\tconst wasAnchored = this.processAnchoredDuringRest(entity);\n\t\t\t\t\tconst wasAsleep = this.processAsleepDuringRest(entity);\n\n\t\t\t\t\t// These statuses prevent going to Reserve\n\t\t\t\t\tif (wasAnchored || wasAsleep) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if an object should be affected by status during specific events\n\t */\n\tpublic checkStatusInteraction(object: IGameObject, event: string): any {\n\t\tconst results: any = {};\n\n\t\tswitch (event) {\n\t\t\tcase 'progress':\n\t\t\t\tresults.ignoreStats = this.processAsleepDuringProgress(object);\n\t\t\t\tbreak;\n\t\t\tcase 'rest':\n\t\t\t\tresults.anchored = this.processAnchoredDuringRest(object);\n\t\t\t\tresults.asleep = this.processAsleepDuringRest(object);\n\t\t\t\tresults.fleetingDestination = this.processFleetingDuringRest(object);\n\t\t\t\tbreak;\n\t\t\tcase 'playFromReserve':\n\t\t\t\tresults.canPlay = this.canPlayFromReserve(object);\n\t\t\t\tbreak;\n\t\t\tcase 'supportCheck':\n\t\t\t\tresults.hasSupport = this.hasSupportAbilities(object);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn results;\n\t}\n\n\t/**\n\t * Handles automatic status updates based on game state changes\n\t */\n\tpublic updateAutomaticStatuses(object: IGameObject): void {\n\t\t// Update Boosted status based on boost counters\n\t\tthis.updateBoostedStatus(object);\n\n\t\t// TODO: Add other automatic status updates as needed\n\t}\n\n\t/**\n\t * Handle effects when Boosted status is gained\n\t */\n\tprivate handleBoostedGained(object: IGameObject): void {\n\t\t// Boosted status is automatic based on counters, no additional effects\n\t}\n\n\t/**\n\t * Handle effects when Boosted status is lost\n\t */\n\tprivate handleBoostedLost(object: IGameObject): void {\n\t\t// Boosted status is automatic based on counters, no additional effects\n\t}\n\n\t/**\n\t * Handle effects when Fleeting status is gained\n\t */\n\tprivate handleFleetingGained(object: IGameObject): void {\n\t\t// Fleeting affects Rest behavior, no immediate effects\n\t}\n\n\t/**\n\t * Gets all visible zones for status processing\n\t */\n\tprivate *getAllVisibleZones(): Generator<any> {\n\t\tfor (const player of this.gsm.state.players.values()) {\n\t\t\tyield player.zones.discardPileZone;\n\t\t\tyield player.zones.manaZone;\n\t\t\tyield player.zones.reserveZone;\n\t\t\tyield player.zones.landmarkZone;\n\t\t\tyield player.zones.heroZone;\n\t\t\tyield player.zones.expeditionZone;\n\t\t}\n\t\tyield this.gsm.state.sharedZones.adventure;\n\t\tyield this.gsm.state.sharedZones.limbo;\n\t}\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/SupportAbilityHandler.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 45,
				"column": 66,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 45,
				"endColumn": 69,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [1471, 1474], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [1471, 1474], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 70,
				"column": 42,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 70,
				"endColumn": 45,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [2383, 2386], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [2383, 2386], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'context' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 70,
				"column": 47,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 70,
				"endColumn": 54
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 70,
				"column": 65,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 70,
				"endColumn": 68,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [2406, 2409], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [2406, 2409], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 3,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { IGameObject } from './types/objects';\nimport type { GameStateManager } from './GameStateManager';\nimport { StatusType } from './types/enums';\nimport { AbilityType } from './types/abilities';\nimport { isGameObject } from './types/objects';\n\n/**\n * Handles Support abilities that work only in Reserve zone\n * Rule 2.2.11.e, 2.4.5.e\n */\nexport class SupportAbilityHandler {\n\tconstructor(private gsm: GameStateManager) {}\n\n\t/**\n\t * Gets all active support abilities from all players' reserves\n\t * Rule 2.2.11.e: Support abilities only work in Reserve and only when ready\n\t */\n\tpublic getActiveSupportAbilities(): IGameObject[] {\n\t\tconst activeSupportObjects: IGameObject[] = [];\n\n\t\tfor (const player of this.gsm.state.players.values()) {\n\t\t\tconst reserveZone = player.zones.reserve;\n\n\t\t\tfor (const entity of reserveZone.getAll()) {\n\t\t\t\tif (isGameObject(entity) && !entity.statuses.has(StatusType.Exhausted)) {\n\t\t\t\t\t// Check if this object has support abilities\n\t\t\t\t\tconst hasSupportAbilities = entity.abilities.some(\n\t\t\t\t\t\t(ability) => ability.abilityType === AbilityType.Support || ability.isSupportAbility\n\t\t\t\t\t);\n\n\t\t\t\t\tif (hasSupportAbilities) {\n\t\t\t\t\t\tactiveSupportObjects.push(entity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn activeSupportObjects;\n\t}\n\n\t/**\n\t * Processes all active support abilities for a given game event\n\t * This would be called by the event system when relevant events occur\n\t */\n\tpublic processSupportAbilities(eventType: string, eventPayload: any): void {\n\t\tconst activeSupportObjects = this.getActiveSupportAbilities();\n\n\t\tfor (const supportObject of activeSupportObjects) {\n\t\t\tfor (const ability of supportObject.abilities) {\n\t\t\t\tif (\n\t\t\t\t\t(ability.abilityType === AbilityType.Support || ability.isSupportAbility) &&\n\t\t\t\t\tability.abilityType === AbilityType.Reaction &&\n\t\t\t\t\tability.trigger?.eventType === eventType\n\t\t\t\t) {\n\t\t\t\t\t// Check if trigger condition is met\n\t\t\t\t\tif (ability.trigger.condition(eventPayload, supportObject, this.gsm)) {\n\t\t\t\t\t\tconsole.log(`[SupportHandler] Triggering support ability from ${supportObject.name}`);\n\t\t\t\t\t\t// TODO: Execute the ability effect\n\t\t\t\t\t\t// this.gsm.effectResolver.resolveEffect(ability.effect, supportObject);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Applies passive support abilities that modify game rules\n\t * These are checked when relevant calculations are made\n\t */\n\tpublic applySupportModifiers(baseValue: any, context: string): any {\n\t\tconst activeSupportObjects = this.getActiveSupportAbilities();\n\t\tlet modifiedValue = baseValue;\n\n\t\tfor (const supportObject of activeSupportObjects) {\n\t\t\tfor (const ability of supportObject.abilities) {\n\t\t\t\tif (\n\t\t\t\t\t(ability.abilityType === AbilityType.Support || ability.isSupportAbility) &&\n\t\t\t\t\tability.abilityType === AbilityType.Passive\n\t\t\t\t) {\n\t\t\t\t\t// TODO: Apply support modifiers based on context\n\t\t\t\t\t// This would modify costs, statistics, etc.\n\t\t\t\t\tconsole.log(`[SupportHandler] Applying support modifier from ${supportObject.name}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn modifiedValue;\n\t}\n\n\t/**\n\t * Checks if support abilities are available for quick actions\n\t * Rule 2.2.11.e: Support abilities work only when ready in Reserve\n\t */\n\tpublic getAvailableSupportQuickActions(playerId: string): IGameObject[] {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) return [];\n\n\t\tconst availableActions: IGameObject[] = [];\n\t\tconst reserveZone = player.zones.reserve;\n\n\t\tfor (const entity of reserveZone.getAll()) {\n\t\t\tif (isGameObject(entity) && !entity.statuses.has(StatusType.Exhausted)) {\n\t\t\t\tconst hasQuickActionSupport = entity.abilities.some(\n\t\t\t\t\t(ability) =>\n\t\t\t\t\t\t(ability.abilityType === AbilityType.Support || ability.isSupportAbility) &&\n\t\t\t\t\t\tability.abilityType === AbilityType.QuickAction\n\t\t\t\t);\n\n\t\t\t\tif (hasQuickActionSupport) {\n\t\t\t\t\tavailableActions.push(entity);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn availableActions;\n\t}\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/TiebreakerSystem.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'IPlayer' is defined but never used.",
				"line": 3,
				"column": 15,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 3,
				"endColumn": 22
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 14,
				"column": 22,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 14,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [552, 555], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [552, 555], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { GameStateManager } from './GameStateManager';\nimport type { IGameObject } from './types/objects';\nimport type { IPlayer, ITerrainStats } from './types/game';\nimport { GamePhase, CardType, StatusType, CounterType } from './types/enums';\nimport { isGameObject } from './types/objects';\n\n/**\n * Handles Arena tiebreaker mechanics\n * Rule 4.3 - Tiebreaker procedure when players are tied for victory\n */\nexport class TiebreakerSystem {\n\tprivate isInTiebreaker: boolean = false;\n\tprivate tiebreakerPlayers: string[] = [];\n\tprivate arenaZone?: any; // Special zone for tiebreaker\n\n\tconstructor(private gsm: GameStateManager) {}\n\n\t/**\n\t * Checks if a tiebreaker should be initiated\n\t * Rule 4.3.a - Tiebreaker occurs when multiple players reach victory threshold\n\t */\n\tpublic checkForTiebreaker(): string | null {\n\t\tconst playerIds = Array.from(this.gsm.state.players.keys());\n\t\tconst playerScores = new Map<string, number>();\n\n\t\t// Calculate total expedition distances\n\t\tfor (const playerId of playerIds) {\n\t\t\tconst player = this.gsm.getPlayer(playerId);\n\t\t\tif (!player) continue;\n\n\t\t\tconst totalDistance = player.heroExpedition.position + player.companionExpedition.position;\n\t\t\tplayerScores.set(playerId, totalDistance);\n\t\t}\n\n\t\tconst maxScore = Math.max(...Array.from(playerScores.values()));\n\n\t\t// Check if victory threshold reached\n\t\tif (maxScore >= 7) {\n\t\t\tconst winners = playerIds.filter((pid) => playerScores.get(pid) === maxScore);\n\n\t\t\tif (winners.length === 1) {\n\t\t\t\treturn winners[0]; // Clear winner\n\t\t\t} else {\n\t\t\t\t// Initiate tiebreaker\n\t\t\t\tthis.initiateTiebreaker(winners);\n\t\t\t\treturn null; // Tiebreaker in progress\n\t\t\t}\n\t\t}\n\n\t\treturn null; // No winner yet\n\t}\n\n\t/**\n\t * Initiates the tiebreaker procedure\n\t * Rule 4.3.b-c - Setup Arena and move all expeditions\n\t */\n\tprivate initiateTiebreaker(tiedPlayers: string[]): void {\n\t\tconsole.log(`[Tiebreaker] Initiating tiebreaker between players: ${tiedPlayers.join(', ')}`);\n\n\t\tthis.isInTiebreaker = true;\n\t\tthis.tiebreakerPlayers = tiedPlayers;\n\n\t\t// Create Arena zone (conceptually - all expeditions in same zone)\n\t\tthis.setupArena();\n\n\t\t// Move all expeditions to Arena\n\t\tthis.moveExpeditionsToArena();\n\n\t\t// Reset expedition positions for Arena combat\n\t\tthis.resetExpeditionPositions();\n\n\t\tconsole.log(`[Tiebreaker] Arena setup complete. Beginning tiebreaker turns.`);\n\t}\n\n\t/**\n\t * Sets up the Arena for tiebreaker combat\n\t * Rule 4.3.b - Arena is a single zone containing all expeditions\n\t */\n\tprivate setupArena(): void {\n\t\t// In the actual implementation, you might create a special zone\n\t\t// For now, we'll track this conceptually\n\t\tconsole.log(`[Tiebreaker] Arena created for ${this.tiebreakerPlayers.length} players`);\n\t}\n\n\t/**\n\t * Moves all expeditions to the Arena\n\t * Rule 4.3.c - All expeditions are placed in the Arena\n\t */\n\tprivate moveExpeditionsToArena(): void {\n\t\tfor (const playerId of this.tiebreakerPlayers) {\n\t\t\tconst player = this.gsm.getPlayer(playerId);\n\t\t\tif (!player) continue;\n\n\t\t\t// Conceptually move expeditions to Arena\n\t\t\t// In practice, expeditions stay in their zones but are considered \"in Arena\"\n\t\t\tconsole.log(`[Tiebreaker] Player ${playerId} expeditions moved to Arena`);\n\t\t}\n\t}\n\n\t/**\n\t * Resets expedition positions for Arena combat\n\t */\n\tprivate resetExpeditionPositions(): void {\n\t\tfor (const playerId of this.tiebreakerPlayers) {\n\t\t\tconst player = this.gsm.getPlayer(playerId);\n\t\t\tif (!player) continue;\n\n\t\t\t// Reset positions to 0 for Arena combat\n\t\t\tplayer.heroExpedition.position = 0;\n\t\t\tplayer.companionExpedition.position = 0;\n\t\t\tplayer.heroExpedition.hasMoved = false;\n\t\t\tplayer.companionExpedition.hasMoved = false;\n\t\t}\n\t}\n\n\t/**\n\t * Processes Progress during tiebreaker\n\t * Rule 4.3.d-e - Modified Progress rules for Arena combat\n\t */\n\tpublic processTiebreakerProgress(): string | null {\n\t\tif (!this.isInTiebreaker) return null;\n\n\t\tconsole.log(`[Tiebreaker] Processing Arena Progress`);\n\n\t\tconst terrainResults = this.calculateArenaTerrainWinners();\n\n\t\t// Check if any player wins by having more terrain types with greater stats\n\t\tconst winner = this.determineArenaWinner(terrainResults);\n\n\t\tif (winner) {\n\t\t\tthis.endTiebreaker(winner);\n\t\t\treturn winner;\n\t\t}\n\n\t\t// Continue tiebreaker if no clear winner\n\t\treturn null;\n\t}\n\n\t/**\n\t * Calculates terrain winners in Arena combat\n\t * Rule 4.3.e - Compare statistics for each terrain type\n\t */\n\tprivate calculateArenaTerrainWinners(): Map<string, string> {\n\t\tconst terrainWinners = new Map<string, string>();\n\t\tconst playerTerrainStats = new Map<string, ITerrainStats>();\n\n\t\t// Calculate total terrain stats for each player\n\t\tfor (const playerId of this.tiebreakerPlayers) {\n\t\t\tconst stats = this.calculatePlayerArenaStats(playerId);\n\t\t\tplayerTerrainStats.set(playerId, stats);\n\t\t}\n\n\t\t// Determine winner for each terrain type\n\t\tfor (const terrain of ['forest', 'mountain', 'water']) {\n\t\t\tlet maxStat = -1;\n\t\t\tlet winner = '';\n\t\t\tlet tied = false;\n\n\t\t\tfor (const playerId of this.tiebreakerPlayers) {\n\t\t\t\tconst stats = playerTerrainStats.get(playerId);\n\t\t\t\tif (!stats) continue;\n\n\t\t\t\tconst terrainValue = Math.max(0, stats[terrain as keyof ITerrainStats]);\n\n\t\t\t\tif (terrainValue > maxStat) {\n\t\t\t\t\tmaxStat = terrainValue;\n\t\t\t\t\twinner = playerId;\n\t\t\t\t\ttied = false;\n\t\t\t\t} else if (terrainValue === maxStat && maxStat > 0) {\n\t\t\t\t\ttied = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!tied && winner && maxStat > 0) {\n\t\t\t\tterrainWinners.set(terrain, winner);\n\t\t\t\tconsole.log(`[Tiebreaker] ${winner} wins ${terrain} terrain with ${maxStat}`);\n\t\t\t}\n\t\t}\n\n\t\treturn terrainWinners;\n\t}\n\n\t/**\n\t * Calculates total Arena stats for a player\n\t */\n\tprivate calculatePlayerArenaStats(playerId: string): ITerrainStats {\n\t\tconst player = this.gsm.getPlayer(playerId);\n\t\tif (!player) return { forest: 0, mountain: 0, water: 0 };\n\n\t\tconst stats: ITerrainStats = { forest: 0, mountain: 0, water: 0 };\n\n\t\t// Include stats from all Characters in expeditions\n\t\tfor (const entity of player.zones.expeditionZone.getAll()) {\n\t\t\tif (isGameObject(entity) && entity.type === CardType.Character) {\n\t\t\t\t// Skip Asleep characters (Rule 2.4.3)\n\t\t\t\tif (entity.statuses.has(StatusType.Asleep)) continue;\n\n\t\t\t\tconst entityStats = entity.currentCharacteristics.statistics;\n\t\t\t\tif (entityStats) {\n\t\t\t\t\tstats.forest += entityStats.forest || 0;\n\t\t\t\t\tstats.mountain += entityStats.mountain || 0;\n\t\t\t\t\tstats.water += entityStats.water || 0;\n\t\t\t\t}\n\n\t\t\t\t// Add boost counters\n\t\t\t\tconst boostCount = entity.counters.get(CounterType.Boost) || 0;\n\t\t\t\tstats.forest += boostCount;\n\t\t\t\tstats.mountain += boostCount;\n\t\t\t\tstats.water += boostCount;\n\t\t\t}\n\t\t}\n\n\t\treturn stats;\n\t}\n\n\t/**\n\t * Determines Arena winner based on terrain victories\n\t * Rule 4.3.e - Player with more terrain victories wins\n\t */\n\tprivate determineArenaWinner(terrainWinners: Map<string, string>): string | null {\n\t\tconst playerWins = new Map<string, number>();\n\n\t\t// Count terrain victories for each player\n\t\tfor (const playerId of this.tiebreakerPlayers) {\n\t\t\tplayerWins.set(playerId, 0);\n\t\t}\n\n\t\tfor (const winner of terrainWinners.values()) {\n\t\t\tconst currentWins = playerWins.get(winner) || 0;\n\t\t\tplayerWins.set(winner, currentWins + 1);\n\t\t}\n\n\t\t// Find player with most terrain victories\n\t\tlet maxWins = 0;\n\t\tlet winner = null;\n\t\tlet tied = false;\n\n\t\tfor (const [playerId, wins] of playerWins.entries()) {\n\t\t\tif (wins > maxWins) {\n\t\t\t\tmaxWins = wins;\n\t\t\t\twinner = playerId;\n\t\t\t\ttied = false;\n\t\t\t} else if (wins === maxWins && wins > 0) {\n\t\t\t\ttied = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!tied && winner && maxWins > 0) {\n\t\t\tconsole.log(`[Tiebreaker] ${winner} wins Arena with ${maxWins} terrain victories`);\n\t\t\treturn winner;\n\t\t}\n\n\t\tconsole.log(`[Tiebreaker] No clear Arena winner, continuing tiebreaker`);\n\t\treturn null;\n\t}\n\n\t/**\n\t * Ends the tiebreaker and declares winner\n\t */\n\tprivate endTiebreaker(winner: string): void {\n\t\tconsole.log(`[Tiebreaker] Tiebreaker ended. Winner: ${winner}`);\n\n\t\tthis.isInTiebreaker = false;\n\t\tthis.tiebreakerPlayers = [];\n\n\t\t// Restore normal game state\n\t\tthis.restoreFromArena();\n\n\t\t// Publish game end event\n\t\t// this.gsm.eventBus.publish('gameEnded', { winner, reason: 'tiebreaker' });\n\t\tconsole.log(`[Tiebreaker] Game ended via tiebreaker - Winner: ${winner}`);\n\t}\n\n\t/**\n\t * Restores game state from Arena\n\t */\n\tprivate restoreFromArena(): void {\n\t\t// Clean up Arena state\n\t\t// Move expeditions back to normal zones (conceptually)\n\t\tconsole.log(`[Tiebreaker] Restored game state from Arena`);\n\t}\n\n\t/**\n\t * Checks if currently in tiebreaker mode\n\t */\n\tpublic isInTiebreakerMode(): boolean {\n\t\treturn this.isInTiebreaker;\n\t}\n\n\t/**\n\t * Gets current tiebreaker players\n\t */\n\tpublic getTiebreakerPlayers(): string[] {\n\t\treturn [...this.tiebreakerPlayers];\n\t}\n\n\t/**\n\t * Processes tiebreaker-specific phase effects\n\t */\n\tpublic processTiebreakerPhase(phase: GamePhase): void {\n\t\tif (!this.isInTiebreaker) return;\n\n\t\tswitch (phase) {\n\t\t\tcase GamePhase.Dusk:\n\t\t\t\t// Process Arena Progress instead of normal Progress\n\t\t\t\tthis.processTiebreakerProgress();\n\t\t\t\tbreak;\n\t\t\tcase GamePhase.Night:\n\t\t\t\t// Modified Rest rules for Arena\n\t\t\t\tthis.processTiebreakerRest();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Processes Rest phase during tiebreaker\n\t * Rule 4.3.f - Modified Rest rules for Arena\n\t */\n\tprivate processTiebreakerRest(): void {\n\t\tconsole.log(`[Tiebreaker] Processing Arena Rest`);\n\n\t\t// Characters in Arena follow normal Rest rules\n\t\t// but positions don't change since all are in Arena\n\t\tfor (const playerId of this.tiebreakerPlayers) {\n\t\t\tconst player = this.gsm.getPlayer(playerId);\n\t\t\tif (!player) continue;\n\n\t\t\t// Process character status effects but don't move to Reserve\n\t\t\t// since Arena combat continues\n\t\t\tconst expeditionChars = player.zones.expeditionZone\n\t\t\t\t.getAll()\n\t\t\t\t.filter((e) => isGameObject(e) && e.type === CardType.Character) as IGameObject[];\n\n\t\t\tfor (const char of expeditionChars) {\n\t\t\t\t// Remove temporary statuses\n\t\t\t\tif (char.statuses.has(StatusType.Anchored)) {\n\t\t\t\t\tchar.statuses.delete(StatusType.Anchored);\n\t\t\t\t}\n\t\t\t\tif (char.statuses.has(StatusType.Asleep)) {\n\t\t\t\t\tchar.statuses.delete(StatusType.Asleep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/TurnManager.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/Zone.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/types/abilities.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 11,
				"column": 40,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 11,
				"endColumn": 43,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [337, 340], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [337, 340], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 13,
				"column": 42,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 13,
				"endColumn": 45,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [444, 447], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [444, 447], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 23,
				"column": 63,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 23,
				"endColumn": 66,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [764, 767], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [764, 767], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 24,
				"column": 15,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 24,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [805, 808], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [805, 808], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 35,
				"column": 20,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 35,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [1149, 1152], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [1149, 1152], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 46,
				"column": 23,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 46,
				"endColumn": 26,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [1473, 1476], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [1473, 1476], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 6,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { CounterType, KeywordAbility } from './enums';\nimport type { IGameObject } from './objects';\nimport type { GameStateManager } from '../GameStateManager';\n\n/**\n * Represents the cost to play a card or activate an ability.\n * Rule 1.2.5, 6.4\n */\nexport interface ICost {\n\tmana?: number;\n\tdiscard?: { count: number; criteria?: any }; // criteria can be further defined\n\texhaustSelf?: boolean;\n\tsacrifice?: { count: number; criteria?: any };\n\tspendCounters?: { type: CounterType; amount: number };\n}\n\n/**\n * Represents a single step within an effect's resolution.\n * Rule 1.2.6, 6.5\n */\nexport interface IEffectStep {\n\tverb: string; // e.g., 'draw', 'createToken', 'gainStatus', 'gainCounter'\n\ttargets: 'self' | 'controller' | { type: 'select'; criteria: any }; // Target selection\n\tparameters?: any; // Verb-specific data, like a status type or counter info\n\tisOptional?: boolean; // For \"may\" effects (Rule 1.2.6.d, 6.5.c)\n}\n\n/**\n * Represents the full effect of an ability or spell.\n * Rule 1.2.6\n */\nexport interface IEffect {\n\tsteps: IEffectStep[];\n\tsourceObjectId?: string; // The object that generated this effect\n\t_triggerPayload?: any;\n}\n\n/**\n * Defines the trigger condition for a Reaction ability.\n * Rule 6.3\n */\nexport interface ITrigger {\n\teventType: string; // e.g., 'entityMoved', corresponds to an EventBus event type\n\t// A function to check if the specific event payload meets the trigger's conditions\n\t// Rule 6.3.b, 6.3.k\n\tcondition: (payload: any, sourceObject: IGameObject, gsm: GameStateManager) => boolean;\n}\n\nexport enum AbilityType {\n\tQuickAction = 'quick_action',\n\tReaction = 'reaction',\n\tPassive = 'passive',\n\tSupport = 'support', // Rule 2.2.11.e - Support abilities work only in Reserve\n\tEffectSource = 'effect_source' // For simple effects from spells etc.\n}\n\n/**\n * Represents a single ability on a card or object.\n * Rule 1.2.4, 2.2.11\n */\nexport interface IAbility {\n\tsourceObjectId?: string;\n\tabilityId: string;\n\tabilityType: AbilityType;\n\tcost?: ICost;\n\ttrigger?: ITrigger;\n\tisSelfMove?: boolean; // You have this, good!\n\teffect: IEffect;\n\ttext: string;\n\tisSupportAbility: boolean;\n\tisKeyword?: boolean;\n\tkeyword?: KeywordAbility;\n\tkeywordValue?: number; // For keywords like Scout X and Tough X\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/types/cards.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/types/enums.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Axiom.",
				"line": 9,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 9,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Bravos.",
				"line": 10,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 10,
				"endColumn": 15
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Lyra.",
				"line": 11,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 11,
				"endColumn": 13
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Muna.",
				"line": 12,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 12,
				"endColumn": 13
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Neutre.",
				"line": 13,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 13,
				"endColumn": 15
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Ordis.",
				"line": 14,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 14,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Yzmir.",
				"line": 15,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 15,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Personnage.",
				"line": 30,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 30,
				"endColumn": 26
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Hros.",
				"line": 31,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 31,
				"endColumn": 16
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Sort.",
				"line": 32,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 32,
				"endColumn": 16
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Permanent.",
				"line": 33,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 33,
				"endColumn": 25
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Emblem.",
				"line": 34,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 34,
				"endColumn": 19
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Repre Permanent.",
				"line": 35,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 35,
				"endColumn": 41
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Permanent dExpdition.",
				"line": 36,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 36,
				"endColumn": 49
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Jeton Personnage.",
				"line": 37,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 37,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Commun.",
				"line": 53,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 53,
				"endColumn": 19
			},
			{
				"ruleId": "@typescript-eslint/no-duplicate-enum-values",
				"severity": 2,
				"message": "Duplicate enum member value Rare.",
				"line": 54,
				"column": 2,
				"nodeType": "TSEnumMember",
				"messageId": "duplicateValue",
				"endLine": 54,
				"endColumn": 15
			}
		],
		"suppressedMessages": [],
		"errorCount": 17,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "export enum Faction {\n\tAxiom = 'Axiom',\n\tBravos = 'Bravos',\n\tLyra = 'Lyra',\n\tMuna = 'Muna',\n\tOrdis = 'Ordis',\n\tYzmir = 'Yzmir',\n\tNeutre = 'Neutre', // Added for Neutral cards\n\tAX = 'Axiom', // Alias for mapping\n\tBR = 'Bravos', // Alias for mapping\n\tLY = 'Lyra', // Alias for mapping\n\tMU = 'Muna', // Alias for mapping\n\tNE = 'Neutre', // Alias for mapping\n\tOR = 'Ordis', // Alias for mapping\n\tYZ = 'Yzmir' // Alias for mapping\n}\n\nexport enum CardType {\n\tCharacter = 'Personnage',\n\tEmblem = 'Emblem', // Added\n\tHero = 'Hros',\n\tManaOrb = 'ManaOrb',\n\tPermanent = 'Permanent',\n\tRegion = 'Region',\n\tSpell = 'Sort',\n\tLandmarkPermanent = 'Repre Permanent',\n\tExpeditionPermanent = 'Permanent dExpdition',\n\tToken = 'Jeton Personnage',\n\t// Aliases for mapping\n\tCHARACTER = 'Personnage',\n\tHERO = 'Hros',\n\tSPELL = 'Sort',\n\tPERMANENT = 'Permanent',\n\tEMBLEM = 'Emblem', // Added\n\tLANDMARK_PERMANENT = 'Repre Permanent',\n\tEXPEDITION_PERMANENT = 'Permanent dExpdition',\n\tTOKEN = 'Jeton Personnage',\n\tTOKEN_MANA = 'Mana',\n\tFOILER = 'Foiler'\n}\n\nexport enum PermanentZoneType {\n\tExpedition = 'Expedition',\n\tLandmark = 'Landmark'\n}\n\nexport enum Rarity {\n\tCommon = 'Commun', // Match names from raritiesLookup\n\tRare = 'Rare',\n\tUnique = 'Unique',\n\tToken = 'Token',\n\t// Aliases for mapping\n\tCOMMON = 'Commun',\n\tRARE = 'Rare'\n}\n\nexport enum GamePhase {\n\tSetup = 'Setup',\n\tMorning = 'Morning',\n\tNoon = 'Noon',\n\tAfternoon = 'Afternoon',\n\tDusk = 'Dusk',\n\tNight = 'Night',\n\tTiebreaker = 'Tiebreaker'\n}\n\nexport enum StatusType {\n\tAnchored = 'Anchored', // Rule 2.4.2\n\tAsleep = 'Asleep', // Rule 2.4.3\n\tBoosted = 'Boosted', // Rule 2.4.4\n\tExhausted = 'Exhausted', // Rule 2.4.5\n\tFleeting = 'Fleeting' // Rule 2.4.6\n\t// FIX: Eternal is a keyword ability (Rule 7.4.3), not a status. It has been removed.\n}\n\nexport enum CounterType {\n\tBoost = 'Boost',\n\t// Example of specific named counters\n\tKelon = 'KelonCounter'\n}\n\nexport enum TerrainType {\n\tForest = 'forest',\n\tMountain = 'mountain',\n\tWater = 'water'\n}\n\nexport enum KeywordAbility {\n\tCooldown = 'Cooldown',\n\tDefender = 'Defender',\n\tEternal = 'Eternal',\n\tGigantic = 'Gigantic',\n\tScout = 'Scout',\n\tSeasoned = 'Seasoned',\n\tTough = 'Tough'\n}\n\n/**\n * Identifies the specific type of a zone.\n * Rule 1.2.3, 3.1\n */\nexport enum ZoneIdentifier {\n\t// Shared Zones (Rule 3.1.1, 3.2)\n\tAdventure = 'Adventure',\n\tExpedition = 'Expedition',\n\tLimbo = 'Limbo',\n\n\t// Player-specific Zones (Rule 3.1.2, 3.2)\n\tDeck = 'Deck',\n\tHand = 'Hand',\n\tDiscardPile = 'DiscardPile',\n\tMana = 'Mana',\n\tReserve = 'Reserve',\n\tLandmark = 'Landmark',\n\tHero = 'Hero'\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/types/game.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 87,
				"column": 17,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 87,
				"endColumn": 20,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [2160, 2163], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [2160, 2163], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { IHeroObject } from './objects';\nimport type { IZone } from './zones';\nimport { GamePhase } from './enums';\n\n/**\n * Terrain statistics for characters/objects\n * Rule 2.2.10, 7.1.2\n */\nexport interface ITerrainStats {\n\tforest: number;\n\tmountain: number;\n\twater: number;\n}\n\n/**\n * Expedition state tracking\n * Rule 7.5.2\n */\nexport interface IExpeditionState {\n\tposition: number; // Distance from starting region\n\tcanMove: boolean; // Affected by Defender keyword\n\thasMoved: boolean; // Tracks if moved this turn\n}\n\n/**\n * Extended expedition state for full game tracking\n */\nexport interface IExtendedExpeditionState {\n\theroPosition: number;\n\tcompanionPosition: number;\n\theroActive: boolean;\n\tcompanionActive: boolean;\n\theroMovedThisTurn: boolean;\n\tcompanionMovedThisTurn: boolean;\n\theroStats: ITerrainStats;\n\tcompanionStats: ITerrainStats;\n}\n\n/**\n * Represents a single player in the game.\n * Rule 1.2.1\n */\nexport interface IPlayer {\n\tid: string;\n\thero?: IHeroObject;\n\tzones: {\n\t\tdeckZone: IZone;\n\t\thandZone: IZone;\n\t\tdiscardPileZone: IZone;\n\t\tmanaZone: IZone;\n\t\treserveZone: IZone;\n\t\tlandmarkZone: IZone;\n\t\theroZone: IZone;\n\t\texpeditionZone: IZone;\n\t\tlimboZone: IZone; // Shared reference to game's limbo zone for convenience\n\t\thand: IZone; // Alias for handZone for test compatibility\n\t\treserve: IZone; // Alias for reserveZone for test compatibility\n\t\texpedition: IZone; // Alias for expeditionZone for test compatibility\n\t};\n\theroExpedition: IExpeditionState;\n\tcompanionExpedition: IExpeditionState;\n\texpeditionState?: IExtendedExpeditionState;\n\thasPassedTurn: boolean;\n\thasExpandedThisTurn: boolean;\n}\n\n/**\n * Encapsulates the entire state of the game at any point in time.\n */\nexport interface IGameState {\n\tplayers: Map<string, IPlayer>;\n\tsharedZones: {\n\t\tadventure: IZone;\n\t\texpedition: IZone;\n\t\tlimbo: IZone;\n\t};\n\tcurrentPhase: GamePhase;\n\tcurrentPlayerId: string;\n\tfirstPlayerId: string; // The player who is first for the current Day\n\tcurrentDay: number;\n\tdayNumber: number;\n\tfirstMorningSkipped: boolean;\n\tgameEnded: boolean;\n\twinner?: string;\n\ttiebreakerMode: boolean;\n\tplayerExpandChoices?: Record<string, boolean>;\n\tactionHistory: any[]; // Log actions and events for debugging\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/types/objects.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/engine/types/zones.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/lib/deckValidation.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'AlteredCard' is defined but never used.",
				"line": 1,
				"column": 15,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 1,
				"endColumn": 26
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'allCards' is defined but never used.",
				"line": 2,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 2,
				"endColumn": 18
			}
		],
		"suppressedMessages": [],
		"errorCount": 2,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { AlteredCard } from '$types';\nimport { allCards, getCardById } from '$data/cards';\n\nexport interface DeckValidationResult {\n\tisValid: boolean;\n\terrors: string[];\n\twarnings: string[];\n\tstats: DeckStats;\n}\n\nexport interface DeckStats {\n\ttotalCards: number;\n\theroCount: number;\n\tfactionBreakdown: { [faction: string]: number };\n\trarityBreakdown: { [rarity: string]: number };\n\tcopyViolations: Array<{ cardName: string; count: number }>;\n}\n\nexport interface DeckCard {\n\tcardId: string;\n\tquantity: number;\n}\n\nexport type DeckFormat = 'constructed' | 'limited';\n\nexport class DeckValidator {\n\tprivate format: DeckFormat;\n\n\tconstructor(format: DeckFormat = 'constructed') {\n\t\tthis.format = format;\n\t}\n\n\tvalidate(cards: DeckCard[], heroId?: string): DeckValidationResult {\n\t\tconst errors: string[] = [];\n\t\tconst warnings: string[] = [];\n\t\tconst stats = this.calculateStats(cards, heroId);\n\n\t\t// Validate based on format\n\t\tif (this.format === 'constructed') {\n\t\t\tthis.validateConstructed(cards, heroId, stats, errors, warnings);\n\t\t} else {\n\t\t\tthis.validateLimited(cards, heroId, stats, errors, warnings);\n\t\t}\n\n\t\treturn {\n\t\t\tisValid: errors.length === 0,\n\t\t\terrors,\n\t\t\twarnings,\n\t\t\tstats\n\t\t};\n\t}\n\n\tprivate validateConstructed(\n\t\tcards: DeckCard[],\n\t\theroId: string | undefined,\n\t\tstats: DeckStats,\n\t\terrors: string[],\n\t\twarnings: string[]\n\t): void {\n\t\t// Rule 1.1.4.b - Hero Requirement\n\t\tif (!heroId) {\n\t\t\terrors.push('A constructed deck must include exactly 1 Hero');\n\t\t} else if (stats.heroCount !== 1) {\n\t\t\terrors.push('A constructed deck must include exactly 1 Hero');\n\t\t}\n\n\t\t// Rule 1.1.4.c - Minimum Deck Size (39 other cards + 1 hero = 40 total)\n\t\tconst nonHeroCards = stats.totalCards - stats.heroCount;\n\t\tif (nonHeroCards < 39) {\n\t\t\terrors.push(\n\t\t\t\t`A constructed deck must include at least 39 non-Hero cards (currently ${nonHeroCards})`\n\t\t\t);\n\t\t}\n\n\t\t// Rule 1.1.4.d - Faction Restrictions\n\t\tif (heroId) {\n\t\t\tconst hero = getCardById(heroId);\n\t\t\tif (hero && hero.faction) {\n\t\t\t\tconst otherFactions = Object.keys(stats.factionBreakdown).filter(\n\t\t\t\t\t(faction) => faction !== hero.faction && stats.factionBreakdown[faction] > 0\n\t\t\t\t);\n\t\t\t\tif (otherFactions.length > 0) {\n\t\t\t\t\terrors.push(\n\t\t\t\t\t\t`All cards must be the same faction as the Hero (${hero.faction}). Found cards from: ${otherFactions.join(', ')}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Rule 1.1.4.e - Copy Restrictions (max 3 cards with same name)\n\t\tstats.copyViolations.forEach((violation) => {\n\t\t\terrors.push(\n\t\t\t\t`Maximum 3 copies of \"${violation.cardName}\" allowed (currently ${violation.count})`\n\t\t\t);\n\t\t});\n\n\t\t// Rule 1.1.4.f - Rare Card Restrictions (max 15 rare cards)\n\t\tconst rareCount = stats.rarityBreakdown['Rare'] || 0;\n\t\tif (rareCount > 15) {\n\t\t\terrors.push(`Maximum 15 rare cards allowed (currently ${rareCount})`);\n\t\t}\n\n\t\t// Rule 1.1.4.g - Unique Card Restrictions (max 3 unique cards)\n\t\tconst uniqueCount = stats.rarityBreakdown['UNIQUE'] || 0;\n\t\tif (uniqueCount > 3) {\n\t\t\terrors.push(`Maximum 3 unique cards allowed (currently ${uniqueCount})`);\n\t\t}\n\n\t\t// Performance warnings\n\t\tif (stats.totalCards > 60) {\n\t\t\twarnings.push('Large deck size may affect consistency');\n\t\t}\n\t}\n\n\tprivate validateLimited(\n\t\tcards: DeckCard[],\n\t\theroId: string | undefined,\n\t\tstats: DeckStats,\n\t\terrors: string[],\n\t\twarnings: string[]\n\t): void {\n\t\t// Rule 1.1.5.b - Hero Requirement (max 1 Hero)\n\t\tif (stats.heroCount > 1) {\n\t\t\terrors.push('A limited deck can include at most 1 Hero');\n\t\t}\n\n\t\t// Rule 1.1.5.c - Minimum Deck Size (29 non-Hero cards)\n\t\tconst nonHeroCards = stats.totalCards - stats.heroCount;\n\t\tif (nonHeroCards < 29) {\n\t\t\terrors.push(\n\t\t\t\t`A limited deck must include at least 29 non-Hero cards (currently ${nonHeroCards})`\n\t\t\t);\n\t\t}\n\n\t\t// Rule 1.1.5.d - Faction Restrictions (max 3 factions, Hero counts as one)\n\t\tconst factionCount = Object.keys(stats.factionBreakdown).filter(\n\t\t\t(faction) => stats.factionBreakdown[faction] > 0\n\t\t).length;\n\n\t\tif (factionCount > 3) {\n\t\t\tconst factions = Object.keys(stats.factionBreakdown).filter(\n\t\t\t\t(faction) => stats.factionBreakdown[faction] > 0\n\t\t\t);\n\t\t\terrors.push(\n\t\t\t\t`Maximum 3 factions allowed in limited format (currently ${factionCount}: ${factions.join(', ')})`\n\t\t\t);\n\t\t}\n\n\t\t// No copy or rarity restrictions in limited format, but warn about multiple copies\n\t\t// Check for multiple copies (in limited format, check manually since copyViolations only tracks constructed violations)\n\t\tconst cardNameCounts: { [name: string]: number } = {};\n\t\tcards.forEach((deckCard) => {\n\t\t\tconst card = getCardById(deckCard.cardId);\n\t\t\tif (card) {\n\t\t\t\tcardNameCounts[card.name] = (cardNameCounts[card.name] || 0) + deckCard.quantity;\n\t\t\t}\n\t\t});\n\n\t\tconst hasMultipleCopies = Object.values(cardNameCounts).some((count) => count > 3);\n\t\tif (hasMultipleCopies) {\n\t\t\twarnings.push('Multiple copies of the same card - consider deck diversity');\n\t\t}\n\t}\n\n\tprivate calculateStats(cards: DeckCard[], heroId?: string): DeckStats {\n\t\tconst stats: DeckStats = {\n\t\t\ttotalCards: 0,\n\t\t\theroCount: 0,\n\t\t\tfactionBreakdown: {},\n\t\t\trarityBreakdown: {},\n\t\t\tcopyViolations: []\n\t\t};\n\n\t\t// Count Hero\n\t\tif (heroId) {\n\t\t\tconst hero = getCardById(heroId);\n\t\t\tif (hero) {\n\t\t\t\tstats.heroCount = 1;\n\t\t\t\tstats.totalCards = 1;\n\t\t\t\tif (hero.faction) {\n\t\t\t\t\tstats.factionBreakdown[hero.faction] = (stats.factionBreakdown[hero.faction] || 0) + 1;\n\t\t\t\t}\n\t\t\t\t// if (hero.rarity) {\n\t\t\t\t// \tstats.rarityBreakdown[hero.rarity] = (stats.rarityBreakdown[hero.rarity] || 0) + 1;\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\n\t\t// Track card names for copy violations\n\t\tconst cardNameCounts: { [name: string]: number } = {};\n\n\t\t// Count main deck cards\n\t\tcards.forEach((deckCard) => {\n\t\t\tconst card = getCardById(deckCard.cardId);\n\t\t\tif (!card) return;\n\n\t\t\tconst quantity = deckCard.quantity;\n\t\t\tstats.totalCards += quantity;\n\n\t\t\t// Count by faction\n\t\t\tif (card.faction) {\n\t\t\t\tstats.factionBreakdown[card.faction] =\n\t\t\t\t\t(stats.factionBreakdown[card.faction] || 0) + quantity;\n\t\t\t}\n\n\t\t\t// Count by rarity\n\t\t\tif (card.rarity) {\n\t\t\t\tstats.rarityBreakdown[card.rarity] = (stats.rarityBreakdown[card.rarity] || 0) + quantity;\n\t\t\t}\n\n\t\t\t// Track card name counts for copy restrictions\n\t\t\tcardNameCounts[card.name] = (cardNameCounts[card.name] || 0) + quantity;\n\t\t});\n\n\t\t// Check for copy violations (only in constructed format)\n\t\tif (this.format === 'constructed') {\n\t\t\tObject.entries(cardNameCounts).forEach(([cardName, count]) => {\n\t\t\t\tif (count > 3) {\n\t\t\t\t\tstats.copyViolations.push({ cardName, count });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn stats;\n\t}\n\n\tsetFormat(format: DeckFormat): void {\n\t\tthis.format = format;\n\t}\n\n\tgetFormat(): DeckFormat {\n\t\treturn this.format;\n\t}\n\n\t// Helper method to check if a card can be added to the deck\n\tcanAddCard(\n\t\tcards: DeckCard[],\n\t\tcardId: string,\n\t\theroId?: string\n\t): { canAdd: boolean; reason?: string } {\n\t\tconst card = getCardById(cardId);\n\t\tif (!card) {\n\t\t\treturn { canAdd: false, reason: 'Card not found' };\n\t\t}\n\n\t\t// Check faction restrictions for constructed\n\t\tif (this.format === 'constructed' && heroId) {\n\t\t\tconst hero = getCardById(heroId);\n\t\t\tif (hero && hero.faction && card.faction && card.faction !== hero.faction) {\n\t\t\t\treturn {\n\t\t\t\t\tcanAdd: false,\n\t\t\t\t\treason: `Card faction (${card.faction}) must match Hero faction (${hero.faction})`\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Check if adding this card would violate copy restrictions (same name)\n\t\tif (this.format === 'constructed') {\n\t\t\t// Count all cards with the same name as the card we're trying to add\n\t\t\tlet sameNameCount = 0;\n\t\t\tcards.forEach((deckCard) => {\n\t\t\t\tconst existingCard = getCardById(deckCard.cardId);\n\t\t\t\tif (existingCard && existingCard.name === card.name) {\n\t\t\t\t\tsameNameCount += deckCard.quantity;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (sameNameCount >= 3) {\n\t\t\t\treturn { canAdd: false, reason: `Maximum 3 copies of \"${card.name}\" allowed` };\n\t\t\t}\n\t\t}\n\n\t\t// Check rarity restrictions for constructed\n\t\tif (this.format === 'constructed') {\n\t\t\tconst existingCard = cards.find((c) => c.cardId === cardId);\n\t\t\tconst tempCards = existingCard\n\t\t\t\t? cards.map((c) => (c.cardId === cardId ? { ...c, quantity: c.quantity + 1 } : c))\n\t\t\t\t: [...cards, { cardId, quantity: 1 }];\n\n\t\t\tconst tempStats = this.calculateStats(tempCards, heroId);\n\n\t\t\tif (card.rarity === 'Rare' && tempStats.rarityBreakdown['Rare'] > 15) {\n\t\t\t\treturn { canAdd: false, reason: 'Maximum 15 rare cards allowed' };\n\t\t\t}\n\n\t\t\t// Assuming card.rarity will be \"UNIQUE\" for unique cards if not found in lookup\n\t\t\tif (card.rarity === 'UNIQUE' && (tempStats.rarityBreakdown['UNIQUE'] || 0) > 3) {\n\t\t\t\treturn { canAdd: false, reason: 'Maximum 3 unique cards allowed' };\n\t\t\t}\n\t\t}\n\n\t\treturn { canAdd: true };\n\t}\n}\n\n// Export a default validator instance\nexport const deckValidator = new DeckValidator();\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/lib/rxdb.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/lib/state/deckMachine.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'sendParent' is defined but never used.",
				"line": 1,
				"column": 25,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 1,
				"endColumn": 35
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'AlteredCard' is defined but never used.",
				"line": 3,
				"column": 15,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 3,
				"endColumn": 26
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'MyDatabase' is defined but never used.",
				"line": 4,
				"column": 26,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 4,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'context' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 147,
				"column": 25,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 147,
				"endColumn": 32
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 518,
				"column": 44,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 518,
				"endColumn": 64
			}
		],
		"suppressedMessages": [],
		"errorCount": 4,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { setup, assign, sendParent, assertEvent } from 'xstate';\nimport { deckValidator, type DeckValidationResult, type DeckFormat } from '$lib/deckValidation';\nimport type { AlteredCard } from '$types';\nimport { dbPromise, type MyDatabase } from '$lib/rxdb'; // Import RxDB\n\n// RxDB Deck type (dates as strings)\nexport interface DeckDoc {\n\tid: string;\n\tname: string;\n\tdescription: string;\n\tcards: DeckCard[];\n\theroId: string | null;\n\tformat: DeckFormat;\n\tisValid: boolean;\n\tcreatedAt: string; // ISO string\n\tupdatedAt: string; // ISO string\n}\n\ninterface DeckContext {\n\tdecks: Deck[]; // This will store Deck with Date objects\n\tcurrentDeck: Deck | null;\n\tselectedCards: string[];\n\tsearchQuery: string;\n\tfilters: DeckFilters;\n\tvalidationResult: DeckValidationResult | null;\n\tisLoading: boolean;\n\terror: string | null;\n}\n\n// This is the Deck type used in the machine's context (dates as Date objects)\nexport interface Deck {\n\tid: string;\n\tname: string;\n\tdescription: string;\n\tcards: DeckCard[];\n\theroId: string | null;\n\tformat: DeckFormat;\n\tisValid: boolean;\n\tcreatedAt: Date; // Date object\n\tupdatedAt: Date; // Date object\n}\n\ninterface DeckCard {\n\tcardId: string;\n\tquantity: number;\n}\n\ninterface DeckFilters {\n\tfaction?: string;\n\ttype?: string;\n\trarity?: string;\n\tcost?: number;\n}\n\ntype DeckEvents =\n\t| { type: 'LOAD_DECKS' }\n\t| { type: 'CREATE_DECK'; name: string; description?: string; format?: DeckFormat }\n\t| { type: 'EDIT_DECK'; deckId: string }\n\t| { type: 'DELETE_DECK'; deckId: string }\n\t| { type: 'ADD_CARD'; cardId: string; quantity?: number }\n\t| { type: 'REMOVE_CARD'; cardId: string }\n\t| { type: 'UPDATE_CARD_QUANTITY'; cardId: string; quantity: number }\n\t| { type: 'SET_HERO'; cardId: string }\n\t| { type: 'SET_FORMAT'; format: DeckFormat }\n\t| { type: 'VALIDATE_DECK' }\n\t| { type: 'SAVE_DECK' }\n\t| { type: 'SEARCH_CARDS'; query: string }\n\t| { type: 'APPLY_FILTERS'; filters: DeckFilters }\n\t| { type: 'CLEAR_FILTERS' }\n\t| { type: 'DECKS_LOADED'; decks: Deck[] } // from loadDecksFromDb\n\t| { type: 'DECK_LOAD_FAILED'; error: unknown }\n\t| { type: 'DECK_SAVED'; deck: Deck } // from saveDeckToDb\n\t| { type: 'DECK_SAVE_FAILED'; error: unknown }\n\t| { type: 'DECK_DELETED'; deckId: string } // from deleteDeckFromDb\n\t| { type: 'DECK_DELETE_FAILED'; error: unknown }\n\t| { type: 'ERROR'; message: string } // General error\n\t| { type: 'CLEAR_ERROR' };\n\n// Helper to convert DB doc to Machine's Deck type\nfunction fromDocToDeck(doc: DeckDoc): Deck {\n\treturn {\n\t\t...doc,\n\t\tcreatedAt: new Date(doc.createdAt),\n\t\tupdatedAt: new Date(doc.updatedAt)\n\t};\n}\n\n// Helper to convert Machine's Deck type to DB doc\nfunction fromDeckToDoc(deck: Deck): DeckDoc {\n\treturn {\n\t\t...deck,\n\t\tcreatedAt: deck.createdAt.toISOString(),\n\t\tupdatedAt: deck.updatedAt.toISOString()\n\t};\n}\n\nexport const deckMachine = setup({\n\ttypes: {\n\t\tcontext: {} as DeckContext,\n\t\tevents: {} as DeckEvents,\n\t\tactors: {} as {\n\t\t\tloadDecksFromDb: { data: Deck[] };\n\t\t\tsaveDeckToDb: { data: Deck; input: { deckToSave: Deck } };\n\t\t\tdeleteDeckFromDb: { data: { id: string }; input: { deckId: string } };\n\t\t}\n\t},\n\tactors: {\n\t\tloadDecksFromDb: async () => {\n\t\t\tconst db = await dbPromise;\n\t\t\tconst deckDocs = await db.decks.find().exec();\n\t\t\treturn deckDocs.map((doc) => fromDocToDeck(doc.toJSON()));\n\t\t},\n\t\tsaveDeckToDb: async ({ input }: { input: { deckToSave: Deck } }) => {\n\t\t\tconst db = await dbPromise;\n\t\t\tif (!input.deckToSave) throw new Error('No deck to save');\n\t\t\tconst deckDoc = fromDeckToDoc(input.deckToSave);\n\t\t\tawait db.decks.upsert(deckDoc);\n\t\t\treturn input.deckToSave; // Return the original deck with Date objects\n\t\t},\n\t\tdeleteDeckFromDb: async ({ input }: { input: { deckId: string } }) => {\n\t\t\tconst db = await dbPromise;\n\t\t\tconst doc = await db.decks.findOne(input.deckId).exec();\n\t\t\tif (doc) {\n\t\t\t\tawait doc.remove();\n\t\t\t\treturn { id: input.deckId };\n\t\t\t}\n\t\t\tthrow new Error('Deck not found for deletion');\n\t\t}\n\t},\n\tactions: {\n\t\t// loadDecks action is removed, handled by invoke\n\t\tassignDecksToContext: assign(({ event }) => {\n\t\t\tassertEvent(event, 'DECKS_LOADED');\n\t\t\treturn {\n\t\t\t\tdecks: event.decks,\n\t\t\t\tisLoading: false,\n\t\t\t\terror: null\n\t\t\t};\n\t\t}),\n\t\tassignLoadErrorToContext: assign(({ event }) => {\n\t\t\tassertEvent(event, 'DECK_LOAD_FAILED');\n\t\t\treturn {\n\t\t\t\tisLoading: false,\n\t\t\t\terror: event.error instanceof Error ? event.error.message : 'Failed to load decks'\n\t\t\t};\n\t\t}),\n\t\tcreateDeck: assign(({ context, event }) => {\n\t\t\tassertEvent(event, 'CREATE_DECK');\n\n\t\t\tconst format = event.format || 'constructed';\n\t\t\tdeckValidator.setFormat(format);\n\t\t\t// Removed redundant declaration of 'format'\n\n\t\t\tconst newDeck: Deck = {\n\t\t\t\tid: `deck-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`, // Ensure more unique ID\n\t\t\t\tname: event.name,\n\t\t\t\tdescription: event.description || '',\n\t\t\t\tcards: [],\n\t\t\t\theroId: null,\n\t\t\t\tformat,\n\t\t\t\tisValid: false, // Will be updated by validation\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t};\n\t\t\t// Initial validation for the new deck\n\t\t\tconst validationResult = deckValidator.validate(newDeck.cards, newDeck.heroId || undefined);\n\t\t\tnewDeck.isValid = validationResult.isValid;\n\n\t\t\treturn {\n\t\t\t\tcurrentDeck: newDeck,\n\t\t\t\tvalidationResult: validationResult, // Store initial validation\n\t\t\t\terror: null\n\t\t\t};\n\t\t}),\n\n\t\tassignCurrentDeckFromLoaded: assign(({ context, event }) => {\n\t\t\tassertEvent(event, 'EDIT_DECK');\n\t\t\tconst deckToEdit = context.decks.find((d) => d.id === event.deckId);\n\t\t\tif (deckToEdit) {\n\t\t\t\tdeckValidator.setFormat(deckToEdit.format);\n\t\t\t\tconst validationResult = deckValidator.validate(\n\t\t\t\t\tdeckToEdit.cards,\n\t\t\t\t\tdeckToEdit.heroId || undefined\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tcurrentDeck: deckToEdit,\n\t\t\t\t\tvalidationResult: validationResult,\n\t\t\t\t\terror: null\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tcurrentDeck: null, // Should not happen if UI is correct\n\t\t\t\tvalidationResult: null,\n\t\t\t\terror: 'Deck not found for editing'\n\t\t\t};\n\t\t}),\n\n\t\t// deleteDeck action is removed, handled by invoke\n\n\t\tassignDeletedDeckToContext: assign(({ context, event }) => {\n\t\t\tassertEvent(event, 'DECK_DELETED');\n\t\t\treturn {\n\t\t\t\tdecks: context.decks.filter((d) => d.id !== event.deckId),\n\t\t\t\tcurrentDeck: context.currentDeck?.id === event.deckId ? null : context.currentDeck,\n\t\t\t\tisLoading: false,\n\t\t\t\terror: null\n\t\t\t};\n\t\t}),\n\t\tassignDeleteErrorToContext: assign(({ event }) => {\n\t\t\tassertEvent(event, 'DECK_DELETE_FAILED');\n\t\t\treturn {\n\t\t\t\tisLoading: false,\n\t\t\t\terror: event.error instanceof Error ? event.error.message : 'Failed to delete deck'\n\t\t\t};\n\t\t}),\n\n\t\taddCard: assign(({ context, event }) => {\n\t\t\tassertEvent(event, 'ADD_CARD');\n\t\t\tif (!context.currentDeck) return {};\n\n\t\t\t// Check if card can be added according to deck building rules\n\t\t\tdeckValidator.setFormat(context.currentDeck.format);\n\t\t\tconst canAddResult = deckValidator.canAddCard(\n\t\t\t\tcontext.currentDeck.cards,\n\t\t\t\tevent.cardId,\n\t\t\t\tcontext.currentDeck.heroId || undefined\n\t\t\t);\n\n\t\t\tif (!canAddResult.canAdd) {\n\t\t\t\treturn {\n\t\t\t\t\t...context,\n\t\t\t\t\terror: canAddResult.reason || 'Cannot add card'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst existingCard = context.currentDeck.cards.find((c) => c.cardId === event.cardId);\n\t\t\tlet updatedCards;\n\n\t\t\tif (existingCard) {\n\t\t\t\tconst maxCopies =\n\t\t\t\t\tcontext.currentDeck.format === 'constructed' ? 3 : Number.MAX_SAFE_INTEGER;\n\t\t\t\tupdatedCards = context.currentDeck.cards.map((c) =>\n\t\t\t\t\tc.cardId === event.cardId\n\t\t\t\t\t\t? { ...c, quantity: Math.min(maxCopies, c.quantity + (event.quantity || 1)) }\n\t\t\t\t\t\t: c\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tupdatedCards = [\n\t\t\t\t\t...context.currentDeck.cards,\n\t\t\t\t\t{\n\t\t\t\t\t\tcardId: event.cardId,\n\t\t\t\t\t\tquantity: event.quantity || 1\n\t\t\t\t\t}\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tconst updatedDeck = {\n\t\t\t\t...context.currentDeck,\n\t\t\t\tcards: updatedCards,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t};\n\t\t\tconst validationResult = deckValidator.validate(\n\t\t\t\tupdatedDeck.cards,\n\t\t\t\tupdatedDeck.heroId || undefined\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tcurrentDeck: { ...updatedDeck, isValid: validationResult.isValid },\n\t\t\t\tvalidationResult,\n\t\t\t\terror: null\n\t\t\t};\n\t\t}),\n\n\t\tremoveCard: assign(({ context, event }) => {\n\t\t\tassertEvent(event, 'REMOVE_CARD');\n\t\t\tif (!context.currentDeck) return {};\n\n\t\t\tconst updatedDeck = {\n\t\t\t\t...context.currentDeck,\n\t\t\t\tcards: context.currentDeck.cards.filter((c) => c.cardId !== event.cardId),\n\t\t\t\tupdatedAt: new Date()\n\t\t\t};\n\t\t\tconst validationResult = deckValidator.validate(\n\t\t\t\tupdatedDeck.cards,\n\t\t\t\tupdatedDeck.heroId || undefined\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tcurrentDeck: { ...updatedDeck, isValid: validationResult.isValid },\n\t\t\t\tvalidationResult,\n\t\t\t\terror: null\n\t\t\t};\n\t\t}),\n\n\t\tupdateCardQuantity: assign(({ context, event }) => {\n\t\t\tassertEvent(event, 'UPDATE_CARD_QUANTITY');\n\t\t\tif (!context.currentDeck) return {};\n\n\t\t\tconst updatedCards = context.currentDeck.cards\n\t\t\t\t.map((c) =>\n\t\t\t\t\tc.cardId === event.cardId\n\t\t\t\t\t\t? { ...c, quantity: Math.max(0, Math.min(3, event.quantity)) }\n\t\t\t\t\t\t: c\n\t\t\t\t)\n\t\t\t\t.filter((c) => c.quantity > 0);\n\n\t\t\tconst updatedDeck = {\n\t\t\t\t...context.currentDeck,\n\t\t\t\tcards: updatedCards,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t};\n\t\t\tconst validationResult = deckValidator.validate(\n\t\t\t\tupdatedDeck.cards,\n\t\t\t\tupdatedDeck.heroId || undefined\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tcurrentDeck: { ...updatedDeck, isValid: validationResult.isValid },\n\t\t\t\tvalidationResult,\n\t\t\t\terror: null\n\t\t\t};\n\t\t}),\n\n\t\tsetHero: assign(({ context, event }) => {\n\t\t\tassertEvent(event, 'SET_HERO');\n\t\t\tif (!context.currentDeck) return {};\n\n\t\t\tconst updatedDeck = {\n\t\t\t\t...context.currentDeck,\n\t\t\t\theroId: event.cardId,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t};\n\t\t\tconst validationResult = deckValidator.validate(\n\t\t\t\tupdatedDeck.cards,\n\t\t\t\tupdatedDeck.heroId || undefined\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tcurrentDeck: { ...updatedDeck, isValid: validationResult.isValid },\n\t\t\t\tvalidationResult,\n\t\t\t\terror: null\n\t\t\t};\n\t\t}),\n\n\t\tsetFormat: assign(({ context, event }) => {\n\t\t\tassertEvent(event, 'SET_FORMAT');\n\t\t\tif (!context.currentDeck) return {};\n\n\t\t\tdeckValidator.setFormat(event.format);\n\t\t\tconst updatedDeck = {\n\t\t\t\t...context.currentDeck,\n\t\t\t\tformat: event.format,\n\t\t\t\tupdatedAt: new Date()\n\t\t\t};\n\t\t\tconst validationResult = deckValidator.validate(\n\t\t\t\tupdatedDeck.cards,\n\t\t\t\tupdatedDeck.heroId || undefined\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tcurrentDeck: { ...updatedDeck, isValid: validationResult.isValid },\n\t\t\t\tvalidationResult,\n\t\t\t\terror: null\n\t\t\t};\n\t\t}),\n\n\t\tvalidateCurrentDeck: assign(({ context }) => {\n\t\t\tif (!context.currentDeck) return {};\n\t\t\tdeckValidator.setFormat(context.currentDeck.format);\n\t\t\tconst validationResult = deckValidator.validate(\n\t\t\t\tcontext.currentDeck.cards,\n\t\t\t\tcontext.currentDeck.heroId || undefined\n\t\t\t);\n\t\t\treturn {\n\t\t\t\tcurrentDeck: { ...context.currentDeck, isValid: validationResult.isValid },\n\t\t\t\tvalidationResult\n\t\t\t};\n\t\t}),\n\n\t\tassignSavedDeckToContext: assign(({ context, event }) => {\n\t\t\tassertEvent(event, 'DECK_SAVED');\n\t\t\t// Update the deck in the list of decks, or add if new\n\t\t\tconst newDecks = context.decks.filter((d) => d.id !== event.deck.id);\n\t\t\tnewDecks.push(event.deck);\n\t\t\treturn {\n\t\t\t\tdecks: newDecks,\n\t\t\t\tcurrentDeck: event.deck, // Update currentDeck to the saved one\n\t\t\t\tisLoading: false,\n\t\t\t\terror: null\n\t\t\t};\n\t\t}),\n\t\tassignSaveErrorToContext: assign(({ event }) => {\n\t\t\tassertEvent(event, 'DECK_SAVE_FAILED');\n\t\t\treturn {\n\t\t\t\tisLoading: false,\n\t\t\t\terror: event.error instanceof Error ? event.error.message : 'Failed to save deck'\n\t\t\t};\n\t\t}),\n\n\t\tsetSearchQuery: assign(({ event }) => {\n\t\t\tassertEvent(event, 'SEARCH_CARDS');\n\t\t\treturn { searchQuery: event.query };\n\t\t}),\n\n\t\tapplyDeckFilters: assign(({ event }) => {\n\t\t\tassertEvent(event, 'APPLY_FILTERS');\n\t\t\treturn { filters: event.filters };\n\t\t}),\n\n\t\tclearDeckFilters: assign(() => ({\n\t\t\tfilters: {},\n\t\t\tsearchQuery: ''\n\t\t})),\n\n\t\tassignErrorToContext: assign(({ event }) => {\n\t\t\tassertEvent(event, 'ERROR');\n\t\t\treturn {\n\t\t\t\terror: event.message,\n\t\t\t\tisLoading: false\n\t\t\t};\n\t\t}),\n\n\t\tclearErrorFromContext: assign(() => ({\n\t\t\terror: null\n\t\t}))\n\t},\n\n\tguards: {\n\t\thasDeckToSave: ({ context }) => context.currentDeck !== null,\n\t\tisCurrentDeckValid: ({ context }) => context.currentDeck?.isValid === true,\n\t\t// canAddCard guard remains the same\n\t\tcanAddCard: ({ context, event }) => {\n\t\t\tassertEvent(event, 'ADD_CARD');\n\t\t\tif (!context.currentDeck) return false;\n\t\t\tdeckValidator.setFormat(context.currentDeck.format);\n\t\t\tconst result = deckValidator.canAddCard(\n\t\t\t\tcontext.currentDeck.cards,\n\t\t\t\tevent.cardId,\n\t\t\t\tcontext.currentDeck.heroId || undefined\n\t\t\t);\n\t\t\treturn result.canAdd;\n\t\t}\n\t}\n}).createMachine({\n\tid: 'deck',\n\tinitial: 'initializing',\n\tcontext: {\n\t\tdecks: [],\n\t\tcurrentDeck: null,\n\t\tselectedCards: [], // This might need to be reviewed if it's actively used\n\t\tsearchQuery: '',\n\t\tfilters: {},\n\t\tvalidationResult: null,\n\t\tisLoading: true, // Start with loading true\n\t\terror: null\n\t},\n\tstates: {\n\t\tinitializing: {\n\t\t\tinvoke: {\n\t\t\t\tid: 'loadDecksFromDb',\n\t\t\t\tsrc: 'loadDecksFromDb',\n\t\t\t\tonDone: {\n\t\t\t\t\ttarget: 'idle',\n\t\t\t\t\tactions: 'assignDecksToContext'\n\t\t\t\t},\n\t\t\t\tonError: {\n\t\t\t\t\ttarget: 'errorLoading',\n\t\t\t\t\tactions: 'assignLoadErrorToContext'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tidle: {\n\t\t\tentry: assign({ isLoading: false }),\n\t\t\ton: {\n\t\t\t\tLOAD_DECKS: 'initializing', // Re-load\n\t\t\t\tCREATE_DECK: {\n\t\t\t\t\ttarget: 'editing',\n\t\t\t\t\tactions: 'createDeck'\n\t\t\t\t},\n\t\t\t\tEDIT_DECK: {\n\t\t\t\t\ttarget: 'editing',\n\t\t\t\t\tactions: 'assignCurrentDeckFromLoaded'\n\t\t\t\t},\n\t\t\t\tDELETE_DECK: {\n\t\t\t\t\ttarget: 'deleting'\n\t\t\t\t\t// Guard: check if deckId is valid or exists?\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// loading state is effectively 'initializing' now\n\t\t// loaded state is effectively 'idle' now\n\n\t\tediting: {\n\t\t\tentry: assign({ isLoading: false }),\n\t\t\ton: {\n\t\t\t\tADD_CARD: { actions: 'addCard' },\n\t\t\t\tREMOVE_CARD: { actions: 'removeCard' },\n\t\t\t\tUPDATE_CARD_QUANTITY: { actions: 'updateCardQuantity' },\n\t\t\t\tSET_HERO: { actions: 'setHero' },\n\t\t\t\tSET_FORMAT: { actions: 'setFormat' },\n\t\t\t\tVALIDATE_DECK: { actions: 'validateCurrentDeck' },\n\t\t\t\tSAVE_DECK: {\n\t\t\t\t\ttarget: 'saving',\n\t\t\t\t\tguard: 'hasDeckToSave'\n\t\t\t\t\t// Consider adding guard: 'isCurrentDeckValid' if saving should only happen for valid decks\n\t\t\t\t},\n\t\t\t\tSEARCH_CARDS: { actions: 'setSearchQuery' },\n\t\t\t\tAPPLY_FILTERS: { actions: 'applyDeckFilters' },\n\t\t\t\tCLEAR_FILTERS: { actions: 'clearDeckFilters' },\n\t\t\t\tLOAD_DECKS: 'initializing', // Go back to loading if requested\n\t\t\t\tEDIT_DECK: {\n\t\t\t\t\t// If user clicks edit on another deck while already editing\n\t\t\t\t\ttarget: 'editing',\n\t\t\t\t\tactions: 'assignCurrentDeckFromLoaded'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsaving: {\n\t\t\tentry: assign({ isLoading: true }),\n\t\t\tinvoke: {\n\t\t\t\tid: 'saveDeckToDb',\n\t\t\t\tsrc: 'saveDeckToDb',\n\t\t\t\tinput: ({ context }) => ({ deckToSave: context.currentDeck! }), // currentDeck is guarded by hasDeckToSave\n\t\t\t\tonDone: {\n\t\t\t\t\ttarget: 'idle', // Or 'editing' if staying on the page\n\t\t\t\t\tactions: 'assignSavedDeckToContext'\n\t\t\t\t},\n\t\t\t\tonError: {\n\t\t\t\t\ttarget: 'editing', // Stay in editing mode on save failure\n\t\t\t\t\tactions: 'assignSaveErrorToContext'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tdeleting: {\n\t\t\tentry: assign({ isLoading: true }),\n\t\t\tinvoke: {\n\t\t\t\tid: 'deleteDeckFromDb',\n\t\t\t\tsrc: 'deleteDeckFromDb',\n\t\t\t\tinput: ({ event }) => {\n\t\t\t\t\t// Assuming DELETE_DECK event carries the deckId\n\t\t\t\t\tassertEvent(event, 'DELETE_DECK');\n\t\t\t\t\treturn { deckId: event.deckId };\n\t\t\t\t},\n\t\t\t\tonDone: {\n\t\t\t\t\ttarget: 'idle',\n\t\t\t\t\tactions: 'assignDeletedDeckToContext'\n\t\t\t\t},\n\t\t\t\tonError: {\n\t\t\t\t\ttarget: 'idle', // Or a specific error state for deletion\n\t\t\t\t\tactions: 'assignDeleteErrorToContext'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\terrorLoading: {\n\t\t\t// Specific error state for initial load\n\t\t\ton: {\n\t\t\t\tLOAD_DECKS: 'initializing',\n\t\t\t\tCLEAR_ERROR: {\n\t\t\t\t\ttarget: 'idle',\n\t\t\t\t\tactions: 'clearErrorFromContext'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\terror: {\n\t\t\t// General error state (can be merged with errorLoading or kept separate)\n\t\t\ton: {\n\t\t\t\tCLEAR_ERROR: {\n\t\t\t\t\ttarget: 'idle', // Or previous state if known\n\t\t\t\t\tactions: 'clearErrorFromContext'\n\t\t\t\t},\n\t\t\t\tLOAD_DECKS: 'initializing' // Allow reloading\n\t\t\t}\n\t\t}\n\t}\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/lib/state/gameMachine.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 26,
				"column": 29,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 26,
				"endColumn": 32,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [965, 968], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [965, 968], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 27,
				"column": 25,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 27,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [1044, 1047], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [1044, 1047], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'context' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 128,
				"column": 35,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 128,
				"endColumn": 42
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 2,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { setup, assign } from 'xstate';\nimport type { GameStateManager } from '$engine/GameStateManager';\nimport { EventBus } from '$engine/EventBus';\nimport type { ICardDefinition } from '$engine/types/cards';\nimport { GamePhase } from '$engine/types/enums';\nimport type { PhaseManager } from '$engine/PhaseManager';\nimport type { TurnManager } from '$engine/TurnManager';\nimport type { CardPlaySystem } from '$engine/CardPlaySystem';\n\ninterface GameContext {\n\tgameStateManager: GameStateManager | null;\n\teventBus: EventBus | null;\n\tphaseManager: PhaseManager | null;\n\tturnManager: TurnManager | null;\n\tcardPlaySystem: CardPlaySystem | null;\n\tcardDefinitions: Map<string, ICardDefinition> | null;\n\tplayers: string[];\n\tcurrentPlayer: string | null;\n\tcurrentPhase: GamePhase;\n\tcurrentDay: number;\n\tselectedCard: string | null;\n\tselectedDeck: string | null;\n\terror: string | null;\n\t// Reaction loop context\n\tpendingReactionsCount: number;\n\tinitiativePlayerReactions: any[]; // Should be IEmblemObject[], using any for now\n\tnextReactionToResolve: any | null; // Should be IEmblemObject | null\n\treactionInitiativePlayerId: string | null;\n\treactionInitiativePassCount: number;\n}\n\ntype GameEvents =\n\t| { type: 'INITIALIZE_GAME'; players: string[] }\n\t| { type: 'START_GAME'; deckId: string }\n\t| { type: 'LOAD_CARD_DEFINITIONS'; cardDefs: ICardDefinition[] }\n\t| { type: 'PLAY_CARD'; cardId: string; playerId: string; targetId?: string }\n\t| { type: 'CHOOSE_REACTION_TO_PLAY'; chosenReactionId: string }\n\t| { type: 'ADVANCE_PHASE' }\n\t| { type: 'PASS_TURN' }\n\t| { type: 'SELECT_CARD'; cardId: string }\n\t| { type: 'END_GAME' }\n\t| { type: 'RESET_GAME' }\n\t| { type: 'ERROR'; message: string };\n\nexport const gameMachine = setup({\n\ttypes: {\n\t\tcontext: {} as GameContext,\n\t\tevents: {} as GameEvents\n\t},\n\tactions: {\n\t\tevaluateLimbo: assign(({ context }) => {\n\t\t\tif (!context.gameStateManager) return {};\n\t\t\tconst limbo = context.gameStateManager.state.sharedZones.limbo;\n\t\t\tconst allReactions = limbo.getAll().filter((obj) => obj.type === 'EMBLEM-REACTION'); // Ensure 'type' and 'controllerId' exist\n\n\t\t\tlet currentReactionInitiativePlayerId = context.reactionInitiativePlayerId;\n\t\t\tlet currentPassCount = context.reactionInitiativePassCount;\n\n\t\t\t// Initialize reactionInitiativePlayerId and passCount if this is the start of a new reaction cycle\n\t\t\tif (currentReactionInitiativePlayerId === null) {\n\t\t\t\tif (context.currentPhase === GamePhase.Afternoon) {\n\t\t\t\t\tcurrentReactionInitiativePlayerId = context.gameStateManager.state.currentPlayerId;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentReactionInitiativePlayerId = context.gameStateManager.state.firstPlayerId;\n\t\t\t\t}\n\t\t\t\tcurrentPassCount = 0; // Reset pass count for the new cycle\n\t\t\t}\n\n\t\t\tconst initiativePlayerReactions = allReactions.filter(\n\t\t\t\t(r) => r.controllerId === currentReactionInitiativePlayerId\n\t\t\t); // Assuming 'controllerId'\n\n\t\t\treturn {\n\t\t\t\tpendingReactionsCount: allReactions.length,\n\t\t\t\tinitiativePlayerReactions: initiativePlayerReactions,\n\t\t\t\t// Set nextReactionToResolve only if there's exactly one, or for auto-processing.\n\t\t\t\t// If multiple, player choice will set it.\n\t\t\t\tnextReactionToResolve:\n\t\t\t\t\tinitiativePlayerReactions.length === 1 ? initiativePlayerReactions[0] : null,\n\t\t\t\treactionInitiativePlayerId: currentReactionInitiativePlayerId,\n\t\t\t\treactionInitiativePassCount: currentPassCount\n\t\t\t};\n\t\t}),\n\t\tsetChosenReaction: assign(({ context, event }) => {\n\t\t\tif (event.type !== 'CHOOSE_REACTION_TO_PLAY') return {};\n\t\t\tconst chosenReaction = context.initiativePlayerReactions.find(\n\t\t\t\t(r) => r.id === event.chosenReactionId\n\t\t\t); // Assuming reaction has 'id'\n\t\t\tif (chosenReaction) {\n\t\t\t\treturn { nextReactionToResolve: chosenReaction };\n\t\t\t} else {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Chosen reaction ID ${event.chosenReactionId} not found in initiativePlayerReactions.`\n\t\t\t\t);\n\t\t\t\treturn {}; // Or set an error\n\t\t\t}\n\t\t}),\n\t\tpassReactionInitiative: assign(({ context }) => {\n\t\t\tif (!context.gameStateManager || !context.reactionInitiativePlayerId) return {};\n\t\t\tconst playerIds = context.gameStateManager.getPlayerIds();\n\t\t\tif (playerIds.length === 0) return {};\n\n\t\t\tconst currentIndex = playerIds.indexOf(context.reactionInitiativePlayerId);\n\t\t\tconst nextIndex = (currentIndex + 1) % playerIds.length;\n\n\t\t\treturn {\n\t\t\t\treactionInitiativePlayerId: playerIds[nextIndex],\n\t\t\t\treactionInitiativePassCount: context.reactionInitiativePassCount + 1,\n\t\t\t\tnextReactionToResolve: null // Clear previous player's reaction\n\t\t\t};\n\t\t}),\n\t\tresolveNextReaction: assign(({ context }) => {\n\t\t\tif (!context.nextReactionToResolve || !context.gameStateManager) return {};\n\n\t\t\tconst reaction = context.nextReactionToResolve;\n\t\t\t// Assuming effectProcessor.resolveEffect is synchronous for now or handles its own async\n\t\t\tcontext.gameStateManager.effectProcessor.resolveEffect(\n\t\t\t\treaction.boundEffect,\n\t\t\t\treaction.controllerId\n\t\t\t);\n\t\t\tcontext.gameStateManager.state.sharedZones.limbo.remove(reaction.id); // Assuming reaction has an id\n\n\t\t\treturn {\n\t\t\t\tnextReactionToResolve: null\n\t\t\t\t// pendingReactionsCount and initiativePlayerReactions will be re-evaluated in evaluateLimbo\n\t\t\t};\n\t\t}),\n\t\tclearReactionContext: assign(({ context }) => {\n\t\t\treturn {\n\t\t\t\tpendingReactionsCount: 0,\n\t\t\t\tinitiativePlayerReactions: [],\n\t\t\t\tnextReactionToResolve: null,\n\t\t\t\treactionInitiativePlayerId: null,\n\t\t\t\treactionInitiativePassCount: 0\n\t\t\t};\n\t\t}),\n\t\tinitializeCoreEngine: assign(({ context, event }) => {\n\t\t\tif (event.type !== 'INITIALIZE_GAME') return context;\n\t\t\tconst eventBus = new EventBus();\n\t\t\tconst gameStateManager = new GameStateManager(eventBus, event.players, []);\n\t\t\tconst phaseManager = new PhaseManager(gameStateManager, eventBus);\n\t\t\tconst turnManager = new TurnManager(gameStateManager, eventBus);\n\t\t\tconst cardPlaySystem = new CardPlaySystem(gameStateManager, eventBus);\n\t\t\treturn {\n\t\t\t\t...context,\n\t\t\t\teventBus,\n\t\t\t\tgameStateManager,\n\t\t\t\tphaseManager,\n\t\t\t\tturnManager,\n\t\t\t\tcardPlaySystem,\n\t\t\t\tplayers: gameStateManager.state.players,\n\t\t\t\tcurrentPlayer: gameStateManager.state.currentPlayer,\n\t\t\t\tcurrentPhase: gameStateManager.state.currentPhase,\n\t\t\t\tcurrentDay: gameStateManager.state.currentDay,\n\t\t\t\terror: null\n\t\t\t};\n\t\t}),\n\n\t\ttriggerGameStartInitialization: assign(({ context, event }) => {\n\t\t\tif (event.type !== 'START_GAME') return context;\n\t\t\tcontext.gameStateManager?.initializeGame();\n\t\t\treturn {\n\t\t\t\t...context,\n\t\t\t\tselectedDeck: event.deckId,\n\t\t\t\tcurrentPhase: context.gameStateManager?.state.currentPhase || GamePhase.Morning,\n\t\t\t\terror: null\n\t\t\t};\n\t\t}),\n\n\t\tloadCardDefinitions: assign(({ context, event }) => {\n\t\t\tif (event.type !== 'LOAD_CARD_DEFINITIONS') return context;\n\t\t\tconst cardDefinitions = new Map<string, ICardDefinition>();\n\t\t\tfor (const cardDef of event.cardDefs) {\n\t\t\t\tcardDefinitions.set(cardDef.id, cardDef);\n\t\t\t}\n\t\t\tcontext.gameStateManager?.loadCardDefinitions(event.cardDefs);\n\t\t\treturn {\n\t\t\t\t...context,\n\t\t\t\tcardDefinitions\n\t\t\t};\n\t\t}),\n\n\t\tplayCard: assign(({ context, event }) => {\n\t\t\tif (event.type !== 'PLAY_CARD' || !context.cardPlaySystem) return context;\n\t\t\tcontext.cardPlaySystem.playCard(event.playerId, event.cardId, event.targetId);\n\t\t\t// The actual state change (selectedCard, etc.) should ideally come from events\n\t\t\t// published by CardPlaySystem and handled by GameStateManager, then reflected here.\n\t\t\t// For now, we keep it simple and don't assume immediate state changes in XState context\n\t\t\t// directly from this action, other than perhaps an error if playCard failed synchronously.\n\t\t\treturn {\n\t\t\t\t...context,\n\t\t\t\t// selectedCard: event.cardId, // Potentially remove if CPS handles this via events\n\t\t\t\terror: null // Reset error, or set if playCard throws/returns error\n\t\t\t};\n\t\t}),\n\n\t\tadvancePhase: assign(({ context }) => {\n\t\t\tif (!context.phaseManager || !context.gameStateManager) return context;\n\t\t\tcontext.phaseManager.advancePhase();\n\t\t\treturn {\n\t\t\t\t...context,\n\t\t\t\tcurrentPhase: context.gameStateManager.state.currentPhase,\n\t\t\t\tcurrentDay: context.gameStateManager.state.currentDay,\n\t\t\t\terror: null\n\t\t\t};\n\t\t}),\n\n\t\tstartAfternoonPhase: assign(({ context }) => {\n\t\t\tif (!context.turnManager || !context.gameStateManager) return context;\n\t\t\tcontext.turnManager.startAfternoon();\n\t\t\treturn {\n\t\t\t\t...context,\n\t\t\t\tcurrentPlayer: context.gameStateManager.state.currentPlayerId\n\t\t\t};\n\t\t}),\n\n\t\tpassTurn: assign(({ context }) => {\n\t\t\tif (!context.turnManager || !context.gameStateManager || !context.currentPlayer)\n\t\t\t\treturn context;\n\t\t\tcontext.turnManager.playerPasses(context.currentPlayer);\n\t\t\t// currentPlayer and currentPhase might change as a result of playerPasses (if phase ends)\n\t\t\treturn {\n\t\t\t\t...context,\n\t\t\t\tcurrentPlayer: context.gameStateManager.state.currentPlayerId,\n\t\t\t\tcurrentPhase: context.gameStateManager.state.currentPhase, // Reflect potential phase change\n\t\t\t\terror: null\n\t\t\t};\n\t\t}),\n\n\t\tselectCard: assign(({ context, event }) => {\n\t\t\tif (event.type !== 'SELECT_CARD') return context;\n\n\t\t\treturn {\n\t\t\t\t...context,\n\t\t\t\tselectedCard: event.cardId,\n\t\t\t\terror: null\n\t\t\t};\n\t\t}),\n\n\t\tsetError: assign(({ context, event }) => {\n\t\t\tif (event.type !== 'ERROR') return context;\n\n\t\t\treturn {\n\t\t\t\t...context,\n\t\t\t\terror: event.message\n\t\t\t};\n\t\t}),\n\n\t\tresetGame: assign(() => ({\n\t\t\tgameStateManager: null,\n\t\t\teventBus: null,\n\t\t\tphaseManager: null,\n\t\t\tturnManager: null,\n\t\t\tcardPlaySystem: null,\n\t\t\tcardDefinitions: null,\n\t\t\tplayers: [],\n\t\t\tcurrentPlayer: null,\n\t\t\tcurrentPhase: GamePhase.Setup,\n\t\t\tcurrentDay: 1,\n\t\t\tselectedCard: null,\n\t\t\tselectedDeck: null,\n\t\t\terror: null,\n\t\t\tpendingReactionsCount: 0,\n\t\t\tinitiativePlayerReactions: [],\n\t\t\tnextReactionToResolve: null,\n\t\t\treactionInitiativePlayerId: null,\n\t\t\treactionInitiativePassCount: 0\n\t\t}))\n\t},\n\n\tguards: {\n\t\tmultipleReactionsAvailable: ({ context }) => {\n\t\t\treturn context.initiativePlayerReactions.length > 1;\n\t\t},\n\t\thasSingleReactionForInitiativePlayer: ({ context }) => {\n\t\t\t// evaluateLimbo sets nextReactionToResolve if length is 1.\n\t\t\treturn (\n\t\t\t\tcontext.initiativePlayerReactions.length === 1 && context.nextReactionToResolve !== null\n\t\t\t);\n\t\t},\n\t\t// Renaming for clarity, effectively the same as old hasReactionsForInitiativePlayer after multiple check\n\t\thasNextReactionToResolve: ({ context }) => {\n\t\t\treturn context.nextReactionToResolve !== null;\n\t\t},\n\t\tcanPassReactionInitiative: ({ context }) => {\n\t\t\t// True if there are pending reactions, current initiative player has no chosen/single reaction, and we haven't cycled through all players\n\t\t\treturn (\n\t\t\t\tcontext.pendingReactionsCount > 0 &&\n\t\t\t\tcontext.nextReactionToResolve === null && // No single auto-selected reaction\n\t\t\t\tcontext.initiativePlayerReactions.length === 0 && // And no reactions for them to choose from (or they chose none)\n\t\t\t\tcontext.reactionInitiativePassCount < (context.players?.length || 0)\n\t\t\t);\n\t\t},\n\t\tnoReactionsAtAllOrAllPassed: ({ context }) => {\n\t\t\t// True if no reactions pending globally, OR\n\t\t\t// if current initiative player has no reactions (nextReactionToResolve is null AND initiativePlayerReactions is empty) AND we've already tried passing to everyone\n\t\t\treturn (\n\t\t\t\tcontext.pendingReactionsCount === 0 ||\n\t\t\t\t(context.nextReactionToResolve === null &&\n\t\t\t\t\tcontext.initiativePlayerReactions.length === 0 &&\n\t\t\t\t\tcontext.reactionInitiativePassCount >= (context.players?.length || 0))\n\t\t\t);\n\t\t},\n\t\tcanPlayCard: ({ context, event }) => {\n\t\t\t// Basic guard, will need refinement with GameStateManager\n\t\t\t// Ensure it's the correct player's turn and the correct phase.\n\t\t\t// The actual check for card in hand, mana, etc., would be inside CardPlaySystem\n\t\t\t// or checked via gsm.canPlayCard(event.playerId, event.cardId).\n\t\t\t// For XState guard, we ensure basic conditions are met for the event to proceed.\n\t\t\tif (event.type !== 'PLAY_CARD') return false;\n\t\t\treturn (\n\t\t\t\tcontext.currentPhase === GamePhase.Afternoon && context.currentPlayer === event.playerId\n\t\t\t);\n\t\t\t// context.selectedCard !== null was here, but event.cardId is more direct.\n\t\t\t// We assume event.cardId is provided.\n\t\t},\n\n\t\tcanAdvancePhase: ({ context }) => {\n\t\t\t// Check if phase can be advanced based on game rules\n\t\t\treturn context.currentPhase !== GamePhase.Afternoon; // Afternoon requires player actions\n\t\t},\n\n\t\tisGameInitialized: ({ context }) => {\n\t\t\treturn context.players.length > 0 && context.currentPlayer !== null;\n\t\t}\n\t}\n}).createMachine({\n\tid: 'game',\n\tinitial: 'idle',\n\tcontext: {\n\t\tgameStateManager: null,\n\t\teventBus: null,\n\t\tphaseManager: null,\n\t\tturnManager: null,\n\t\tcardPlaySystem: null,\n\t\tcardDefinitions: null,\n\t\tplayers: [],\n\t\tcurrentPlayer: null,\n\t\tcurrentPhase: GamePhase.Setup,\n\t\tcurrentDay: 1,\n\t\tselectedCard: null,\n\t\tselectedDeck: null,\n\t\terror: null,\n\t\tpendingReactionsCount: 0,\n\t\tinitiativePlayerReactions: [],\n\t\tnextReactionToResolve: null,\n\t\treactionInitiativePlayerId: null,\n\t\treactionInitiativePassCount: 0\n\t},\n\tstates: {\n\t\tidle: {\n\t\t\ton: {\n\t\t\t\tINITIALIZE_GAME: {\n\t\t\t\t\ttarget: 'initializing',\n\t\t\t\t\tactions: 'initializeCoreEngine'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tinitializing: {\n\t\t\ton: {\n\t\t\t\tSTART_GAME: {\n\t\t\t\t\ttarget: 'playing',\n\t\t\t\t\tactions: 'triggerGameStartInitialization',\n\t\t\t\t\tguard: 'isGameInitialized'\n\t\t\t\t},\n\t\t\t\tLOAD_CARD_DEFINITIONS: {\n\t\t\t\t\tactions: 'loadCardDefinitions'\n\t\t\t\t},\n\t\t\t\tERROR: {\n\t\t\t\t\ttarget: 'error',\n\t\t\t\t\tactions: 'setError'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tplaying: {\n\t\t\tinitial: 'waitingForAction',\n\t\t\tstates: {\n\t\t\t\twaitingForAction: {\n\t\t\t\t\ton: {\n\t\t\t\t\t\tPLAY_CARD: {\n\t\t\t\t\t\t\ttarget: 'processingCard',\n\t\t\t\t\t\t\tactions: 'playCard',\n\t\t\t\t\t\t\tguard: 'canPlayCard'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tADVANCE_PHASE: {\n\t\t\t\t\t\t\ttarget: 'advancingPhase',\n\t\t\t\t\t\t\tguard: 'canAdvancePhase'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tPASS_TURN: {\n\t\t\t\t\t\t\ttarget: 'checkingReactions',\n\t\t\t\t\t\t\tactions: 'passTurn'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tSELECT_CARD: {\n\t\t\t\t\t\t\ttarget: 'waitingForAction',\n\t\t\t\t\t\t\tactions: 'selectCard'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tprocessingCard: {\n\t\t\t\t\tafter: {\n\t\t\t\t\t\t// Assuming playCard action is synchronous for now.\n\t\t\t\t\t\t// If it becomes async, this would be handled by onDone/onError from an invoked service.\n\t\t\t\t\t\t1: 'checkingReactions' // Short delay then check reactions\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tadvancingPhase: {\n\t\t\t\t\tentry: 'advancePhase',\n\t\t\t\t\talways: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttarget: 'checkingReactions', // Check reactions after phase advance logic\n\t\t\t\t\t\t\tguard: ({ context }) => context.currentPhase !== GamePhase.Afternoon\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttarget: 'checkingReactions', // Check reactions after starting afternoon\n\t\t\t\t\t\t\tactions: 'startAfternoonPhase',\n\t\t\t\t\t\t\tguard: ({ context }) => context.currentPhase === GamePhase.Afternoon\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tcheckingReactions: {\n\t\t\t\t\tinitial: 'evaluatingLimbo',\n\t\t\t\t\tstates: {\n\t\t\t\t\t\tevaluatingLimbo: {\n\t\t\t\t\t\t\tentry: 'evaluateLimbo',\n\t\t\t\t\t\t\talways: [\n\t\t\t\t\t\t\t\t{ target: 'awaitingReactionChoice', guard: 'multipleReactionsAvailable' },\n\t\t\t\t\t\t\t\t{ target: 'resolvingReaction', guard: 'hasSingleReactionForInitiativePlayer' }, // True if exactly one\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttarget: 'evaluatingLimbo',\n\t\t\t\t\t\t\t\t\tactions: 'passReactionInitiative',\n\t\t\t\t\t\t\t\t\tguard: 'canPassReactionInitiative' // No reactions for current player, can pass\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t// Default: No reactions for current initiative player, and cannot pass initiative further\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttarget: '#game.playing.gameFlowContinuationPoint',\n\t\t\t\t\t\t\t\t\tguard: 'noReactionsAtAllOrAllPassed'\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t},\n\t\t\t\t\t\tawaitingReactionChoice: {\n\t\t\t\t\t\t\ton: {\n\t\t\t\t\t\t\t\tCHOOSE_REACTION_TO_PLAY: {\n\t\t\t\t\t\t\t\t\ttarget: 'resolvingReaction',\n\t\t\t\t\t\t\t\t\tactions: 'setChosenReaction'\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// TODO: Add timeout or auto-pass/auto-resolve default if player doesn't choose?\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tresolvingReaction: {\n\t\t\t\t\t\t\tentry: 'resolveNextReaction',\n\t\t\t\t\t\t\talways: { target: 'evaluatingLimbo' }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tgameFlowContinuationPoint: {\n\t\t\t\t\tentry: 'clearReactionContext',\n\t\t\t\t\talways: { target: 'waitingForAction' } // Simplified: always go back to waitingForAction\n\t\t\t\t}\n\t\t\t},\n\t\t\ton: {\n\t\t\t\tEND_GAME: 'gameEnded',\n\t\t\t\tERROR: {\n\t\t\t\t\ttarget: 'error',\n\t\t\t\t\tactions: 'setError'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgameEnded: {\n\t\t\ton: {\n\t\t\t\tRESET_GAME: {\n\t\t\t\t\ttarget: 'idle',\n\t\t\t\t\tactions: 'resetGame'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\terror: {\n\t\t\ton: {\n\t\t\t\tRESET_GAME: {\n\t\t\t\t\ttarget: 'idle',\n\t\t\t\t\tactions: 'resetGame'\n\t\t\t\t},\n\t\t\t\tINITIALIZE_GAME: {\n\t\t\t\t\ttarget: 'initializing',\n\t\t\t\t\tactions: 'initializeCoreEngine'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/lib/utils.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/routes/+layout.svelte",
		"messages": [
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'console' is not defined.",
				"line": 8,
				"column": 3,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 8,
				"endColumn": 10
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n\timport '../app.css';\n\timport { onMount } from 'svelte';\n\timport Header from '$components/layout/Header.svelte';\n\timport Footer from '$components/layout/Footer.svelte';\n\n\tonMount(() => {\n\t\tconsole.log('Layout mounted successfully!');\n\t});\n</script>\n\n<svelte:head>\n\t<title>Altered TCG - Digital Card Game</title>\n\t<meta name=\"description\" content=\"Altered TCG - Digital card game and deck builder\" />\n\t<meta name=\"theme-color\" content=\"#09090b\" />\n</svelte:head>\n\n<div class=\"bg-background min-h-screen font-sans antialiased\">\n\t<Header />\n\t<main class=\"flex-1\">\n\t\t<slot />\n\t</main>\n\t<Footer />\n</div>\n\n<style>\n\t:global(html) {\n\t\tcolor-scheme: light dark;\n\t}\n</style>\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/routes/+page.svelte",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'Button' is defined but never used.",
				"line": 2,
				"column": 9,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 2,
				"endColumn": 15
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'Card' is defined but never used.",
				"line": 3,
				"column": 9,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 3,
				"endColumn": 13
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'CardContent' is defined but never used.",
				"line": 4,
				"column": 9,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 4,
				"endColumn": 20
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'CardDescription' is defined but never used.",
				"line": 5,
				"column": 9,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 5,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'CardHeader' is defined but never used.",
				"line": 6,
				"column": 9,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 6,
				"endColumn": 19
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'CardTitle' is defined but never used.",
				"line": 7,
				"column": 9,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 7,
				"endColumn": 18
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'window' is not defined.",
				"line": 53,
				"column": 25,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 53,
				"endColumn": 31
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'window' is not defined.",
				"line": 75,
				"column": 27,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 75,
				"endColumn": 33
			}
		],
		"suppressedMessages": [],
		"errorCount": 8,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n\timport Button from '$components/ui/button/Button.svelte';\n\timport Card from '$components/ui/card/Card.svelte';\n\timport CardContent from '$components/ui/card/CardContent.svelte';\n\timport CardDescription from '$components/ui/card/CardDescription.svelte';\n\timport CardHeader from '$components/ui/card/CardHeader.svelte';\n\timport CardTitle from '$components/ui/card/CardTitle.svelte';\n\timport { Zap, BookOpen, Lightbulb, Layers } from 'lucide-svelte';\n\n\tconst features = [\n\t\t{\n\t\t\ticon: BookOpen,\n\t\t\ttitle: 'Card Viewer',\n\t\t\tdescription: 'Browse and discover all Altered TCG cards with detailed information.',\n\t\t\thref: '/cards'\n\t\t},\n\t\t{\n\t\t\ticon: Layers,\n\t\t\ttitle: 'Deck Builder',\n\t\t\tdescription: 'Craft, save, and manage your custom decks for competitive play or fun.',\n\t\t\thref: '/decks'\n\t\t},\n\t\t{\n\t\t\ticon: Lightbulb,\n\t\t\ttitle: 'AI Deck Advisor',\n\t\t\tdescription: 'Get AI-powered suggestions to complete your decks and optimize strategies.',\n\t\t\thref: '/ai-advisor'\n\t\t}\n\t];\n</script>\n\n<svelte:head>\n\t<title>AlterDeck - Your Ultimate Altered TCG Companion</title>\n\t<meta\n\t\tname=\"description\"\n\t\tcontent=\"Explore cards, build powerful decks, and get AI-driven advice for Altered TCG.\"\n\t/>\n</svelte:head>\n\n<div class=\"bg-background text-foreground min-h-screen\">\n\t<div class=\"flex flex-col items-center justify-center space-y-12 p-8 text-center\">\n\t\t<section class=\"w-full py-12\">\n\t\t\t<div class=\"container px-4 md:px-6\">\n\t\t\t\t<div class=\"flex flex-col items-center space-y-6 text-center\">\n\t\t\t\t\t<h1 class=\"text-primary text-4xl font-bold\">Welcome to AlterDeck</h1>\n\t\t\t\t\t<p class=\"text-muted-foreground max-w-[700px] text-lg\">\n\t\t\t\t\t\tYour ultimate companion for Altered TCG. Explore cards, build powerful decks, and get\n\t\t\t\t\t\tAI-driven advice.\n\t\t\t\t\t</p>\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tclass=\"bg-primary text-primary-foreground hover:bg-primary/90 inline-flex h-11 items-center justify-center rounded-md px-8 text-sm font-medium\"\n\t\t\t\t\t\t\ton:click={() => (window.location.href = '/cards')}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\tExplore Cards\n\t\t\t\t\t\t\t<Zap class=\"ml-2 h-5 w-5\" />\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</section>\n\n\t\t<section class=\"w-full py-12\">\n\t\t\t<div class=\"container px-4 md:px-6\">\n\t\t\t\t<h2 class=\"mb-12 text-center text-3xl font-bold\">Features</h2>\n\t\t\t\t<div class=\"grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-3\">\n\t\t\t\t\t{#each features as feature}\n\t\t\t\t\t\t<div class=\"bg-card text-card-foreground rounded-lg border p-6 shadow-lg\">\n\t\t\t\t\t\t\t<div class=\"flex flex-col items-center space-y-4 text-center\">\n\t\t\t\t\t\t\t\t<svelte:component this={feature.icon} class=\"text-primary h-8 w-8\" />\n\t\t\t\t\t\t\t\t<h3 class=\"text-2xl font-bold\">{feature.title}</h3>\n\t\t\t\t\t\t\t\t<p class=\"text-muted-foreground\">{feature.description}</p>\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\tclass=\"border-input bg-background hover:bg-accent hover:text-accent-foreground inline-flex h-10 w-full items-center justify-center rounded-md border px-4 py-2 text-sm font-medium\"\n\t\t\t\t\t\t\t\t\ton:click={() => (window.location.href = feature.href)}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tGo to {feature.title}\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t{/each}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</section>\n\t</div>\n</div>\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/routes/ai-advisor/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/routes/cards/+page.svelte",
		"messages": [
			{
				"ruleId": null,
				"nodeType": null,
				"fatal": true,
				"severity": 2,
				"message": "Parsing error: ')' expected.",
				"line": 488,
				"column": 18
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 1,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n\timport { onMount } from 'svelte';\n\timport { page } from '$app/stores';\n\timport { goto } from '$app/navigation';\n\timport { useMachine } from '@xstate/svelte';\n\timport { deckMachine } from '$lib/state/deckMachine';\n\timport { getAllCards, getCardById, cardsReadyPromise } from '$data/cards'; // Updated imports\n\timport type { AlteredCard } from '$types';\n\timport { Search, Filter, Plus, X, AlertCircle, CheckCircle, Clock } from 'lucide-svelte';\n\n\tconst { snapshot, send } = useMachine(deckMachine);\n\n\tlet searchQuery = '';\n\tlet localLoadedCards: AlteredCard[] = []; // To store cards once loaded\n\tlet filteredCards: AlteredCard[] = []; // Derived from localLoadedCards and searchQuery\n\tlet selectedAction: string | null = null;\n\tlet showHeroSelector = false;\n\n\t// Promise for loading cards\n\tlet cardsPromise: Promise<AlteredCard[]>;\n\n\tonMount(async () => {\n\t\t// It's important cardsReadyPromise resolves before we attempt to getAllCards\n\t\t// cardsReadyPromise itself ensures DB is initialized and seeded if necessary.\n\t\tcardsPromise = cardsReadyPromise.then(() => getAllCards());\n\n\t\t// Check URL parameters for actions after cards are potentially being loaded\n\t\tconst urlParams = $page.url.searchParams;\n\t\tconst action = urlParams.get('action');\n\n\t\tif (action === 'create') {\n\t\t\tselectedAction = 'create';\n\t\t\tconst deckName = prompt('Enter deck name:') || 'New Deck';\n\t\t\tconst format = confirm('Create a Constructed deck? (Cancel for Limited)')\n\t\t\t\t? 'constructed'\n\t\t\t\t: 'limited';\n\t\t\tsend({ type: 'CREATE_DECK', name: deckName, format });\n\t\t} else if (action === 'edit') {\n\t\t\tselectedAction = 'edit'; // Or some indicator that we are in edit mode\n\t\t\tconst deckId = urlParams.get('deckId');\n\t\t\tif (deckId) {\n\t\t\t\t// Ensure decks are loaded before trying to edit.\n\t\t\t\t// The machine loads decks on init. If it's idle, decks should be loaded.\n\t\t\t\tif ($snapshot.matches('idle') || $snapshot.context.decks.length > 0) {\n\t\t\t\t\tsend({ type: 'EDIT_DECK', deckId });\n\t\t\t\t} else {\n\t\t\t\t\t// If decks aren't loaded yet (e.g., deep link directly to edit page),\n\t\t\t\t\t// wait for the machine to finish initializing.\n\t\t\t\t\tconst unsubscribe = snapshot.subscribe((s) => {\n\t\t\t\t\t\tif (s.matches('idle')) {\n\t\t\t\t\t\t\tsend({ type: 'EDIT_DECK', deckId });\n\t\t\t\t\t\t\tunsubscribe(); // Clean up subscription\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error('Deck ID missing for edit action');\n\t\t\t\tgoto('/decks'); // Or show an error\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction handleSearch() {\n\t\tif (!localLoadedCards) return; // Guard against search before load\n\t\tif (searchQuery.trim() === '') {\n\t\t\tfilteredCards = localLoadedCards;\n\t\t} else {\n\t\t\tfilteredCards = localLoadedCards.filter(\n\t\t\t\t(card) =>\n\t\t\t\t\tcard.name.toLowerCase().includes(searchQuery.toLowerCase()) ||\n\t\t\t\t\tcard.type.toLowerCase().includes(searchQuery.toLowerCase()) ||\n\t\t\t\t\tcard.faction?.toLowerCase().includes(searchQuery.toLowerCase())\n\t\t\t);\n\t\t}\n\t}\n\n\t$: if (searchQuery && localLoadedCards.length > 0) {\n\t\t// Trigger search when searchQuery changes\n\t\thandleSearch();\n\t} else if (localLoadedCards.length > 0) {\n\t\t// Reset if search query is cleared\n\t\tfilteredCards = localLoadedCards;\n\t}\n\n\tfunction handleAddCard(cardId: string) {\n\t\tif (selectedAction === 'create' && $snapshot.context.currentDeck) {\n\t\t\tsend({ type: 'ADD_CARD', cardId });\n\t\t}\n\t}\n\n\tfunction handleSetHero(cardId: string) {\n\t\tif (selectedAction === 'create' && $snapshot.context.currentDeck) {\n\t\t\tsend({ type: 'SET_HERO', cardId });\n\t\t\tshowHeroSelector = false;\n\t\t}\n\t}\n\n\tfunction handleRemoveCard(cardId: string) {\n\t\tsend({ type: 'REMOVE_CARD', cardId });\n\t}\n\n\tfunction handleChangeFormat(format: 'constructed' | 'limited') {\n\t\tsend({ type: 'SET_FORMAT', format });\n\t}\n\n\t// Group cards by base name to show transformations together\n\tfunction groupCardsByBase(cards: AlteredCard[]) {\n\t\tconst groups: { [key: string]: AlteredCard[] } = {};\n\n\t\tcards.forEach((card) => {\n\t\t\t// Use the card name as the grouping key since transformations have the same name\n\t\t\tconst baseName = card.name;\n\t\t\tif (!groups[baseName]) {\n\t\t\t\tgroups[baseName] = [];\n\t\t\t}\n\t\t\tgroups[baseName].push(card);\n\t\t});\n\n\t\treturn Object.values(groups);\n\t}\n\n\t// Filter cards for hero selection (only CHARACTER types)\n\t// This will be reactive based on localLoadedCards once available\n\t$: heroCards = localLoadedCards.filter((card) => card.type === 'CHARACTER');\n\n\t// Get card quantity in current deck\n\tfunction getCardQuantity(cardId: string): number {\n\t\tif (!$snapshot.context.currentDeck) return 0;\n\t\tconst deckCard = $snapshot.context.currentDeck.cards.find((c) => c.cardId === cardId);\n\t\treturn deckCard ? deckCard.quantity : 0;\n\t}\n\n\t// Check if card can be added\n\tfunction canAddCard(cardId: string): boolean {\n\t\tconst validator = deckMachine.config.guards?.canAddCard;\n\t\tif (!validator) return false;\n\n\t\treturn validator({\n\t\t\tcontext: $snapshot.context,\n\t\t\tevent: { type: 'ADD_CARD', cardId }\n\t\t} as any);\n\t}\n\n\t$: cardGroups = groupCardsByBase(filteredCards);\n\t// heroCards is now reactive\n\t$: currentDeck = $snapshot.context.currentDeck;\n\t$: validationResult = $snapshot.context.validationResult;\n\t$: error = $snapshot.context.error;\n</script>\n\n<svelte:head>\n\t<title>Card Viewer - AlterDeck</title>\n\t<meta name=\"description\" content=\"Browse and discover all Altered TCG cards\" />\n</svelte:head>\n\n<div class=\"container mx-auto px-4 py-8\">\n\t<div class=\"flex flex-col gap-6\">\n\t\t<!-- Header -->\n\t\t<div class=\"flex items-center justify-between\">\n\t\t\t<div>\n\t\t\t\t<h1 class=\"text-3xl font-bold tracking-tight\">\n\t\t\t\t\t{selectedAction === 'create'\n\t\t\t\t\t\t? 'Deck Builder'\n\t\t\t\t\t\t: selectedAction === 'edit'\n\t\t\t\t\t\t\t? 'Edit Deck'\n\t\t\t\t\t\t\t: 'Card Viewer'}\n\t\t\t\t</h1>\n\t\t\t\t<p class=\"text-muted-foreground\">\n\t\t\t\t\t{selectedAction === 'create'\n\t\t\t\t\t\t? 'Build your deck with Altered TCG rules enforcement.'\n\t\t\t\t\t\t: selectedAction === 'edit'\n\t\t\t\t\t\t\t? 'Edit your existing deck.'\n\t\t\t\t\t\t\t: `Browse all ${localLoadedCards.length > 0 ? localLoadedCards.length : '...'} Altered TCG cards with their transformations.`}\n\t\t\t\t</p>\n\t\t\t</div>\n\t\t\t{#if selectedAction === 'create' || selectedAction === 'edit'}\n\t\t\t\t{#if $snapshot.matches('saving')}\n\t\t\t\t\t<Button disabled class=\"bg-blue-500 text-white\">\n\t\t\t\t\t\t<Clock class=\"mr-2 h-4 w-4 animate-spin\" />\n\t\t\t\t\t\tSaving...\n\t\t\t\t\t</Button>\n\t\t\t\t{:else}\n\t\t\t\t\t<Button\n\t\t\t\t\t\ton:click={() => send({ type: 'SAVE_DECK' })}\n\t\t\t\t\t\tdisabled={!currentDeck ||\n\t\t\t\t\t\t\t!$snapshot.context.validationResult?.isValid ||\n\t\t\t\t\t\t\t$snapshot.matches('saving')}\n\t\t\t\t\t\tclass=\"bg-green-600 text-white hover:bg-green-700\"\n\t\t\t\t\t>\n\t\t\t\t\t\tSave Deck\n\t\t\t\t\t</Button>\n\t\t\t\t{/if}\n\t\t\t\t<Button on:click={() => goto('/decks')} variant=\"outline\">Back to Decks</Button>\n\t\t\t{/if}\n\t\t</div>\n\n\t\t<!-- Deck Building Panel -->\n\t\t{#if (selectedAction === 'create' || selectedAction === 'edit') && currentDeck}\n\t\t\t<div class=\"bg-card space-y-4 rounded-lg border p-6\">\n\t\t\t\t<div class=\"flex items-center justify-between\">\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<!-- Deck Name - TODO: Make editable for currentDeck.name -->\n\t\t\t\t\t\t<h2 class=\"text-xl font-semibold\">{currentDeck.name}</h2>\n\t\t\t\t\t\t<div class=\"text-muted-foreground flex items-center gap-4 text-sm\">\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\t>Format:\n\t\t\t\t\t\t\t\t<select\n\t\t\t\t\t\t\t\t\tbind:value={currentDeck.format}\n\t\t\t\t\t\t\t\t\tonchange={(e) => handleChangeFormat(e.target.value)}\n\t\t\t\t\t\t\t\t\tclass=\"ml-1 rounded border px-2 py-1\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<option value=\"constructed\">Constructed</option>\n\t\t\t\t\t\t\t\t\t<option value=\"limited\">Limited</option>\n\t\t\t\t\t\t\t\t</select>\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t<span>Cards: {validationResult?.stats.totalCards || 0}</span>\n\t\t\t\t\t\t\t{#if currentDeck.heroId}\n\t\t\t\t\t\t\t\t{#await getCardById(currentDeck.heroId)}\n\t\t\t\t\t\t\t\t\t<span>Loading hero...</span>\n\t\t\t\t\t\t\t\t{:then hero}\n\t\t\t\t\t\t\t\t\t<span>Hero: {hero?.name || 'Unknown'}</span>\n\t\t\t\t\t\t\t\t{:catch error}\n\t\t\t\t\t\t\t\t\t<span class=\"text-red-500\">Error loading hero</span>\n\t\t\t\t\t\t\t\t{/await}\n\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\tonclick={() => (showHeroSelector = true)}\n\t\t\t\t\t\t\t\t\tclass=\"text-blue-600 underline hover:text-blue-800\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tSelect Hero\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"flex items-center gap-2\">\n\t\t\t\t\t\t{#if validationResult?.isValid}\n\t\t\t\t\t\t\t<CheckCircle class=\"h-5 w-5 text-green-600\" />\n\t\t\t\t\t\t\t<span class=\"text-sm text-green-600\">Valid</span>\n\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t<AlertCircle class=\"h-5 w-5 text-red-600\" />\n\t\t\t\t\t\t\t<span class=\"text-sm text-red-600\">Invalid</span>\n\t\t\t\t\t\t{/if}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<!-- Validation Errors -->\n\t\t\t\t{#if validationResult?.errors && validationResult.errors.length > 0}\n\t\t\t\t\t<div class=\"rounded border border-red-200 bg-red-50 p-3\">\n\t\t\t\t\t\t<h4 class=\"mb-2 text-sm font-medium text-red-800\">Deck Issues:</h4>\n\t\t\t\t\t\t<ul class=\"space-y-1 text-sm text-red-700\">\n\t\t\t\t\t\t\t{#each validationResult.errors as error}\n\t\t\t\t\t\t\t\t<li> {error}</li>\n\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t</div>\n\t\t\t\t{/if}\n\n\t\t\t\t<!-- Validation Warnings -->\n\t\t\t\t{#if validationResult?.warnings && validationResult.warnings.length > 0}\n\t\t\t\t\t<div class=\"rounded border border-yellow-200 bg-yellow-50 p-3\">\n\t\t\t\t\t\t<h4 class=\"mb-2 text-sm font-medium text-yellow-800\">Suggestions:</h4>\n\t\t\t\t\t\t<ul class=\"space-y-1 text-sm text-yellow-700\">\n\t\t\t\t\t\t\t{#each validationResult.warnings as warning}\n\t\t\t\t\t\t\t\t<li> {warning}</li>\n\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t</div>\n\t\t\t\t{/if}\n\n\t\t\t\t<!-- Error Messages -->\n\t\t\t\t{#if error}\n\t\t\t\t\t<div class=\"rounded border border-red-200 bg-red-50 p-3\">\n\t\t\t\t\t\t<p class=\"text-sm text-red-700\">{error}</p>\n\t\t\t\t\t</div>\n\t\t\t\t{/if}\n\n\t\t\t\t<!-- Deck Stats -->\n\t\t\t\t{#if validationResult?.stats}\n\t\t\t\t\t<div class=\"grid grid-cols-2 gap-4 text-sm md:grid-cols-4\">\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<div class=\"font-medium\">Total Cards</div>\n\t\t\t\t\t\t\t<div class=\"text-2xl\">{validationResult.stats.totalCards}</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<div class=\"font-medium\">Heroes</div>\n\t\t\t\t\t\t\t<div class=\"text-2xl\">{validationResult.stats.heroCount}</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t{#if Object.keys(validationResult.stats.rarityBreakdown).length > 0}\n\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t<div class=\"font-medium\">Rare Cards</div>\n\t\t\t\t\t\t\t\t<div class=\"text-2xl\">{validationResult.stats.rarityBreakdown['Rare'] || 0}</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t<div class=\"font-medium\">Unique Cards</div>\n\t\t\t\t\t\t\t\t<div class=\"text-2xl\">{validationResult.stats.rarityBreakdown['Unique'] || 0}</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t{/if}\n\t\t\t\t\t</div>\n\t\t\t\t{/if}\n\t\t\t</div>\n\t\t{/if}\n\n\t\t<!-- Hero Selector Modal -->\n\t\t{#if showHeroSelector}\n\t\t\t<div class=\"bg-opacity-50 fixed inset-0 z-50 flex items-center justify-center bg-black\">\n\t\t\t\t<div class=\"max-h-96 max-w-4xl overflow-y-auto rounded-lg bg-white p-6\">\n\t\t\t\t\t<div class=\"mb-4 flex items-center justify-between\">\n\t\t\t\t\t\t<h3 class=\"text-lg font-semibold\">Select Hero</h3>\n\t\t\t\t\t\t<button onclick={() => (showHeroSelector = false)}>\n\t\t\t\t\t\t\t<X class=\"h-5 w-5\" />\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"grid grid-cols-4 gap-4\">\n\t\t\t\t\t\t{#each heroCards as hero}\n\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\tonclick={() => handleSetHero(hero.id)}\n\t\t\t\t\t\t\t\tclass=\"rounded border p-2 hover:bg-gray-50\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{#if hero.imageUrl}\n\t\t\t\t\t\t\t\t\t<img src={hero.imageUrl} alt={hero.name} class=\"mb-2 h-auto w-full rounded\" />\n\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t\t<div class=\"text-center text-xs\">\n\t\t\t\t\t\t\t\t\t<div class=\"font-medium\">{hero.name}</div>\n\t\t\t\t\t\t\t\t\t<div class=\"text-gray-600\">{hero.faction}</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t{/if}\n\n\t\t<!-- Search -->\n\t\t<div class=\"flex gap-4\">\n\t\t\t<div class=\"relative flex-1\">\n\t\t\t\t<Search\n\t\t\t\t\tclass=\"text-muted-foreground absolute top-1/2 left-3 h-4 w-4 -translate-y-1/2 transform\"\n\t\t\t\t/>\n\t\t\t\t<input\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tplaceholder=\"Search cards...\"\n\t\t\t\t\tbind:value={searchQuery}\n\t\t\t\t\toninput={handleSearch}\n\t\t\t\t\tclass=\"border-input bg-background focus:ring-ring w-full rounded-md border py-2 pr-4 pl-10 focus:ring-2 focus:outline-none\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Cards Grid by Group -->\n\t\t{#await cardsPromise}\n\t\t\t<div class=\"flex items-center justify-center py-12\">\n\t\t\t\t<Clock class=\"text-primary h-8 w-8 animate-spin\" />\n\t\t\t\t<p class=\"text-muted-foreground ml-2\">Loading cards...</p>\n\t\t\t</div>\n\t\t{:then loadedSuccessfullyCards}\n\t\t\t{@const _ =\n\t\t\t\t((localLoadedCards = loadedSuccessfullyCards),\n\t\t\t\t(filteredCards = loadedSuccessfullyCards),\n\t\t\t\thandleSearch())}\n\t\t\t<!-- Assign and initialize filter -->\n\t\t\t<div class=\"space-y-8\">\n\t\t\t\t{#each cardGroups as cardGroup (cardGroup[0].name)}\n\t\t\t\t\t<div class=\"space-y-2\">\n\t\t\t\t\t\t<h3 class=\"text-xl font-semibold\">{cardGroup[0].name}</h3>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclass=\"grid grid-cols-1 gap-4 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-6\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{#each cardGroup as card (card.id)}\n\t\t\t\t\t\t\t\t<div class=\"group relative\">\n\t\t\t\t\t\t\t\t\t{#if card.imageUrl}\n\t\t\t\t\t\t\t\t\t\t<img\n\t\t\t\t\t\t\t\t\t\t\tsrc={card.imageUrl}\n\t\t\t\t\t\t\t\t\t\t\talt={card.name}\n\t\t\t\t\t\t\t\t\t\t\tclass=\"h-auto w-full cursor-pointer rounded-lg shadow-md transition-shadow hover:shadow-lg\"\n\t\t\t\t\t\t\t\t\t\t\tloading=\"lazy\"\n\t\t\t\t\t\t\t\t\t\t/>\n\n\t\t\t\t\t\t\t\t\t\t<!-- Deck Building Overlay -->\n\t\t\t\t\t\t\t\t\t\t{#if selectedAction === 'create'}\n\t\t\t\t\t\t\t\t\t\t\t{@const quantity = getCardQuantity(card.id)}\n\t\t\t\t\t\t\t\t\t\t\t{@const canAdd = canAddCard(card.id)}\n\t\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\t\tclass=\"bg-opacity-0 group-hover:bg-opacity-40 absolute inset-0 flex items-center justify-center rounded-lg bg-black transition-all\"\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"opacity-0 transition-opacity group-hover:opacity-100\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t{#if quantity > 0}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclass=\"mb-2 rounded-full bg-white px-3 py-1 text-center text-sm font-medium\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{quantity} in deck\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{/if}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t{#if canAdd}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonclick={() => handleAddCard(card.id)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclass=\"rounded-full bg-blue-600 p-2 text-white hover:bg-blue-700\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Plus class=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"rounded-full bg-gray-600 p-2 text-white\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<X class=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{/if}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t{#if quantity > 0}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonclick={() => handleRemoveCard(card.id)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclass=\"ml-2 rounded-full bg-red-600 p-2 text-white hover:bg-red-700\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<X class=\"h-4 w-4\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t{/if}\n\n\t\t\t\t\t\t\t\t\t\t<!-- Card Info Overlay -->\n\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\tclass=\"bg-opacity-0 group-hover:bg-opacity-20 absolute inset-0 flex items-end rounded-lg bg-black p-2 transition-all\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\t\tclass=\"bg-opacity-70 rounded bg-black px-2 py-1 text-xs text-white opacity-0 transition-opacity group-hover:opacity-100\"\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t{card.faction}  {card.rarity}\n\t\t\t\t\t\t\t\t\t\t\t\t{#if card.id.includes('_R1')}\n\t\t\t\t\t\t\t\t\t\t\t\t\t(Transform 1)\n\t\t\t\t\t\t\t\t\t\t\t\t{:else if card.id.includes('_R2')}\n\t\t\t\t\t\t\t\t\t\t\t\t\t(Transform 2)\n\t\t\t\t\t\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t\t\t\t\t\t(Base)\n\t\t\t\t\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\t\tclass=\"flex aspect-[2.5/3.5] w-full items-center justify-center rounded-lg bg-gray-200 text-gray-500\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\tNo Image\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t{/each}\n\t\t\t</div>\n\n\t\t\t{#if filteredCards.length === 0 && localLoadedCards.length > 0}\n\t\t\t\t<div class=\"flex items-center justify-center py-12\">\n\t\t\t\t\t<div class=\"text-muted-foreground\">No cards found matching your search.</div>\n\t\t\t\t</div>\n\t\t\t{/if}\n\t\t{:catch error}\n\t\t\t<div class=\"flex items-center justify-center py-12 text-red-500\">\n\t\t\t\t<AlertCircle class=\"mr-2 h-8 w-8\" />\n\t\t\t\t<p>Error loading cards: {error.message}</p>\n\t\t\t</div>\n\t\t{/await}\n\t</div>\n</div>\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/routes/decks/+page.svelte",
		"messages": [
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'confirm' is not defined.",
				"line": 138,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 138,
				"endColumn": 17
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n\timport { onMount } from 'svelte';\n\timport { goto } from '$app/navigation';\n\timport { useMachine } from '@xstate/svelte';\n\timport { deckMachine } from '$lib/state/deckMachine';\n\timport { PlusCircle, Trash2, Edit3, Play } from 'lucide-svelte';\n\timport Button from '$components/ui/button/Button.svelte';\n\timport Card from '$components/ui/card/Card.svelte';\n\timport CardContent from '$components/ui/card/CardContent.svelte';\n\timport CardDescription from '$components/ui/card/CardDescription.svelte';\n\timport CardFooter from '$components/ui/card/CardFooter.svelte';\n\timport CardHeader from '$components/ui/card/CardHeader.svelte';\n\timport CardTitle from '$components/ui/card/CardTitle.svelte';\n\n\tconst { snapshot, send } = useMachine(deckMachine);\n\n\t// No need for isMounted, machine's isLoading and state should suffice.\n\tonMount(() => {\n\t\t// If the machine is in a state where decks are already loaded (e.g. navigating back),\n\t\t// we might not need to send LOAD_DECKS. However, sending it is usually harmless\n\t\t// as the machine can decide if a reload is necessary or if it's already loading.\n\t\t// The machine now auto-loads on initialization. This dispatch might be for a manual refresh.\n\t\tif ($snapshot.matches('idle')) {\n\t\t\t// Only send if idle, otherwise it's already loading/initialized\n\t\t\t// send({ type: 'LOAD_DECKS' }); // Machine now loads on init. This could be for a manual refresh button.\n\t\t}\n\t});\n\n\tfunction handleCreateNewDeck() {\n\t\tgoto('/decks/create');\n\t}\n\n\tfunction handleEditDeck(deckId: string) {\n\t\tgoto(`/decks/edit/${deckId}`);\n\t}\n\n\tfunction handlePlayGame(deckId: string) {\n\t\tgoto(`/play/${deckId}`);\n\t}\n\n\tfunction handleDeleteDeck(deckId: string) {\n\t\tsend({ type: 'DELETE_DECK', deckId });\n\t}\n\n\t// Computed deck list items\n\t$: deckListItems = $snapshot.context.decks\n\t\t.map((deck) => ({\n\t\t\tid: deck.id,\n\t\t\tname: deck.name,\n\t\t\tcardCount: deck.cards.reduce((sum, card) => sum + card.quantity, 0),\n\t\t\tupdatedAt: deck.updatedAt,\n\t\t\tformat: deck.format // Use actual deck format\n\t\t}))\n\t\t.sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());\n\n\t$: isLoading =\n\t\t$snapshot.matches('initializing') ||\n\t\t$snapshot.matches('deleting') ||\n\t\t$snapshot.context.isLoading;\n\t$: canDisplayDecks = $snapshot.matches('idle') || $snapshot.matches('editing'); // States where decks are loaded\n</script>\n\n<svelte:head>\n\t<title>Deck Builder - AlterDeck</title>\n\t<meta name=\"description\" content=\"Create, manage, and refine your Altered TCG decks\" />\n</svelte:head>\n\n<div class=\"space-y-8\">\n\t<section class=\"flex flex-col items-center justify-between gap-4 sm:flex-row\">\n\t\t<div>\n\t\t\t<h1 class=\"font-headline text-primary text-4xl font-bold tracking-tight sm:text-5xl\">\n\t\t\t\tDeck Builder\n\t\t\t</h1>\n\t\t\t<p class=\"text-muted-foreground mt-2 text-lg\">\n\t\t\t\tCreate, manage, and refine your Altered TCG decks.\n\t\t\t</p>\n\t\t</div>\n\t\t<Button\n\t\t\ton:click={handleCreateNewDeck}\n\t\t\tclass=\"bg-accent text-accent-foreground hover:bg-accent/90\"\n\t\t>\n\t\t\t<PlusCircle class=\"mr-2 h-5 w-5\" /> Create New Deck\n\t\t</Button>\n\t</section>\n\n\t{#if isLoading}\n\t\t<div class=\"p-10 text-center\">Loading decks...</div>\n\t{:else if deckListItems.length === 0 && canDisplayDecks}\n\t\t<Card class=\"py-12 text-center shadow-lg\">\n\t\t\t<CardHeader>\n\t\t\t\t<CardTitle class=\"text-muted-foreground text-2xl\">No Decks Yet</CardTitle>\n\t\t\t</CardHeader>\n\t\t\t<CardContent>\n\t\t\t\t<p>Start building your first deck to see it here.</p>\n\t\t\t\t<Button\n\t\t\t\t\ton:click={handleCreateNewDeck}\n\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\tclass=\"border-primary text-primary hover:bg-primary/10 mt-6\"\n\t\t\t\t>\n\t\t\t\t\tCreate Your First Deck\n\t\t\t\t</Button>\n\t\t\t</CardContent>\n\t\t</Card>\n\t{:else}\n\t\t<div class=\"grid grid-cols-1 gap-6 md:grid-cols-2 lg:grid-cols-3\">\n\t\t\t{#each deckListItems as deck (deck.id)}\n\t\t\t\t<Card\n\t\t\t\t\tclass=\"hover:shadow-primary/30 flex flex-col shadow-lg transition-shadow duration-300\"\n\t\t\t\t>\n\t\t\t\t\t<CardHeader>\n\t\t\t\t\t\t<div class=\"flex items-start justify-between\">\n\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t<CardTitle class=\"font-headline text-xl\">{deck.name}</CardTitle>\n\t\t\t\t\t\t\t\t<CardDescription>{deck.cardCount} cards - Format: {deck.format}</CardDescription>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</CardHeader>\n\t\t\t\t\t<CardContent class=\"flex-grow\">\n\t\t\t\t\t\t<p class=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\tLast updated: {new Date(deck.updatedAt).toLocaleDateString()}\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</CardContent>\n\t\t\t\t\t<CardFooter class=\"flex justify-end gap-2\">\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\ton:click={() => handlePlayGame(deck.id)}\n\t\t\t\t\t\t\tvariant=\"default\"\n\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\tclass=\"bg-primary text-primary-foreground hover:bg-primary/90\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Play class=\"mr-1 h-4 w-4\" /> Play\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button on:click={() => handleEditDeck(deck.id)} variant=\"outline\" size=\"sm\">\n\t\t\t\t\t\t\t<Edit3 class=\"mr-1 h-4 w-4\" /> Edit\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\ton:click={() => {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tconfirm(\n\t\t\t\t\t\t\t\t\t\t`Are you sure you want to delete \"${deck.name}\"? This action cannot be undone.`\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\thandleDeleteDeck(deck.id);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\tvariant=\"destructive\"\n\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Trash2 class=\"mr-1 h-4 w-4\" /> Delete\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</CardFooter>\n\t\t\t\t</Card>\n\t\t\t{/each}\n\t\t</div>\n\t{/if}\n\n\t<!-- Error State -->\n\t<!-- Don't show general error during initial load if specific error UI exists or handled by errorLoading state -->\n\t{#if $snapshot.context.error && !$snapshot.matches('initializing')}\n\t\t<div class=\"bg-destructive/10 border-destructive/20 text-destructive rounded-lg border p-4\">\n\t\t\tError: {$snapshot.context.error}\n\t\t</div>\n\t{/if}\n\n\t{#if $snapshot.matches('errorLoading')}\n\t\t<div class=\"bg-destructive/10 border-destructive/20 text-destructive rounded-lg border p-4\">\n\t\t\tFailed to load decks. Please try again. Message: {$snapshot.context.error}\n\t\t</div>\n\t{/if}\n</div>\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/routes/decks/create/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/routes/decks/edit/[deckId]/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/routes/play/[deckId]/+page.svelte",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'beforeUpdate' is defined but never used.",
				"line": 2,
				"column": 20,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 2,
				"endColumn": 32
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'handlePlayCard' is defined but never used.",
				"line": 44,
				"column": 11,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 44,
				"endColumn": 25
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'handleSelectCard' is defined but never used.",
				"line": 50,
				"column": 11,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 50,
				"endColumn": 27
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'selectedCard' is defined but never used.",
				"line": 58,
				"column": 5,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 58,
				"endColumn": 17
			}
		],
		"suppressedMessages": [],
		"errorCount": 4,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n\timport { onMount, beforeUpdate } from 'svelte';\n\timport { page } from '$app/stores';\n\timport { goto } from '$app/navigation';\n\timport { useMachine } from '@xstate/svelte';\n\timport { gameMachine } from '$lib/state/gameMachine';\n\timport { Loader2, ArrowLeft, Zap, BookOpen, Box } from 'lucide-svelte';\n\timport Button from '$components/ui/button/Button.svelte';\n\timport Card from '$components/ui/card/Card.svelte';\n\n\t$: deckId = $page.params.deckId;\n\n\tconst { snapshot, send } = useMachine(gameMachine);\n\n\tlet isLoading = true;\n\tlet error: string | null = null;\n\n\tonMount(() => {\n\t\tif (deckId) {\n\t\t\t// Initialize game with player IDs\n\t\t\tsend({ type: 'INITIALIZE_GAME', players: ['player1', 'player2'] });\n\t\t\t// Start game with deck\n\t\t\tsend({ type: 'START_GAME', deckId });\n\t\t\tisLoading = false;\n\t\t} else {\n\t\t\terror = 'No deck ID provided';\n\t\t\tisLoading = false;\n\t\t}\n\t});\n\n\tfunction handleSurrender() {\n\t\tsend({ type: 'END_GAME' });\n\t\tgoto('/decks');\n\t}\n\n\tfunction handlePassTurn() {\n\t\tsend({ type: 'PASS_TURN' });\n\t}\n\n\tfunction handleAdvancePhase() {\n\t\tsend({ type: 'ADVANCE_PHASE' });\n\t}\n\n\tfunction handlePlayCard(cardId: string) {\n\t\tif ($snapshot.context.currentPlayer) {\n\t\t\tsend({ type: 'PLAY_CARD', cardId, playerId: $snapshot.context.currentPlayer });\n\t\t}\n\t}\n\n\tfunction handleSelectCard(cardId: string) {\n\t\tsend({ type: 'SELECT_CARD', cardId });\n\t}\n\n\t// Reactive variables\n\t$: currentPhase = $snapshot.context.currentPhase;\n\t$: currentPlayer = $snapshot.context.currentPlayer;\n\t$: currentDay = $snapshot.context.currentDay;\n\t$: selectedCard = $snapshot.context.selectedCard;\n\t$: gameError = $snapshot.context.error;\n\t$: isMyTurn = currentPlayer === 'player1'; // Assuming player1 is the user\n</script>\n\n<svelte:head>\n\t<title>Play Game - AlterDeck</title>\n\t<meta name=\"description\" content=\"Play Altered TCG with your deck\" />\n</svelte:head>\n\n{#if isLoading}\n\t<div class=\"bg-background text-foreground flex h-screen flex-col items-center justify-center\">\n\t\t<Loader2 class=\"text-primary mb-4 h-16 w-16 animate-spin\" />\n\t\t<p class=\"text-xl\">Loading Game...</p>\n\t</div>\n{:else if error || gameError}\n\t<div class=\"bg-background text-foreground flex h-screen flex-col items-center justify-center p-4\">\n\t\t<Card class=\"bg-card text-card-foreground w-full max-w-md p-6 shadow-lg\">\n\t\t\t<h2 class=\"text-destructive mb-2 text-2xl font-bold\">Game Error</h2>\n\t\t\t<p class=\"text-muted-foreground mb-4\">{error || gameError}</p>\n\t\t\t<Button variant=\"outline\" on:click={() => goto('/decks')}>\n\t\t\t\t<ArrowLeft class=\"mr-2 h-4 w-4\" /> Back to Decks\n\t\t\t</Button>\n\t\t</Card>\n\t</div>\n{:else}\n\t<div class=\"text-foreground flex h-screen flex-col overflow-hidden bg-zinc-800\">\n\t\t<!-- Game Status Bar -->\n\t\t<div\n\t\t\tclass=\"flex h-10 shrink-0 items-center justify-between border-b border-zinc-700 bg-zinc-900 px-4 text-xs\"\n\t\t>\n\t\t\t<div>Day: {currentDay} | Phase: {currentPhase}</div>\n\t\t\t<div class=\"font-bold {isMyTurn ? 'animate-pulse text-green-400' : 'text-red-400'}\">\n\t\t\t\t{isMyTurn ? 'YOUR TURN' : \"OPPONENT'S TURN\"}\n\t\t\t</div>\n\t\t\t<div class=\"w-1/3 truncate text-right\">\n\t\t\t\t{#if gameError}\n\t\t\t\t\t<span class=\"text-destructive text-xs\">{gameError}</span>\n\t\t\t\t{/if}\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Game Board -->\n\t\t<div class=\"flex min-h-0 flex-1 flex-col space-y-1 p-1\">\n\t\t\t<!-- Opponent Area -->\n\t\t\t<div\n\t\t\t\tclass=\"flex min-h-0 flex-1 flex-col space-y-1 rounded border border-zinc-700 bg-zinc-900/50 p-1\"\n\t\t\t>\n\t\t\t\t<div class=\"flex h-24 shrink-0 items-center justify-center\">\n\t\t\t\t\t<!-- Opponent Hero Spot -->\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex h-20 w-16 items-center justify-center rounded border border-zinc-600 bg-zinc-800\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<span class=\"text-muted-foreground text-xs\">Hero</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"flex flex-1 items-stretch space-x-1 p-1\">\n\t\t\t\t\t<!-- Opponent Board Zones -->\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex flex-1 flex-col items-center justify-center rounded border border-zinc-600 bg-zinc-800/50 p-2\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<span class=\"text-muted-foreground text-xs\">Reserve</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex flex-1 flex-col items-center justify-center rounded border border-zinc-600 bg-zinc-800/50 p-2\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<span class=\"text-muted-foreground text-xs\">Expedition</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex flex-1 flex-col items-center justify-center rounded border border-zinc-600 bg-zinc-800/50 p-2\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<span class=\"text-muted-foreground text-xs\">Landmarks</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"flex h-28 shrink-0 items-center justify-between space-x-2 p-1\">\n\t\t\t\t\t<!-- Opponent Stats -->\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex h-full flex-1 flex-col items-center justify-center rounded bg-black/30 p-1 text-center\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<Zap class=\"h-4 w-4 text-yellow-400\" />\n\t\t\t\t\t\t<p class=\"mt-1 text-sm font-semibold\">0/0</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<!-- Opponent Hand -->\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex h-full flex-[2_2_0%] items-center justify-center overflow-hidden rounded border border-zinc-600 bg-zinc-800/50\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<span class=\"text-muted-foreground text-xs\">Opponent Hand</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<!-- Opponent Deck Info -->\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex h-full flex-1 flex-col items-center justify-center rounded bg-black/30 p-1 text-center text-xs\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<div class=\"flex items-center\">\n\t\t\t\t\t\t\t<BookOpen class=\"mr-1 h-4 w-4 text-blue-400\" />Deck: 30\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"mt-1 flex items-center\">\n\t\t\t\t\t\t\t<Box class=\"mr-1 h-4 w-4 text-gray-500\" />Discard: 0\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<!-- Adventure Zone -->\n\t\t\t<div\n\t\t\t\tclass=\"flex h-12 shrink-0 items-center justify-center rounded border border-zinc-600 bg-zinc-700/30 p-1\"\n\t\t\t>\n\t\t\t\t<p class=\"text-muted-foreground text-xs\">Adventure Zone</p>\n\t\t\t</div>\n\n\t\t\t<!-- Player Area (reversed layout) -->\n\t\t\t<div\n\t\t\t\tclass=\"flex min-h-0 flex-1 flex-col-reverse space-y-1 space-y-reverse rounded border border-zinc-700 bg-zinc-900/50 p-1\"\n\t\t\t>\n\t\t\t\t<div class=\"flex h-24 shrink-0 items-center justify-center\">\n\t\t\t\t\t<!-- Player Hero Spot -->\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex h-20 w-16 items-center justify-center rounded border border-zinc-600 bg-zinc-800\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<span class=\"text-muted-foreground text-xs\">Hero</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"flex flex-1 items-stretch space-x-1 p-1\">\n\t\t\t\t\t<!-- Player Board Zones -->\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex flex-1 flex-col items-center justify-center rounded border border-zinc-600 bg-zinc-800/50 p-2\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<span class=\"text-muted-foreground text-xs\">Reserve</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex flex-1 cursor-pointer flex-col items-center justify-center rounded border border-zinc-600 bg-zinc-800/50 p-2 hover:bg-zinc-700/50\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<span class=\"text-muted-foreground text-xs\">Expedition</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex flex-1 cursor-pointer flex-col items-center justify-center rounded border border-zinc-600 bg-zinc-800/50 p-2 hover:bg-zinc-700/50\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<span class=\"text-muted-foreground text-xs\">Landmarks</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"flex h-28 shrink-0 items-center justify-between space-x-2 p-1\">\n\t\t\t\t\t<!-- Player Stats -->\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex h-full flex-1 flex-col items-center justify-center rounded bg-black/30 p-1 text-center\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<Zap class=\"h-4 w-4 text-yellow-400\" />\n\t\t\t\t\t\t<p class=\"mt-1 text-sm font-semibold\">3/3</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<!-- Player Hand -->\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex h-full flex-[2_2_0%] items-center justify-center overflow-hidden rounded border border-zinc-600 bg-zinc-800/50\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<span class=\"text-muted-foreground text-xs\">Your Hand (6 cards)</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<!-- Player Deck Info -->\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex h-full flex-1 flex-col items-center justify-center rounded bg-black/30 p-1 text-center text-xs\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<div class=\"flex items-center\">\n\t\t\t\t\t\t\t<BookOpen class=\"mr-1 h-4 w-4 text-blue-400\" />Deck: 24\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"mt-1 flex items-center\">\n\t\t\t\t\t\t\t<Box class=\"mr-1 h-4 w-4 text-gray-500\" />Discard: 0\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\n\t\t<!-- Action Bar -->\n\t\t<div\n\t\t\tclass=\"flex h-12 shrink-0 items-center justify-center space-x-4 border-t border-zinc-700 bg-zinc-900 p-1\"\n\t\t>\n\t\t\t<Button on:click={handlePassTurn} disabled={!isMyTurn} variant=\"destructive\" size=\"sm\">\n\t\t\t\tPass Turn\n\t\t\t</Button>\n\t\t\t<Button on:click={handleAdvancePhase} variant=\"secondary\" size=\"sm\">Advance Phase</Button>\n\t\t\t<Button on:click={handleSurrender} variant=\"outline\" size=\"sm\">\n\t\t\t\t<ArrowLeft class=\"mr-2 h-4 w-4\" /> Surrender\n\t\t\t</Button>\n\t\t</div>\n\t</div>\n{/if}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/routes/simple/+layout.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/routes/simple/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/routes/test/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/src/types/index.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/card-playing.spec.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 262,
				"column": 46,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 262,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [9331, 9334], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [9331, 9334], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 289,
				"column": 37,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 289,
				"endColumn": 40,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [10207, 10210], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [10207, 10210], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 305,
				"column": 42,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 305,
				"endColumn": 45,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [10663, 10666], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [10663, 10666], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 3,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { test, expect } from '@playwright/test';\n\ntest.describe('Card Playing Mechanics - Rule 5.1', () => {\n\ttest.beforeEach(async ({ page }) => {\n\t\tawait page.goto('/');\n\n\t\t// Set up a test deck with various card types\n\t\tawait page.click('text=Browse Cards');\n\t\tawait page.waitForSelector('[data-testid=\"card-grid\"]', { timeout: 10000 });\n\t\tawait page.click('text=Create Deck');\n\t\tawait page.fill('input[placeholder=\"Enter deck name\"]', 'Card Play Test Deck');\n\t\tawait page.selectOption('select', 'Standard');\n\n\t\t// Add diverse cards for testing\n\t\tconst cards = page.locator('[data-testid=\"card-item\"]');\n\t\tfor (let i = 0; i < 40; i++) {\n\t\t\tawait cards.nth(i).click();\n\t\t}\n\n\t\tawait page.click('button:has-text(\"Save Deck\")');\n\t\tawait page.click('text=My Decks');\n\t\tawait page.click('button:has-text(\"Play\")');\n\t\tawait page.waitForSelector('[data-testid=\"game-board\"]', { timeout: 15000 });\n\t});\n\n\ttest('Rule 5.1.2: Card Playing Process', async ({ page }) => {\n\t\t// Navigate to Afternoon phase when cards can be played\n\t\tawait navigateToAfternoonTurn(page);\n\n\t\tconst handCards = await page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]');\n\t\tconst initialHandCount = await handCards.count();\n\n\t\tif (initialHandCount > 0) {\n\t\t\t// Rule 5.1.2.a-f: Validation and Declaration of Intent\n\t\t\tconst cardToPlay = handCards.first();\n\t\t\tawait cardToPlay.click();\n\n\t\t\t// Card should be selected (Rule 5.1.2.g: Intent declared)\n\t\t\texpect(await cardToPlay.getAttribute('class')).toContain('selected');\n\n\t\t\t// Rule 5.1.2.h: Check if card can be played\n\t\t\tconst manaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\t\tconst availableMana = parseInt(manaDisplay?.split('/')[0] || '0');\n\n\t\t\t// Get card cost (if visible)\n\t\t\tconst cardCost = await cardToPlay.locator('[data-testid=\"card-cost\"]').textContent();\n\t\t\tconst cost = parseInt(cardCost || '0');\n\n\t\t\tif (cost <= availableMana) {\n\t\t\t\t// Rule 5.1.2.i: Play the card\n\t\t\t\tconst expeditionZone = page.locator('[data-testid=\"expedition-zone\"][data-owner=\"self\"]');\n\t\t\t\tawait expeditionZone.click();\n\n\t\t\t\tawait page.waitForTimeout(1000);\n\n\t\t\t\t// Verify card was played successfully\n\t\t\t\tconst newHandCount = await handCards.count();\n\t\t\t\texpect(newHandCount).toBe(initialHandCount - 1);\n\n\t\t\t\t// Verify mana was spent\n\t\t\t\tconst newManaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\t\t\tconst newAvailableMana = parseInt(newManaDisplay?.split('/')[0] || '0');\n\t\t\t\texpect(newAvailableMana).toBe(availableMana - cost);\n\n\t\t\t\t// Rule 5.1.2.j: Turn advances after playing card\n\t\t\t\tawait page.waitForTimeout(1000);\n\t\t\t\tconst turnIndicator = await page.locator('[data-testid=\"turn-indicator\"]').textContent();\n\t\t\t\texpect(turnIndicator).toContain(\"OPPONENT'S TURN\");\n\t\t\t}\n\t\t}\n\t});\n\n\ttest('Rule 5.1.3: Character Card Placement', async ({ page }) => {\n\t\tawait navigateToAfternoonTurn(page);\n\n\t\t// Find a Character card in hand\n\t\tconst characterCard = await findCardByType(page, 'Character');\n\t\tif (characterCard) {\n\t\t\tawait characterCard.click();\n\n\t\t\t// Rule 5.1.3: Characters go to Expedition zone\n\t\t\tconst expeditionZone = page.locator('[data-testid=\"expedition-zone\"][data-owner=\"self\"]');\n\t\t\tconst initialExpeditionCount = await expeditionZone.locator('[data-testid=\"card\"]').count();\n\n\t\t\tawait expeditionZone.click();\n\t\t\tawait page.waitForTimeout(1000);\n\n\t\t\tconst finalExpeditionCount = await expeditionZone.locator('[data-testid=\"card\"]').count();\n\t\t\texpect(finalExpeditionCount).toBe(initialExpeditionCount + 1);\n\t\t}\n\t});\n\n\ttest('Rule 5.1.4: Permanent Card Placement', async ({ page }) => {\n\t\tawait navigateToAfternoonTurn(page);\n\n\t\t// Test Landmark Permanent\n\t\tconst landmarkCard = await findCardByType(page, 'Landmark');\n\t\tif (landmarkCard) {\n\t\t\tawait landmarkCard.click();\n\n\t\t\t// Landmark Permanents go to Landmark zone\n\t\t\tconst landmarkZone = page.locator('[data-testid=\"landmark-zone\"][data-owner=\"self\"]');\n\t\t\tconst initialLandmarkCount = await landmarkZone.locator('[data-testid=\"card\"]').count();\n\n\t\t\tawait landmarkZone.click();\n\t\t\tawait page.waitForTimeout(1000);\n\n\t\t\tconst finalLandmarkCount = await landmarkZone.locator('[data-testid=\"card\"]').count();\n\t\t\texpect(finalLandmarkCount).toBe(initialLandmarkCount + 1);\n\t\t}\n\n\t\t// Test Expedition Permanent\n\t\tconst expeditionPermanent = await findCardByType(page, 'Expedition Permanent');\n\t\tif (expeditionPermanent) {\n\t\t\tawait expeditionPermanent.click();\n\n\t\t\t// Expedition Permanents go to Expedition zone\n\t\t\tconst expeditionZone = page.locator('[data-testid=\"expedition-zone\"][data-owner=\"self\"]');\n\t\t\tconst initialExpeditionCount = await expeditionZone.locator('[data-testid=\"card\"]').count();\n\n\t\t\tawait expeditionZone.click();\n\t\t\tawait page.waitForTimeout(1000);\n\n\t\t\tconst finalExpeditionCount = await expeditionZone.locator('[data-testid=\"card\"]').count();\n\t\t\texpect(finalExpeditionCount).toBe(initialExpeditionCount + 1);\n\t\t}\n\t});\n\n\ttest('Rule 5.1.5: Spell Card Resolution', async ({ page }) => {\n\t\tawait navigateToAfternoonTurn(page);\n\n\t\t// Find a Spell card in hand\n\t\tconst spellCard = await findCardByType(page, 'Spell');\n\t\tif (spellCard) {\n\t\t\tconst initialReserveCount = await page\n\t\t\t\t.locator('[data-testid=\"reserve-zone\"] [data-testid=\"card\"]')\n\t\t\t\t.count();\n\n\t\t\tawait spellCard.click();\n\n\t\t\t// Spells should auto-play (no target selection needed)\n\t\t\tawait page.waitForTimeout(2000);\n\n\t\t\t// Rule 5.2.4.b: Non-Fleeting spells go to Reserve after resolution\n\t\t\tconst finalReserveCount = await page\n\t\t\t\t.locator('[data-testid=\"reserve-zone\"] [data-testid=\"card\"]')\n\t\t\t\t.count();\n\t\t\texpect(finalReserveCount).toBe(initialReserveCount + 1);\n\t\t}\n\t});\n\n\ttest('Rule 5.1.6: Cost Payment Validation', async ({ page }) => {\n\t\tawait navigateToAfternoonTurn(page);\n\n\t\t// Test insufficient mana scenario\n\t\tconst handCards = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]');\n\t\tconst cardCount = await handCards.count();\n\n\t\tif (cardCount > 0) {\n\t\t\t// Try to find a high-cost card\n\t\t\tfor (let i = 0; i < Math.min(cardCount, 5); i++) {\n\t\t\t\tconst card = handCards.nth(i);\n\t\t\t\tconst costElement = card.locator('[data-testid=\"card-cost\"]');\n\t\t\t\tconst costText = await costElement.textContent();\n\t\t\t\tconst cost = parseInt(costText || '0');\n\n\t\t\t\tconst manaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\t\t\tconst availableMana = parseInt(manaDisplay?.split('/')[0] || '0');\n\n\t\t\t\tif (cost > availableMana) {\n\t\t\t\t\t// Try to play this card (should fail)\n\t\t\t\t\tawait card.click();\n\n\t\t\t\t\tconst expeditionZone = page.locator('[data-testid=\"expedition-zone\"][data-owner=\"self\"]');\n\t\t\t\t\tawait expeditionZone.click();\n\n\t\t\t\t\t// Card should still be in hand (payment failed)\n\t\t\t\t\tawait page.waitForTimeout(1000);\n\t\t\t\t\texpect(await card.isVisible()).toBe(true);\n\n\t\t\t\t\t// Error message should appear\n\t\t\t\t\tconst errorMessage = page.locator('[data-testid=\"error-message\"]');\n\t\t\t\t\texpect(await errorMessage.isVisible()).toBe(true);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\ttest('Rule 5.1.7: Targeting and Zone Validation', async ({ page }) => {\n\t\tawait navigateToAfternoonTurn(page);\n\n\t\tconst handCards = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]');\n\t\tconst cardCount = await handCards.count();\n\n\t\tif (cardCount > 0) {\n\t\t\tconst card = handCards.first();\n\t\t\tawait card.click();\n\n\t\t\t// Test invalid zone targeting\n\t\t\tconst wrongZone = page.locator('[data-testid=\"reserve-zone\"]');\n\t\t\tawait wrongZone.click();\n\n\t\t\t// Card should not be played to wrong zone\n\t\t\tawait page.waitForTimeout(1000);\n\t\t\texpect(await card.isVisible()).toBe(true);\n\n\t\t\t// Try correct zone\n\t\t\tconst correctZone = page.locator('[data-testid=\"expedition-zone\"][data-owner=\"self\"]');\n\t\t\tawait correctZone.click();\n\n\t\t\t// Card should be played successfully\n\t\t\tawait page.waitForTimeout(1000);\n\t\t\tconst newCardCount = await handCards.count();\n\t\t\texpect(newCardCount).toBe(cardCount - 1);\n\t\t}\n\t});\n\n\ttest('Rule 7.4.1.b: Cooldown Spell Mechanics', async ({ page }) => {\n\t\tawait navigateToAfternoonTurn(page);\n\n\t\t// Find a spell with Cooldown keyword\n\t\tconst cooldownSpell = await findCardWithKeyword(page, 'Cooldown');\n\t\tif (cooldownSpell) {\n\t\t\tawait cooldownSpell.click();\n\t\t\tawait page.waitForTimeout(2000);\n\n\t\t\t// Cooldown spells should enter Reserve exhausted\n\t\t\tconst reserveCards = page.locator('[data-testid=\"reserve-zone\"] [data-testid=\"card\"]');\n\t\t\tconst lastReserveCard = reserveCards.last();\n\n\t\t\t// Check if card has exhausted status\n\t\t\tconst cardClasses = await lastReserveCard.getAttribute('class');\n\t\t\texpect(cardClasses).toContain('exhausted');\n\t\t}\n\t});\n\n\ttest('Turn End After Card Play', async ({ page }) => {\n\t\tawait navigateToAfternoonTurn(page);\n\n\t\tconst initialTurn = await page.locator('[data-testid=\"turn-indicator\"]').textContent();\n\t\texpect(initialTurn).toContain('YOUR TURN');\n\n\t\t// Play a card\n\t\tconst handCard = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]').first();\n\t\tif (await handCard.isVisible()) {\n\t\t\tawait handCard.click();\n\n\t\t\tconst expeditionZone = page.locator('[data-testid=\"expedition-zone\"][data-owner=\"self\"]');\n\t\t\tawait expeditionZone.click();\n\n\t\t\t// Wait for turn to advance\n\t\t\tawait page.waitForTimeout(2000);\n\n\t\t\tconst newTurn = await page.locator('[data-testid=\"turn-indicator\"]').textContent();\n\t\t\texpect(newTurn).toContain(\"OPPONENT'S TURN\");\n\t\t}\n\t});\n});\n\n// Helper functions\nasync function navigateToAfternoonTurn(page: any) {\n\t// Navigate to Afternoon phase when it's the player's turn\n\twhile (true) {\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\tconst turnText = await page.locator('[data-testid=\"turn-indicator\"]').textContent();\n\n\t\tif (phaseText?.includes('Afternoon') && turnText?.includes('YOUR TURN')) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (phaseText?.includes('Morning')) {\n\t\t\tconst expandButton = page.locator('button:has-text(\"Skip Expand\")');\n\t\t\tif (await expandButton.isVisible()) {\n\t\t\t\tawait expandButton.click();\n\t\t\t} else {\n\t\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t\t}\n\t\t} else if (turnText?.includes(\"OPPONENT'S TURN\")) {\n\t\t\tawait page.waitForTimeout(2000); // Wait for opponent turn\n\t\t} else {\n\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t}\n\n\t\tawait page.waitForTimeout(1000);\n\t}\n}\n\nasync function findCardByType(page: any, cardType: string) {\n\tconst handCards = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]');\n\tconst count = await handCards.count();\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst card = handCards.nth(i);\n\t\tconst typeElement = card.locator('[data-testid=\"card-type\"]');\n\t\tconst typeText = await typeElement.textContent();\n\n\t\tif (typeText?.includes(cardType)) {\n\t\t\treturn card;\n\t\t}\n\t}\n\treturn null;\n}\n\nasync function findCardWithKeyword(page: any, keyword: string) {\n\tconst handCards = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]');\n\tconst count = await handCards.count();\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst card = handCards.nth(i);\n\t\tconst keywordElement = card.locator('[data-testid=\"card-keywords\"]');\n\t\tconst keywordText = await keywordElement.textContent();\n\n\t\tif (keywordText?.includes(keyword)) {\n\t\t\treturn card;\n\t\t}\n\t}\n\treturn null;\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/expand-mechanics.spec.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 275,
				"column": 45,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 275,
				"endColumn": 48,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [9989, 9992], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [9989, 9992], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 290,
				"column": 39,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 290,
				"endColumn": 42,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [10446, 10449], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [10446, 10449], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 2,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { test, expect } from '@playwright/test';\n\ntest.describe('Expand Mechanics - Rule 4.2.1.e', () => {\n\ttest.beforeEach(async ({ page }) => {\n\t\tawait page.goto('/');\n\n\t\t// Set up test deck\n\t\tawait page.click('text=Browse Cards');\n\t\tawait page.waitForSelector('[data-testid=\"card-grid\"]', { timeout: 10000 });\n\t\tawait page.click('text=Create Deck');\n\t\tawait page.fill('input[placeholder=\"Enter deck name\"]', 'Expand Test Deck');\n\t\tawait page.selectOption('select', 'Standard');\n\n\t\t// Add cards to deck\n\t\tconst cards = page.locator('[data-testid=\"card-item\"]');\n\t\tfor (let i = 0; i < 40; i++) {\n\t\t\tawait cards.nth(i).click();\n\t\t}\n\n\t\tawait page.click('button:has-text(\"Save Deck\")');\n\t\tawait page.click('text=My Decks');\n\t\tawait page.click('button:has-text(\"Play\")');\n\t\tawait page.waitForSelector('[data-testid=\"game-board\"]', { timeout: 15000 });\n\t});\n\n\ttest('Rule 4.2.1.e: Expand Availability in Morning Phase', async ({ page }) => {\n\t\t// Navigate to Day 2 Morning (Day 1 Morning is skipped)\n\t\tawait navigateToMorningPhase(page);\n\n\t\t// Verify expand button is available\n\t\tconst expandButton = page.locator('button:has-text(\"Expand Card\")');\n\t\texpect(await expandButton.isVisible()).toBe(true);\n\t\texpect(await expandButton.isEnabled()).toBe(true);\n\n\t\t// Verify skip expand button is also available\n\t\tconst skipButton = page.locator('button:has-text(\"Skip Expand\")');\n\t\texpect(await skipButton.isVisible()).toBe(true);\n\t\texpect(await skipButton.isEnabled()).toBe(true);\n\t});\n\n\ttest('Rule 4.2.1.e: Expand Card to Mana Zone', async ({ page }) => {\n\t\tawait navigateToMorningPhase(page);\n\n\t\tconst initialHandCount = await page\n\t\t\t.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]')\n\t\t\t.count();\n\t\tconst initialManaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\tconst initialManaMax = parseInt(initialManaDisplay?.split('/')[1] || '0');\n\n\t\tif (initialHandCount > 0) {\n\t\t\t// Click expand button\n\t\t\tawait page.click('button:has-text(\"Expand Card\")');\n\n\t\t\t// Select a card from hand\n\t\t\tconst handCard = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]').first();\n\t\t\tawait handCard.click();\n\n\t\t\tawait page.waitForTimeout(1000);\n\n\t\t\t// Verify card moved from hand to mana\n\t\t\tconst finalHandCount = await page\n\t\t\t\t.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]')\n\t\t\t\t.count();\n\t\t\texpect(finalHandCount).toBe(initialHandCount - 1);\n\n\t\t\t// Verify mana orb count increased\n\t\t\tconst finalManaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\t\tconst finalManaMax = parseInt(finalManaDisplay?.split('/')[1] || '0');\n\t\t\texpect(finalManaMax).toBe(initialManaMax + 1);\n\n\t\t\t// Rule 4.2.1.e: Mana Orb enters ready (not exhausted)\n\t\t\tconst finalManaCurrent = parseInt(finalManaDisplay?.split('/')[0] || '0');\n\t\t\texpect(finalManaCurrent).toBe(finalManaMax); // All mana should be available\n\t\t}\n\t});\n\n\ttest('Rule 4.2.1.e: Skip Expand Option', async ({ page }) => {\n\t\tawait navigateToMorningPhase(page);\n\n\t\tconst initialHandCount = await page\n\t\t\t.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]')\n\t\t\t.count();\n\t\tconst initialManaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\tconst initialManaMax = parseInt(initialManaDisplay?.split('/')[1] || '0');\n\n\t\t// Click skip expand\n\t\tawait page.click('button:has-text(\"Skip Expand\")');\n\n\t\tawait page.waitForTimeout(1000);\n\n\t\t// Verify hand count unchanged\n\t\tconst finalHandCount = await page\n\t\t\t.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]')\n\t\t\t.count();\n\t\texpect(finalHandCount).toBe(initialHandCount);\n\n\t\t// Verify mana unchanged\n\t\tconst finalManaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\tconst finalManaMax = parseInt(finalManaDisplay?.split('/')[1] || '0');\n\t\texpect(finalManaMax).toBe(initialManaMax);\n\n\t\t// Expand options should no longer be available\n\t\tconst expandButton = page.locator('button:has-text(\"Expand Card\")');\n\t\tconst skipButton = page.locator('button:has-text(\"Skip Expand\")');\n\t\texpect(await expandButton.isVisible()).toBe(false);\n\t\texpect(await skipButton.isVisible()).toBe(false);\n\t});\n\n\ttest('Expand Once Per Turn Restriction', async ({ page }) => {\n\t\tawait navigateToMorningPhase(page);\n\n\t\tconst initialHandCount = await page\n\t\t\t.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]')\n\t\t\t.count();\n\n\t\tif (initialHandCount > 1) {\n\t\t\t// Expand first card\n\t\t\tawait page.click('button:has-text(\"Expand Card\")');\n\t\t\tconst firstCard = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]').first();\n\t\t\tawait firstCard.click();\n\n\t\t\tawait page.waitForTimeout(1000);\n\n\t\t\t// Verify expand options are no longer available\n\t\t\tconst expandButton = page.locator('button:has-text(\"Expand Card\")');\n\t\t\tconst skipButton = page.locator('button:has-text(\"Skip Expand\")');\n\t\t\texpect(await expandButton.isVisible()).toBe(false);\n\t\t\texpect(await skipButton.isVisible()).toBe(false);\n\n\t\t\t// Verify only one card was moved\n\t\t\tconst finalHandCount = await page\n\t\t\t\t.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]')\n\t\t\t\t.count();\n\t\t\texpect(finalHandCount).toBe(initialHandCount - 1);\n\t\t}\n\t});\n\n\ttest('Expand Not Available Outside Morning Phase', async ({ page }) => {\n\t\t// Test in Noon phase\n\t\twhile (true) {\n\t\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\t\tif (phaseText?.includes('Noon')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t\tawait page.waitForTimeout(1000);\n\t\t}\n\n\t\tconst expandButton = page.locator('button:has-text(\"Expand Card\")');\n\t\tconst skipButton = page.locator('button:has-text(\"Skip Expand\")');\n\t\texpect(await expandButton.isVisible()).toBe(false);\n\t\texpect(await skipButton.isVisible()).toBe(false);\n\n\t\t// Test in Afternoon phase\n\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\tawait page.waitForTimeout(1000);\n\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\texpect(phaseText).toContain('Afternoon');\n\n\t\texpect(await expandButton.isVisible()).toBe(false);\n\t\texpect(await skipButton.isVisible()).toBe(false);\n\t});\n\n\ttest('Expand Resets Between Days', async ({ page }) => {\n\t\t// Test expand on Day 2\n\t\tawait navigateToMorningPhase(page);\n\n\t\tif ((await page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]').count()) > 0) {\n\t\t\tawait page.click('button:has-text(\"Expand Card\")');\n\t\t\tconst handCard = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]').first();\n\t\t\tawait handCard.click();\n\n\t\t\tawait page.waitForTimeout(1000);\n\n\t\t\t// Expand should no longer be available\n\t\t\tconst expandButton = page.locator('button:has-text(\"Expand Card\")');\n\t\t\texpect(await expandButton.isVisible()).toBe(false);\n\t\t}\n\n\t\t// Advance to Day 3 Morning\n\t\tawait advanceToNextDay(page);\n\t\tawait navigateToMorningPhase(page);\n\n\t\t// Expand should be available again\n\t\tconst expandButton = page.locator('button:has-text(\"Expand Card\")');\n\t\tconst skipButton = page.locator('button:has-text(\"Skip Expand\")');\n\t\texpect(await expandButton.isVisible()).toBe(true);\n\t\texpect(await skipButton.isVisible()).toBe(true);\n\t});\n\n\ttest('Expand with Empty Hand', async ({ page }) => {\n\t\tawait navigateToMorningPhase(page);\n\n\t\t// Simulate empty hand scenario (if possible)\n\t\tconst handCount = await page\n\t\t\t.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]')\n\t\t\t.count();\n\n\t\tif (handCount === 0) {\n\t\t\t// Expand button should still be visible but disabled\n\t\t\tconst expandButton = page.locator('button:has-text(\"Expand Card\")');\n\t\t\texpect(await expandButton.isVisible()).toBe(true);\n\t\t\texpect(await expandButton.isEnabled()).toBe(false);\n\n\t\t\t// Skip should still work\n\t\t\tconst skipButton = page.locator('button:has-text(\"Skip Expand\")');\n\t\t\texpect(await skipButton.isVisible()).toBe(true);\n\t\t\texpect(await skipButton.isEnabled()).toBe(true);\n\n\t\t\tawait skipButton.click();\n\n\t\t\t// Options should disappear after skip\n\t\t\texpect(await expandButton.isVisible()).toBe(false);\n\t\t\texpect(await skipButton.isVisible()).toBe(false);\n\t\t}\n\t});\n\n\ttest('Expand UI State Management', async ({ page }) => {\n\t\tawait navigateToMorningPhase(page);\n\n\t\t// Test expand button interaction\n\t\tawait page.click('button:has-text(\"Expand Card\")');\n\n\t\t// Cards in hand should become selectable for expand\n\t\tconst handCards = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]');\n\t\tconst firstCard = handCards.first();\n\n\t\tif (await firstCard.isVisible()) {\n\t\t\t// Click on a card\n\t\t\tawait firstCard.click();\n\n\t\t\t// Card should be selected or action should complete\n\t\t\tawait page.waitForTimeout(1000);\n\n\t\t\t// Verify expand completed - buttons should disappear\n\t\t\tconst expandButton = page.locator('button:has-text(\"Expand Card\")');\n\t\t\tconst skipButton = page.locator('button:has-text(\"Skip Expand\")');\n\t\t\texpect(await expandButton.isVisible()).toBe(false);\n\t\t\texpect(await skipButton.isVisible()).toBe(false);\n\t\t}\n\t});\n\n\ttest('Multiple Players Expand Mechanics', async ({ page }) => {\n\t\tawait navigateToMorningPhase(page);\n\n\t\t// Player 1 expand\n\t\tif ((await page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]').count()) > 0) {\n\t\t\tawait page.click('button:has-text(\"Expand Card\")');\n\t\t\tconst handCard = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]').first();\n\t\t\tawait handCard.click();\n\n\t\t\tawait page.waitForTimeout(1000);\n\t\t}\n\n\t\t// Wait for opponent's expand decision (simulated)\n\t\t// In a real game, both players would need to make expand decisions\n\t\t// For testing, we verify that the phase doesn't advance until both players decide\n\n\t\t// Phase should eventually advance to Noon after both players decide\n\t\tawait page.waitForFunction(\n\t\t\t() => {\n\t\t\t\tconst phaseElement = document.querySelector('[data-testid=\"phase-display\"]');\n\t\t\t\treturn phaseElement?.textContent?.includes('Noon');\n\t\t\t},\n\t\t\t{ timeout: 10000 }\n\t\t);\n\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\texpect(phaseText).toContain('Noon');\n\t});\n});\n\n// Helper functions\nasync function navigateToMorningPhase(page: any) {\n\t// Navigate to a Morning phase (Day 2+)\n\twhile (true) {\n\t\tconst dayText = await page.locator('[data-testid=\"day-display\"]').textContent();\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\n\t\tif (phaseText?.includes('Morning') && !dayText?.includes('Day: 1')) {\n\t\t\tbreak;\n\t\t}\n\n\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\tawait page.waitForTimeout(1000);\n\t}\n}\n\nasync function advanceToNextDay(page: any) {\n\t// Advance through all phases to reach the next day\n\twhile (true) {\n\t\tconst currentDay = await page.locator('[data-testid=\"day-display\"]').textContent();\n\t\tconst dayNumber = parseInt(currentDay?.match(/Day: (\\d+)/)?.[1] || '1');\n\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\n\t\tif (phaseText?.includes('Afternoon')) {\n\t\t\t// Handle turn-based play in Afternoon\n\t\t\tconst turnText = await page.locator('[data-testid=\"turn-indicator\"]').textContent();\n\t\t\tif (turnText?.includes('YOUR TURN')) {\n\t\t\t\tawait page.click('button:has-text(\"Pass Turn\")');\n\t\t\t} else {\n\t\t\t\tawait page.waitForTimeout(1000);\n\t\t\t}\n\t\t} else {\n\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t}\n\n\t\tawait page.waitForTimeout(1000);\n\n\t\t// Check if we've advanced to the next day\n\t\tconst newDay = await page.locator('[data-testid=\"day-display\"]').textContent();\n\t\tconst newDayNumber = parseInt(newDay?.match(/Day: (\\d+)/)?.[1] || '1');\n\n\t\tif (newDayNumber > dayNumber) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/game-engine.spec.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/phase-transitions.spec.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'currentDay' is assigned a value but never used.",
				"line": 94,
				"column": 4,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 94,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'expeditionCards' is assigned a value but never used.",
				"line": 149,
				"column": 9,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 149,
				"endColumn": 24
			}
		],
		"suppressedMessages": [],
		"errorCount": 2,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { test, expect } from '@playwright/test';\n\ntest.describe('Phase Transitions - Rules Compliance', () => {\n\ttest.beforeEach(async ({ page }) => {\n\t\tawait page.goto('/');\n\n\t\t// Create and set up a test deck\n\t\tawait page.click('text=Browse Cards');\n\t\tawait page.waitForSelector('[data-testid=\"card-grid\"]', { timeout: 10000 });\n\t\tawait page.click('text=Create Deck');\n\t\tawait page.fill('input[placeholder=\"Enter deck name\"]', 'Phase Test Deck');\n\t\tawait page.selectOption('select', 'Standard');\n\n\t\t// Add cards to deck\n\t\tconst cards = page.locator('[data-testid=\"card-item\"]');\n\t\tfor (let i = 0; i < 40; i++) {\n\t\t\tawait cards.nth(i).click();\n\t\t}\n\n\t\tawait page.click('button:has-text(\"Save Deck\")');\n\t\tawait page.click('text=My Decks');\n\t\tawait page.click('button:has-text(\"Play\")');\n\t\tawait page.waitForSelector('[data-testid=\"game-board\"]', { timeout: 15000 });\n\t});\n\n\ttest('Rule 4.1.l: First Morning Phase is Skipped', async ({ page }) => {\n\t\t// Verify that on Day 1, the first Morning phase is skipped\n\t\tconst dayDisplay = await page.locator('[data-testid=\"day-display\"]').textContent();\n\t\tconst phaseDisplay = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\n\t\texpect(dayDisplay).toContain('Day: 1');\n\t\t// Should start at Noon, not Morning on Day 1\n\t\texpect(phaseDisplay).toMatch(/Phase: (Noon|Afternoon)/);\n\t\texpect(phaseDisplay).not.toContain('Morning');\n\t});\n\n\ttest('Rule 4.2: Complete Day Structure Progression', async ({ page }) => {\n\t\t// Test complete progression through all phases of a day\n\t\tconst phases = ['Morning', 'Noon', 'Afternoon', 'Dusk', 'Night'];\n\t\tlet currentDay = 1;\n\n\t\t// Skip Day 1 Morning (it's automatically skipped per Rule 4.1.l)\n\t\tfor (let day = 1; day <= 2; day++) {\n\t\t\tconst expectedPhases = day === 1 ? ['Noon', 'Afternoon', 'Dusk', 'Night'] : phases;\n\n\t\t\tfor (const expectedPhase of expectedPhases) {\n\t\t\t\t// Wait for current phase\n\t\t\t\tawait page.waitForFunction(\n\t\t\t\t\t(phase) => {\n\t\t\t\t\t\tconst phaseElement = document.querySelector('[data-testid=\"phase-display\"]');\n\t\t\t\t\t\treturn phaseElement?.textContent?.includes(phase);\n\t\t\t\t\t},\n\t\t\t\t\texpectedPhase,\n\t\t\t\t\t{ timeout: 5000 }\n\t\t\t\t);\n\n\t\t\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\t\t\texpect(phaseText).toContain(expectedPhase);\n\n\t\t\t\t// Special handling for different phases\n\t\t\t\tif (expectedPhase === 'Morning') {\n\t\t\t\t\t// Rule 4.2.1: Morning phase effects\n\t\t\t\t\tconst expandButton = page.locator('button:has-text(\"Expand Card\")');\n\t\t\t\t\tif (await expandButton.isVisible()) {\n\t\t\t\t\t\tawait page.click('button:has-text(\"Skip Expand\")');\n\t\t\t\t\t}\n\t\t\t\t} else if (expectedPhase === 'Afternoon') {\n\t\t\t\t\t// Rule 4.2.3: Afternoon turn-based play\n\t\t\t\t\tconst turnIndicator = await page.locator('[data-testid=\"turn-indicator\"]').textContent();\n\t\t\t\t\texpect(turnIndicator).toMatch(/(YOUR TURN|OPPONENT'S TURN)/);\n\n\t\t\t\t\t// Pass turn if it's our turn\n\t\t\t\t\tif (turnIndicator?.includes('YOUR TURN')) {\n\t\t\t\t\t\tawait page.click('button:has-text(\"Pass Turn\")');\n\t\t\t\t\t\tawait page.waitForTimeout(1000);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Wait for afternoon to end (both players pass)\n\t\t\t\t\tawait page.waitForFunction(\n\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\tconst phaseElement = document.querySelector('[data-testid=\"phase-display\"]');\n\t\t\t\t\t\t\treturn !phaseElement?.textContent?.includes('Afternoon');\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ timeout: 10000 }\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// Auto-advancing phases (Noon, Dusk, Night)\n\t\t\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t\t\t}\n\n\t\t\t\tawait page.waitForTimeout(1000);\n\t\t\t}\n\n\t\t\tcurrentDay++;\n\t\t}\n\n\t\t// Verify we've advanced to Day 3\n\t\tconst finalDayText = await page.locator('[data-testid=\"day-display\"]').textContent();\n\t\texpect(finalDayText).toContain('Day: 3');\n\t});\n\n\ttest('Rule 4.2.1: Morning Phase Effects (Day 2+)', async ({ page }) => {\n\t\t// Advance to Day 2 Morning to test Morning phase effects\n\t\twhile (true) {\n\t\t\tconst dayText = await page.locator('[data-testid=\"day-display\"]').textContent();\n\t\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\n\t\t\tif (dayText?.includes('Day: 2') && phaseText?.includes('Morning')) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t\tawait page.waitForTimeout(1000);\n\t\t}\n\n\t\t// Rule 4.2.1.a: Succeed (status effects)\n\t\t// Rule 4.2.1.b: Prepare (ready all objects)\n\t\t// Rule 4.2.1.c: Draw 2 cards\n\t\tconst initialHandCount = await page\n\t\t\t.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]')\n\t\t\t.count();\n\n\t\t// Wait for automatic draw\n\t\tawait page.waitForTimeout(2000);\n\n\t\tconst finalHandCount = await page\n\t\t\t.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]')\n\t\t\t.count();\n\t\texpect(finalHandCount).toBe(initialHandCount + 2);\n\n\t\t// Rule 4.2.1.e: Expand phase\n\t\tconst expandButton = page.locator('button:has-text(\"Expand Card\")');\n\t\texpect(await expandButton.isVisible()).toBe(true);\n\t});\n\n\ttest('Rule 4.2.4: Dusk Phase Progress Effects', async ({ page }) => {\n\t\t// Navigate to Dusk phase\n\t\twhile (true) {\n\t\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\t\tif (phaseText?.includes('Dusk')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t\tawait page.waitForTimeout(1000);\n\t\t}\n\n\t\t// Rule 4.2.4: Progress phase should execute\n\t\t// Characters in expedition should move forward\n\t\tconst expeditionCards = await page\n\t\t\t.locator('[data-testid=\"expedition-zone\"] [data-testid=\"card\"]')\n\t\t\t.count();\n\n\t\t// Advance through Dusk\n\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\tawait page.waitForTimeout(2000);\n\n\t\t// Verify we moved to Night phase\n\t\tconst phaseAfterDusk = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\texpect(phaseAfterDusk).toContain('Night');\n\t});\n\n\ttest('Rule 4.2.5: Night Phase Effects', async ({ page }) => {\n\t\t// Navigate to Night phase\n\t\twhile (true) {\n\t\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\t\tif (phaseText?.includes('Night')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t\tawait page.waitForTimeout(1000);\n\t\t}\n\n\t\tconst currentDay = await page.locator('[data-testid=\"day-display\"]').textContent();\n\t\tconst dayNumber = parseInt(currentDay?.match(/Day: (\\d+)/)?.[1] || '1');\n\n\t\t// Rule 4.2.5: Night phase effects\n\t\t// a. Rest (ready all exhausted objects)\n\t\t// b. Clean-up (remove fleeting status, etc.)\n\t\t// c. Check Victory\n\n\t\t// Advance through Night\n\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\tawait page.waitForTimeout(2000);\n\n\t\t// Should advance to next day's Morning\n\t\tconst newDayText = await page.locator('[data-testid=\"day-display\"]').textContent();\n\t\tconst newDayNumber = parseInt(newDayText?.match(/Day: (\\d+)/)?.[1] || '1');\n\t\texpect(newDayNumber).toBe(dayNumber + 1);\n\n\t\tconst newPhaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\texpect(newPhaseText).toContain('Morning');\n\t});\n\n\ttest('Phase Transition Timing and Automation', async ({ page }) => {\n\t\t// Test that certain phases auto-advance while others wait for player input\n\n\t\t// Noon should auto-advance to Afternoon\n\t\twhile (true) {\n\t\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\t\tif (phaseText?.includes('Noon')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t\tawait page.waitForTimeout(1000);\n\t\t}\n\n\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\tawait page.waitForTimeout(1000);\n\n\t\t// Should be in Afternoon now\n\t\tconst afternoonPhase = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\texpect(afternoonPhase).toContain('Afternoon');\n\n\t\t// Afternoon should wait for player actions (turns)\n\t\tconst turnIndicator = await page.locator('[data-testid=\"turn-indicator\"]').textContent();\n\t\texpect(turnIndicator).toMatch(/(YOUR TURN|OPPONENT'S TURN)/);\n\n\t\t// Dusk should auto-advance to Night\n\t\twhile (true) {\n\t\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\t\tif (phaseText?.includes('Dusk')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (phaseText?.includes('Afternoon')) {\n\t\t\t\t// End afternoon by passing turns\n\t\t\t\tconst turn = await page.locator('[data-testid=\"turn-indicator\"]').textContent();\n\t\t\t\tif (turn?.includes('YOUR TURN')) {\n\t\t\t\t\tawait page.click('button:has-text(\"Pass Turn\")');\n\t\t\t\t} else {\n\t\t\t\t\tawait page.waitForTimeout(1000);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t\t}\n\t\t\tawait page.waitForTimeout(1000);\n\t\t}\n\n\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\tawait page.waitForTimeout(1000);\n\n\t\t// Should auto-advance to Night\n\t\tconst nightPhase = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\texpect(nightPhase).toContain('Night');\n\t});\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/status-effects-keywords.spec.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 354,
				"column": 36,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 354,
				"endColumn": 39,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [13722, 13725], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [13722, 13725], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 372,
				"column": 41,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 372,
				"endColumn": 44,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [14400, 14403], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [14400, 14403], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 384,
				"column": 46,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 384,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [14749, 14752], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [14749, 14752], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 400,
				"column": 41,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 400,
				"endColumn": 44,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [15219, 15222], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [15219, 15222], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 416,
				"column": 47,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 416,
				"endColumn": 50,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [15655, 15658], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [15655, 15658], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 432,
				"column": 42,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 432,
				"endColumn": 45,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [16155, 16158], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [16155, 16158], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 448,
				"column": 43,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 448,
				"endColumn": 46,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [16616, 16619], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [16616, 16619], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 448,
				"column": 59,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 448,
				"endColumn": 62,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [16632, 16635], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [16632, 16635], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 454,
				"column": 46,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 454,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [16884, 16887], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [16884, 16887], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 472,
				"column": 42,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 472,
				"endColumn": 45,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [17411, 17414], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [17411, 17414], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 483,
				"column": 43,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 483,
				"endColumn": 46,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [17711, 17714], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [17711, 17714], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 501,
				"column": 42,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 501,
				"endColumn": 45,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [18359, 18362], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [18359, 18362], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 512,
				"column": 34,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 512,
				"endColumn": 37,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [18651, 18654], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [18651, 18654], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 512,
				"column": 45,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 512,
				"endColumn": 48,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [18662, 18665], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [18662, 18665], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 518,
				"column": 38,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 518,
				"endColumn": 41,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [18888, 18891], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [18888, 18891], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 518,
				"column": 49,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 518,
				"endColumn": 52,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [18899, 18902], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [18899, 18902], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 524,
				"column": 31,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 524,
				"endColumn": 34,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [19122, 19125], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [19122, 19125], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 524,
				"column": 42,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 524,
				"endColumn": 45,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [19133, 19136], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [19133, 19136], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 534,
				"column": 39,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 534,
				"endColumn": 42,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [19397, 19400], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [19397, 19400], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 542,
				"column": 42,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 542,
				"endColumn": 45,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [19601, 19604], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [19601, 19604], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 558,
				"column": 40,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 558,
				"endColumn": 43,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [20040, 20043], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [20040, 20043], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 558,
				"column": 56,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 558,
				"endColumn": 59,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [20056, 20059], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [20056, 20059], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 22,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { test, expect } from '@playwright/test';\n\ntest.describe('Status Effects and Keyword Abilities - Rules 2.4 & 7.4', () => {\n\ttest.beforeEach(async ({ page }) => {\n\t\tawait page.goto('/');\n\t\tawait setupTestDeck(page, 'Status Effects Test');\n\t});\n\n\ttest('Rule 2.4.2: Anchored Status Effect', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\t// Find a character with Anchored status or apply it\n\t\tconst anchoredCharacter = await findCharacterWithStatus(page, 'Anchored');\n\t\tif (anchoredCharacter) {\n\t\t\t// Rule 2.4.2: Anchored characters cannot move forward during Progress phase\n\t\t\tconst initialPosition = await getCharacterPosition(page, anchoredCharacter);\n\n\t\t\t// Advance to Dusk phase (Progress phase)\n\t\t\tawait navigateToDuskPhase(page);\n\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t\tawait page.waitForTimeout(2000);\n\n\t\t\t// Verify character didn't move\n\t\t\tconst finalPosition = await getCharacterPosition(page, anchoredCharacter);\n\t\t\texpect(finalPosition).toBe(initialPosition);\n\n\t\t\t// Verify Anchored status is still present\n\t\t\tconst statusElements = anchoredCharacter.locator('[data-testid=\"status-effect\"]');\n\t\t\tconst statusText = await statusElements.allTextContents();\n\t\t\texpect(statusText).toContain('Anchored');\n\t\t}\n\t});\n\n\ttest('Rule 2.4.3: Asleep Status Effect', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\tconst asleepCharacter = await findCharacterWithStatus(page, 'Asleep');\n\t\tif (asleepCharacter) {\n\t\t\t// Rule 2.4.3.a: Asleep characters cannot be chosen to go on an Expedition\n\t\t\tawait navigateToAfternoonTurn(page);\n\n\t\t\t// Try to select the asleep character for expedition action\n\t\t\tawait asleepCharacter.click();\n\n\t\t\t// Should not be selectable or should show error\n\t\t\tconst errorMessage = page.locator('[data-testid=\"error-message\"]');\n\t\t\tif (await errorMessage.isVisible()) {\n\t\t\t\tconst errorText = await errorMessage.textContent();\n\t\t\t\texpect(errorText).toMatch(/asleep|cannot.*expedition/i);\n\t\t\t}\n\n\t\t\t// Rule 2.4.3.b: Asleep status is removed during Morning Succeed step\n\t\t\tawait advanceToNextMorning(page);\n\n\t\t\t// Verify Asleep status is removed\n\t\t\tconst statusElements = asleepCharacter.locator('[data-testid=\"status-effect\"]');\n\t\t\tconst statusText = await statusElements.allTextContents();\n\t\t\texpect(statusText).not.toContain('Asleep');\n\t\t}\n\t});\n\n\ttest('Rule 2.4.4: Boosted Status Effect', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\tconst boostedCharacter = await findCharacterWithStatus(page, 'Boosted');\n\t\tif (boostedCharacter) {\n\t\t\t// Rule 2.4.4: Boosted characters have +1 to all statistics\n\t\t\tconst statsElement = boostedCharacter.locator('[data-testid=\"character-stats\"]');\n\t\t\tconst statsText = await statsElement.textContent();\n\n\t\t\t// Verify boosted stats (should show increased values)\n\t\t\texpect(statsText).toMatch(/\\+1|\\+/); // Look for boost indicators\n\n\t\t\t// Rule 2.4.4.b: Boosted status is removed during Morning Succeed step\n\t\t\tawait advanceToNextMorning(page);\n\n\t\t\tconst statusElements = boostedCharacter.locator('[data-testid=\"status-effect\"]');\n\t\t\tconst statusText = await statusElements.allTextContents();\n\t\t\texpect(statusText).not.toContain('Boosted');\n\t\t}\n\t});\n\n\ttest('Rule 2.4.5: Exhausted Status Effect', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\t// Find an exhausted mana orb or character\n\t\tconst exhaustedMana = page.locator('[data-testid=\"mana-orb\"][data-status=\"exhausted\"]');\n\t\tif ((await exhaustedMana.count()) > 0) {\n\t\t\t// Rule 2.4.5: Exhausted objects cannot be used to pay costs\n\t\t\tconst manaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\t\tconst currentMana = parseInt(manaDisplay?.split('/')[0] || '0');\n\t\t\tconst maxMana = parseInt(manaDisplay?.split('/')[1] || '0');\n\n\t\t\texpect(currentMana).toBeLessThan(maxMana); // Some mana should be exhausted\n\n\t\t\t// Rule 2.4.5.b: Exhausted status is removed during Morning Prepare step\n\t\t\tawait advanceToNextMorning(page);\n\n\t\t\tconst newManaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\t\tconst newCurrentMana = parseInt(newManaDisplay?.split('/')[0] || '0');\n\t\t\tconst newMaxMana = parseInt(newManaDisplay?.split('/')[1] || '0');\n\n\t\t\texpect(newCurrentMana).toBe(newMaxMana); // All mana should be ready\n\t\t}\n\t});\n\n\ttest('Rule 2.4.6: Fleeting Status Effect', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\t// Find a fleeting spell or permanent\n\t\tconst fleetingCard = await findCardWithStatus(page, 'Fleeting');\n\t\tif (fleetingCard) {\n\t\t\t// Rule 2.4.6.e: Fleeting spells go to Discard Pile instead of Reserve\n\t\t\tif (await isSpellCard(page, fleetingCard)) {\n\t\t\t\tconst initialDiscardCount = await page\n\t\t\t\t\t.locator('[data-testid=\"discard-count\"]')\n\t\t\t\t\t.textContent();\n\t\t\t\tconst discardCount = parseInt(initialDiscardCount || '0');\n\n\t\t\t\tawait playCard(page, fleetingCard);\n\n\t\t\t\tconst finalDiscardCount = await page.locator('[data-testid=\"discard-count\"]').textContent();\n\t\t\t\tconst newDiscardCount = parseInt(finalDiscardCount || '0');\n\n\t\t\t\texpect(newDiscardCount).toBe(discardCount + 1);\n\t\t\t}\n\n\t\t\t// Rule 2.4.6.f: Fleeting permanents are discarded during Night Clean-up\n\t\t\tif (await isPermanentCard(page, fleetingCard)) {\n\t\t\t\tawait advanceToNightPhase(page);\n\n\t\t\t\t// Card should be moved to discard pile during clean-up\n\t\t\t\tconst discardPile = page.locator('[data-testid=\"discard-pile\"]');\n\t\t\t\tconst discardedCards = await discardPile.locator('[data-testid=\"card\"]').allTextContents();\n\t\t\t\tconst cardName = await fleetingCard.locator('[data-testid=\"card-name\"]').textContent();\n\n\t\t\t\texpect(discardedCards).toContain(cardName);\n\t\t\t}\n\t\t}\n\t});\n\n\ttest('Rule 7.4.1: Cooldown Keyword Ability', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\tconst cooldownSpell = await findCardWithKeyword(page, 'Cooldown');\n\t\tif (cooldownSpell) {\n\t\t\tawait navigateToAfternoonTurn(page);\n\n\t\t\t// Rule 7.4.1.b: Cooldown spells enter Reserve exhausted\n\t\t\tawait playCard(page, cooldownSpell);\n\n\t\t\tconst reserveZone = page.locator('[data-testid=\"reserve-zone\"]');\n\t\t\tconst exhaustedCards = reserveZone.locator('[data-testid=\"card\"][data-status=\"exhausted\"]');\n\n\t\t\texpect(await exhaustedCards.count()).toBeGreaterThan(0);\n\n\t\t\t// Rule 7.4.1.c: Cannot be recalled while exhausted\n\t\t\tconst exhaustedSpell = exhaustedCards.first();\n\t\t\tawait exhaustedSpell.click();\n\n\t\t\t// Should not be recallable\n\t\t\tconst recallButton = page.locator('button:has-text(\"Recall\")');\n\t\t\texpect(await recallButton.isEnabled()).toBe(false);\n\t\t}\n\t});\n\n\ttest('Rule 7.4.2: Defender Keyword Ability', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\tconst defenderCharacter = await findCharacterWithKeyword(page, 'Defender');\n\t\tif (defenderCharacter) {\n\t\t\t// Rule 7.4.2: Characters with Defender cannot move forward\n\t\t\tconst initialPosition = await getCharacterPosition(page, defenderCharacter);\n\n\t\t\tawait navigateToDuskPhase(page);\n\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t\tawait page.waitForTimeout(2000);\n\n\t\t\tconst finalPosition = await getCharacterPosition(page, defenderCharacter);\n\t\t\texpect(finalPosition).toBe(initialPosition);\n\n\t\t\t// Rule 7.4.2.b: Other characters in same expedition also cannot move\n\t\t\tconst expeditionZone = defenderCharacter.locator(\n\t\t\t\t'xpath=ancestor::[data-testid=\"expedition-zone\"]'\n\t\t\t);\n\t\t\tconst expeditionCharacters = expeditionZone.locator('[data-testid=\"character-card\"]');\n\n\t\t\tfor (let i = 0; i < (await expeditionCharacters.count()); i++) {\n\t\t\t\tconst character = expeditionCharacters.nth(i);\n\t\t\t\tconst position = await getCharacterPosition(page, character);\n\t\t\t\t// All should remain at same position\n\t\t\t\texpect(position).toBe(initialPosition);\n\t\t\t}\n\t\t}\n\t});\n\n\ttest('Rule 7.4.3: Eternal Keyword Ability', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\tconst eternalCard = await findCardWithKeyword(page, 'Eternal');\n\t\tif (eternalCard) {\n\t\t\t// Rule 7.4.3: Eternal cards cannot be discarded\n\t\t\t// Try to discard through various means\n\n\t\t\t// Test 1: Night clean-up should not discard Eternal cards\n\t\t\tconst cardName = await eternalCard.locator('[data-testid=\"card-name\"]').textContent();\n\t\t\tawait advanceToNightPhase(page);\n\n\t\t\t// Card should still be in play\n\t\t\tconst boardCards = page.locator('[data-testid=\"game-board\"] [data-testid=\"card\"]');\n\t\t\tconst boardCardNames = await boardCards.allTextContents();\n\t\t\texpect(boardCardNames).toContain(cardName);\n\n\t\t\t// Should not be in discard pile\n\t\t\tconst discardPile = page.locator('[data-testid=\"discard-pile\"]');\n\t\t\tconst discardedCards = await discardPile.locator('[data-testid=\"card\"]').allTextContents();\n\t\t\texpect(discardedCards).not.toContain(cardName);\n\t\t}\n\t});\n\n\ttest('Rule 7.4.4: Gigantic Keyword Ability', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\tconst giganticCharacter = await findCharacterWithKeyword(page, 'Gigantic');\n\t\tif (giganticCharacter) {\n\t\t\t// Rule 7.4.4: Gigantic characters take up 2 expedition slots\n\t\t\tconst expeditionZone = giganticCharacter.locator(\n\t\t\t\t'xpath=ancestor::[data-testid=\"expedition-zone\"]'\n\t\t\t);\n\t\t\tconst expeditionCards = expeditionZone.locator('[data-testid=\"character-card\"]');\n\t\t\tconst totalCards = await expeditionCards.count();\n\n\t\t\t// Try to add another character to the expedition\n\t\t\tawait navigateToAfternoonTurn(page);\n\t\t\tconst handCharacter = await findCharacterInHand(page);\n\n\t\t\tif (handCharacter) {\n\t\t\t\tawait handCharacter.click();\n\t\t\t\tawait expeditionZone.click();\n\n\t\t\t\t// Should be rejected if expedition is full due to Gigantic\n\t\t\t\tif (totalCards >= 3) {\n\t\t\t\t\t// Assuming max 4 slots, Gigantic takes 2\n\t\t\t\t\tconst errorMessage = page.locator('[data-testid=\"error-message\"]');\n\t\t\t\t\texpect(await errorMessage.isVisible()).toBe(true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\ttest('Rule 7.4.5: Scout Keyword Ability', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\tconst scoutCharacter = await findCharacterWithKeyword(page, 'Scout');\n\t\tif (scoutCharacter) {\n\t\t\t// Rule 7.4.5: Scout characters move +1 additional step during Progress\n\t\t\tconst initialPosition = await getCharacterPosition(page, scoutCharacter);\n\n\t\t\tawait navigateToDuskPhase(page);\n\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t\tawait page.waitForTimeout(2000);\n\n\t\t\tconst finalPosition = await getCharacterPosition(page, scoutCharacter);\n\t\t\texpect(finalPosition).toBe(initialPosition + 2); // +1 normal + 1 scout bonus\n\t\t}\n\t});\n\n\ttest('Rule 7.4.6: Seasoned Keyword Ability', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\tconst seasonedCharacter = await findCharacterWithKeyword(page, 'Seasoned');\n\t\tif (seasonedCharacter) {\n\t\t\t// Rule 7.4.6: Seasoned X - character enters play with X boost counters\n\t\t\tconst boostCounters = seasonedCharacter.locator('[data-testid=\"boost-counter\"]');\n\t\t\tconst counterCount = await boostCounters.count();\n\n\t\t\texpect(counterCount).toBeGreaterThan(0);\n\n\t\t\t// Verify boost counters provide +1/+1/+1 per counter\n\t\t\tconst statsElement = seasonedCharacter.locator('[data-testid=\"character-stats\"]');\n\t\t\tconst statsText = await statsElement.textContent();\n\t\t\texpect(statsText).toMatch(/\\+\\d/); // Should show boosted stats\n\t\t}\n\t});\n\n\ttest('Rule 7.4.7: Tough Keyword Ability', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\tconst toughCharacter = await findCharacterWithKeyword(page, 'Tough');\n\t\tif (toughCharacter) {\n\t\t\t// Rule 7.4.7: Tough X - character takes X less damage\n\t\t\t// This would need damage dealing mechanics to test properly\n\n\t\t\t// For now, verify the Tough status is displayed\n\t\t\tconst keywordElements = toughCharacter.locator('[data-testid=\"keyword-ability\"]');\n\t\t\tconst keywordText = await keywordElements.allTextContents();\n\t\t\texpect(keywordText.some((text) => text.includes('Tough'))).toBe(true);\n\t\t}\n\t});\n\n\ttest('Status Effect Interactions and Stacking', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\t// Test multiple status effects on same character\n\t\tconst character = await findAnyCharacter(page);\n\t\tif (character) {\n\t\t\t// Apply multiple status effects (if possible through game mechanics)\n\t\t\tawait applyStatusEffect(page, character, 'Boosted');\n\t\t\tawait applyStatusEffect(page, character, 'Anchored');\n\n\t\t\tconst statusElements = character.locator('[data-testid=\"status-effect\"]');\n\t\t\tconst statusTexts = await statusElements.allTextContents();\n\n\t\t\t// Should have both effects\n\t\t\texpect(statusTexts).toContain('Boosted');\n\t\t\texpect(statusTexts).toContain('Anchored');\n\n\t\t\t// Effects should interact correctly\n\t\t\t// Boosted should increase stats, Anchored should prevent movement\n\t\t\tconst statsElement = character.locator('[data-testid=\"character-stats\"]');\n\t\t\tconst statsText = await statsElement.textContent();\n\t\t\texpect(statsText).toMatch(/\\+/); // Boosted effect\n\t\t}\n\t});\n\n\ttest('Status Effect Duration and Removal', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\t// Test that temporary status effects are removed at correct times\n\t\tconst character = await findCharacterWithStatus(page, 'Boosted');\n\t\tif (character) {\n\t\t\t// Boosted should be removed during next Morning Succeed step\n\t\t\tawait advanceToNextMorning(page);\n\n\t\t\tconst statusElements = character.locator('[data-testid=\"status-effect\"]');\n\t\t\tconst statusTexts = await statusElements.allTextContents();\n\t\t\texpect(statusTexts).not.toContain('Boosted');\n\t\t}\n\n\t\t// Test permanent status effects (like those from keywords)\n\t\tconst eternalCard = await findCardWithKeyword(page, 'Eternal');\n\t\tif (eternalCard) {\n\t\t\tawait advanceToNextMorning(page);\n\n\t\t\t// Eternal keyword should persist\n\t\t\tconst keywordElements = eternalCard.locator('[data-testid=\"keyword-ability\"]');\n\t\t\tconst keywordTexts = await keywordElements.allTextContents();\n\t\t\texpect(keywordTexts.some((text) => text.includes('Eternal'))).toBe(true);\n\t\t}\n\t});\n});\n\n// Helper functions for status effects and keywords\nasync function setupTestDeck(page: any, deckName: string) {\n\tawait page.click('text=Browse Cards');\n\tawait page.waitForSelector('[data-testid=\"card-grid\"]', { timeout: 10000 });\n\tawait page.click('text=Create Deck');\n\tawait page.fill('input[placeholder=\"Enter deck name\"]', deckName);\n\tawait page.selectOption('select', 'Standard');\n\n\tconst cards = page.locator('[data-testid=\"card-item\"]');\n\tfor (let i = 0; i < 40; i++) {\n\t\tawait cards.nth(i).click();\n\t}\n\n\tawait page.click('button:has-text(\"Save Deck\")');\n\tawait page.click('text=My Decks');\n\tawait page.click('button:has-text(\"Play\")');\n\tawait page.waitForSelector('[data-testid=\"game-board\"]', { timeout: 15000 });\n}\n\nasync function navigateToGameplay(page: any) {\n\t// Basic navigation to get game started\n\twhile (true) {\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\tif (phaseText?.includes('Afternoon')) {\n\t\t\tbreak;\n\t\t}\n\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\tawait page.waitForTimeout(1000);\n\t}\n}\n\nasync function findCharacterWithStatus(page: any, status: string) {\n\tconst characters = page.locator('[data-testid=\"character-card\"]');\n\tconst count = await characters.count();\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst character = characters.nth(i);\n\t\tconst statusElements = character.locator('[data-testid=\"status-effect\"]');\n\t\tconst statusTexts = await statusElements.allTextContents();\n\n\t\tif (statusTexts.includes(status)) {\n\t\t\treturn character;\n\t\t}\n\t}\n\treturn null;\n}\n\nasync function findCardWithStatus(page: any, status: string) {\n\tconst cards = page.locator('[data-testid=\"card\"]');\n\tconst count = await cards.count();\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst card = cards.nth(i);\n\t\tconst statusElements = card.locator('[data-testid=\"status-effect\"]');\n\t\tconst statusTexts = await statusElements.allTextContents();\n\n\t\tif (statusTexts.includes(status)) {\n\t\t\treturn card;\n\t\t}\n\t}\n\treturn null;\n}\n\nasync function findCharacterWithKeyword(page: any, keyword: string) {\n\tconst characters = page.locator('[data-testid=\"character-card\"]');\n\tconst count = await characters.count();\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst character = characters.nth(i);\n\t\tconst keywordElements = character.locator('[data-testid=\"keyword-ability\"]');\n\t\tconst keywordTexts = await keywordElements.allTextContents();\n\n\t\tif (keywordTexts.some((text) => text.includes(keyword))) {\n\t\t\treturn character;\n\t\t}\n\t}\n\treturn null;\n}\n\nasync function findCardWithKeyword(page: any, keyword: string) {\n\tconst cards = page.locator('[data-testid=\"card\"]');\n\tconst count = await cards.count();\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst card = cards.nth(i);\n\t\tconst keywordElements = card.locator('[data-testid=\"keyword-ability\"]');\n\t\tconst keywordTexts = await keywordElements.allTextContents();\n\n\t\tif (keywordTexts.some((text) => text.includes(keyword))) {\n\t\t\treturn card;\n\t\t}\n\t}\n\treturn null;\n}\n\nasync function getCharacterPosition(page: any, character: any): Promise<number> {\n\tconst positionElement = character.locator('[data-testid=\"character-position\"]');\n\tconst positionText = await positionElement.textContent();\n\treturn parseInt(positionText || '0');\n}\n\nasync function navigateToAfternoonTurn(page: any) {\n\twhile (true) {\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\tconst turnText = await page.locator('[data-testid=\"turn-indicator\"]').textContent();\n\n\t\tif (phaseText?.includes('Afternoon') && turnText?.includes('YOUR TURN')) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (turnText?.includes(\"OPPONENT'S TURN\")) {\n\t\t\tawait page.waitForTimeout(2000);\n\t\t} else {\n\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t}\n\t\tawait page.waitForTimeout(1000);\n\t}\n}\n\nasync function navigateToDuskPhase(page: any) {\n\twhile (true) {\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\tif (phaseText?.includes('Dusk')) {\n\t\t\tbreak;\n\t\t}\n\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\tawait page.waitForTimeout(1000);\n\t}\n}\n\nasync function advanceToNextMorning(page: any) {\n\tconst currentDay = await page.locator('[data-testid=\"day-display\"]').textContent();\n\tconst dayNumber = parseInt(currentDay?.match(/Day: (\\d+)/)?.[1] || '1');\n\n\twhile (true) {\n\t\tconst newDay = await page.locator('[data-testid=\"day-display\"]').textContent();\n\t\tconst newDayNumber = parseInt(newDay?.match(/Day: (\\d+)/)?.[1] || '1');\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\n\t\tif (newDayNumber > dayNumber && phaseText?.includes('Morning')) {\n\t\t\tbreak;\n\t\t}\n\n\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\tawait page.waitForTimeout(1000);\n\t}\n}\n\nasync function advanceToNightPhase(page: any) {\n\twhile (true) {\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\tif (phaseText?.includes('Night')) {\n\t\t\tbreak;\n\t\t}\n\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\tawait page.waitForTimeout(1000);\n\t}\n}\n\nasync function isSpellCard(page: any, card: any): Promise<boolean> {\n\tconst typeElement = card.locator('[data-testid=\"card-type\"]');\n\tconst typeText = await typeElement.textContent();\n\treturn typeText?.includes('Spell') || false;\n}\n\nasync function isPermanentCard(page: any, card: any): Promise<boolean> {\n\tconst typeElement = card.locator('[data-testid=\"card-type\"]');\n\tconst typeText = await typeElement.textContent();\n\treturn typeText?.includes('Permanent') || false;\n}\n\nasync function playCard(page: any, card: any) {\n\tawait card.click();\n\n\t// Try to play in appropriate zone\n\tconst expeditionZone = page.locator('[data-testid=\"expedition-zone\"][data-owner=\"self\"]');\n\tawait expeditionZone.click();\n\n\tawait page.waitForTimeout(1000);\n}\n\nasync function findAnyCharacter(page: any) {\n\tconst characters = page.locator('[data-testid=\"character-card\"]');\n\tif ((await characters.count()) > 0) {\n\t\treturn characters.first();\n\t}\n\treturn null;\n}\n\nasync function findCharacterInHand(page: any) {\n\tconst handCards = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]');\n\tconst count = await handCards.count();\n\n\tfor (let i = 0; i < count; i++) {\n\t\tconst card = handCards.nth(i);\n\t\tconst typeElement = card.locator('[data-testid=\"card-type\"]');\n\t\tconst typeText = await typeElement.textContent();\n\n\t\tif (typeText?.includes('Character')) {\n\t\t\treturn card;\n\t\t}\n\t}\n\treturn null;\n}\n\nasync function applyStatusEffect(page: any, character: any, status: string) {\n\t// This would depend on game mechanics for applying status effects\n\t// For now, this is a placeholder for when such mechanics exist\n\tconsole.log(`Applying ${status} to character`);\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/terrain-mana-system.spec.ts",
		"messages": [
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'expeditionZone' is not defined.",
				"line": 279,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 279,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 331,
				"column": 36,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 331,
				"endColumn": 39,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [12273, 12276], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [12273, 12276], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 349,
				"column": 41,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 349,
				"endColumn": 44,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [12951, 12954], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [12951, 12954], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 360,
				"column": 45,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 360,
				"endColumn": 48,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [13258, 13261], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [13258, 13261], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 374,
				"column": 46,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 374,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [13681, 13684], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [13681, 13684], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 392,
				"column": 43,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 392,
				"endColumn": 46,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [14209, 14212], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [14209, 14212], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 410,
				"column": 39,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 410,
				"endColumn": 42,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [14854, 14857], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [14854, 14857], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 439,
				"column": 32,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 439,
				"endColumn": 35,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [15756, 15759], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [15756, 15759], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 470,
				"column": 46,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 470,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [16657, 16660], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [16657, 16660], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 487,
				"column": 44,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 487,
				"endColumn": 47,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [17151, 17154], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [17151, 17154], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 504,
				"column": 33,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 504,
				"endColumn": 36,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [17639, 17642], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [17639, 17642], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 10,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { test, expect } from '@playwright/test';\n\ntest.describe('Terrain and Mana System - Rules 2.2 & 3.2.5', () => {\n\ttest.beforeEach(async ({ page }) => {\n\t\tawait page.goto('/');\n\t\tawait setupTestDeck(page, 'Terrain Test Deck');\n\t});\n\n\ttest('Rule 2.2.10: Character Statistics and Terrain Types', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\t// Find characters and verify their terrain statistics\n\t\tconst characters = page.locator('[data-testid=\"character-card\"]');\n\t\tconst characterCount = await characters.count();\n\n\t\tif (characterCount > 0) {\n\t\t\tconst character = characters.first();\n\n\t\t\t// Rule 2.2.10: Each character has Forest, Mountain, and Water statistics\n\t\t\tconst forestStat = character.locator('[data-testid=\"forest-stat\"]');\n\t\t\tconst mountainStat = character.locator('[data-testid=\"mountain-stat\"]');\n\t\t\tconst waterStat = character.locator('[data-testid=\"water-stat\"]');\n\n\t\t\texpect(await forestStat.isVisible()).toBe(true);\n\t\t\texpect(await mountainStat.isVisible()).toBe(true);\n\t\t\texpect(await waterStat.isVisible()).toBe(true);\n\n\t\t\t// Verify stats are numeric values\n\t\t\tconst forestValue = await forestStat.textContent();\n\t\t\tconst mountainValue = await mountainStat.textContent();\n\t\t\tconst waterValue = await waterStat.textContent();\n\n\t\t\texpect(parseInt(forestValue || '0')).toBeGreaterThanOrEqual(0);\n\t\t\texpect(parseInt(mountainValue || '0')).toBeGreaterThanOrEqual(0);\n\t\t\texpect(parseInt(waterValue || '0')).toBeGreaterThanOrEqual(0);\n\t\t}\n\t});\n\n\ttest('Rule 3.2.5: Mana Zone and Orb Management', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\t// Rule 3.2.5.a: Mana Zone contains Mana Orbs\n\t\tconst manaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\tconst [current, max] = manaDisplay?.split('/').map((s) => parseInt(s)) || [0, 0];\n\n\t\texpect(max).toBeGreaterThan(0); // Should start with at least some mana orbs\n\t\texpect(current).toBeLessThanOrEqual(max);\n\n\t\t// Rule 3.2.5.b: Mana Orbs can be ready or exhausted\n\t\tconst manaOrbs = page.locator('[data-testid=\"mana-orb\"]');\n\t\tconst orbCount = await manaOrbs.count();\n\t\texpect(orbCount).toBe(max);\n\n\t\t// Check orb states\n\t\tconst readyOrbs = page.locator('[data-testid=\"mana-orb\"]:not([data-status=\"exhausted\"])');\n\t\tconst exhaustedOrbs = page.locator('[data-testid=\"mana-orb\"][data-status=\"exhausted\"]');\n\n\t\tconst readyCount = await readyOrbs.count();\n\t\tconst exhaustedCount = await exhaustedOrbs.count();\n\n\t\texpect(readyCount + exhaustedCount).toBe(max);\n\t\texpect(readyCount).toBe(current);\n\t});\n\n\ttest('Mana Orb Creation Through Expand', async ({ page }) => {\n\t\tawait navigateToMorningPhase(page);\n\n\t\tconst initialManaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\tconst initialMax = parseInt(initialManaDisplay?.split('/')[1] || '0');\n\n\t\t// Expand a card to create a new mana orb\n\t\tconst handCards = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]');\n\t\tif ((await handCards.count()) > 0) {\n\t\t\tawait page.click('button:has-text(\"Expand Card\")');\n\t\t\tawait handCards.first().click();\n\n\t\t\tawait page.waitForTimeout(1000);\n\n\t\t\t// Verify mana orb was created\n\t\t\tconst finalManaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\t\tconst finalMax = parseInt(finalManaDisplay?.split('/')[1] || '0');\n\n\t\t\texpect(finalMax).toBe(initialMax + 1);\n\n\t\t\t// Rule 4.2.1.e: New mana orb enters ready\n\t\t\tconst finalCurrent = parseInt(finalManaDisplay?.split('/')[0] || '0');\n\t\t\texpect(finalCurrent).toBe(finalMax);\n\t\t}\n\t});\n\n\ttest('Terrain-Based Mana Providing', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\t// Find characters in play and check their mana contribution\n\t\tconst expeditionCharacters = page.locator(\n\t\t\t'[data-testid=\"expedition-zone\"] [data-testid=\"character-card\"]'\n\t\t);\n\t\tconst characterCount = await expeditionCharacters.count();\n\n\t\tif (characterCount > 0) {\n\t\t\tconst character = expeditionCharacters.first();\n\n\t\t\t// Get character's terrain statistics\n\t\t\tconst forestStat = await character.locator('[data-testid=\"forest-stat\"]').textContent();\n\t\t\tconst mountainStat = await character.locator('[data-testid=\"mountain-stat\"]').textContent();\n\t\t\tconst waterStat = await character.locator('[data-testid=\"water-stat\"]').textContent();\n\n\t\t\tconst forestValue = parseInt(forestStat || '0');\n\t\t\tconst mountainValue = parseInt(mountainStat || '0');\n\t\t\tconst waterValue = parseInt(waterStat || '0');\n\n\t\t\t// Check available terrain mana\n\t\t\tconst terrainManaDisplay = page.locator('[data-testid=\"terrain-mana-display\"]');\n\t\t\tif (await terrainManaDisplay.isVisible()) {\n\t\t\t\tconst terrainManaText = await terrainManaDisplay.textContent();\n\n\t\t\t\t// Should show available mana from characters' statistics\n\t\t\t\texpect(terrainManaText).toContain(`Forest: ${forestValue}`);\n\t\t\t\texpect(terrainManaText).toContain(`Mountain: ${mountainValue}`);\n\t\t\t\texpect(terrainManaText).toContain(`Water: ${waterValue}`);\n\t\t\t}\n\t\t}\n\t});\n\n\ttest('Mana Cost Payment and Exhaustion', async ({ page }) => {\n\t\tawait navigateToAfternoonTurn(page);\n\n\t\tconst initialManaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\tconst initialCurrent = parseInt(initialManaDisplay?.split('/')[0] || '0');\n\n\t\t// Try to play a card that costs mana\n\t\tconst handCards = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]');\n\t\tif ((await handCards.count()) > 0) {\n\t\t\tconst cardToPlay = handCards.first();\n\t\t\tconst costElement = cardToPlay.locator('[data-testid=\"card-cost\"]');\n\t\t\tconst costText = await costElement.textContent();\n\t\t\tconst cost = parseInt(costText || '0');\n\n\t\t\tif (cost <= initialCurrent && cost > 0) {\n\t\t\t\tawait cardToPlay.click();\n\n\t\t\t\t// Play the card\n\t\t\t\tconst expeditionZone = page.locator('[data-testid=\"expedition-zone\"][data-owner=\"self\"]');\n\t\t\t\tawait expeditionZone.click();\n\n\t\t\t\tawait page.waitForTimeout(1000);\n\n\t\t\t\t// Verify mana was spent (orbs exhausted)\n\t\t\t\tconst finalManaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\t\t\tconst finalCurrent = parseInt(finalManaDisplay?.split('/')[0] || '0');\n\n\t\t\t\texpect(finalCurrent).toBe(initialCurrent - cost);\n\n\t\t\t\t// Check that correct number of orbs are exhausted\n\t\t\t\tconst exhaustedOrbs = page.locator('[data-testid=\"mana-orb\"][data-status=\"exhausted\"]');\n\t\t\t\tconst exhaustedCount = await exhaustedOrbs.count();\n\t\t\t\texpect(exhaustedCount).toBe(cost);\n\t\t\t}\n\t\t}\n\t});\n\n\ttest('Mana Orb Ready State Restoration', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\t// Exhaust some mana by playing cards\n\t\tawait spendMana(page, 2);\n\n\t\tconst manaAfterSpending = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\tconst currentAfterSpending = parseInt(manaAfterSpending?.split('/')[0] || '0');\n\t\tconst maxMana = parseInt(manaAfterSpending?.split('/')[1] || '0');\n\n\t\texpect(currentAfterSpending).toBeLessThan(maxMana);\n\n\t\t// Rule 4.2.1.b: Mana orbs become ready during Morning Prepare step\n\t\tawait advanceToNextMorning(page);\n\n\t\tconst manaAfterMorning = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\tconst currentAfterMorning = parseInt(manaAfterMorning?.split('/')[0] || '0');\n\t\tconst maxAfterMorning = parseInt(manaAfterMorning?.split('/')[1] || '0');\n\n\t\texpect(currentAfterMorning).toBe(maxAfterMorning); // All mana should be ready\n\t});\n\n\ttest('Terrain Mana vs Regular Mana Interaction', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\t// Test that terrain mana (from character statistics) works alongside regular mana orbs\n\t\tconst regularManaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\tconst regularMana = parseInt(regularManaDisplay?.split('/')[0] || '0');\n\n\t\t// Check terrain mana availability\n\t\tconst terrainManaElements = page.locator('[data-testid=\"terrain-mana\"]');\n\t\tlet totalTerrainMana = 0;\n\n\t\tif ((await terrainManaElements.count()) > 0) {\n\t\t\tconst forestMana = await page.locator('[data-testid=\"forest-mana\"]').textContent();\n\t\t\tconst mountainMana = await page.locator('[data-testid=\"mountain-mana\"]').textContent();\n\t\t\tconst waterMana = await page.locator('[data-testid=\"water-mana\"]').textContent();\n\n\t\t\ttotalTerrainMana =\n\t\t\t\tparseInt(forestMana || '0') + parseInt(mountainMana || '0') + parseInt(waterMana || '0');\n\t\t}\n\n\t\t// Total available mana should be regular + terrain\n\t\tconst totalAvailableMana = regularMana + totalTerrainMana;\n\n\t\t// Try to play a card with high cost using both types of mana\n\t\tconst highCostCard = await findCardWithMinimumCost(page, totalAvailableMana);\n\t\tif (highCostCard) {\n\t\t\tawait highCostCard.click();\n\n\t\t\tconst expeditionZone = page.locator('[data-testid=\"expedition-zone\"][data-owner=\"self\"]');\n\t\t\tawait expeditionZone.click();\n\n\t\t\t// Should succeed if total mana is sufficient\n\t\t\tawait page.waitForTimeout(1000);\n\n\t\t\tconst cardStillInHand = await highCostCard.isVisible();\n\t\t\texpect(cardStillInHand).toBe(false);\n\t\t}\n\t});\n\n\ttest('Mana Orb Face-Down State', async ({ page }) => {\n\t\tawait navigateToMorningPhase(page);\n\n\t\t// Expand a card to create a mana orb\n\t\tconst handCards = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]');\n\t\tif ((await handCards.count()) > 0) {\n\t\t\tconst cardToExpand = handCards.first();\n\t\t\tconst cardName = await cardToExpand.locator('[data-testid=\"card-name\"]').textContent();\n\n\t\t\tawait page.click('button:has-text(\"Expand Card\")');\n\t\t\tawait cardToExpand.click();\n\n\t\t\tawait page.waitForTimeout(1000);\n\n\t\t\t// Rule 4.2.1.e: Card becomes a face-down Mana Orb\n\t\t\tconst manaOrbs = page.locator('[data-testid=\"mana-orb\"]');\n\t\t\tconst newOrb = manaOrbs.last(); // Should be the newest orb\n\n\t\t\t// Verify it's face-down (original card identity hidden)\n\t\t\tconst orbFaceDown = await newOrb.getAttribute('data-face-down');\n\t\t\texpect(orbFaceDown).toBe('true');\n\n\t\t\t// Verify original card name is not visible on the orb\n\t\t\tconst orbText = await newOrb.textContent();\n\t\t\texpect(orbText).not.toContain(cardName);\n\t\t}\n\t});\n\n\ttest('Complex Mana Cost Scenarios', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\t// Test edge cases for mana payment\n\n\t\t// Test 1: Insufficient mana\n\t\tconst manaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\tconst availableMana = parseInt(manaDisplay?.split('/')[0] || '0');\n\n\t\tconst highCostCard = await findCardWithMinimumCost(page, availableMana + 1);\n\t\tif (highCostCard) {\n\t\t\tawait highCostCard.click();\n\n\t\t\tconst expeditionZone = page.locator('[data-testid=\"expedition-zone\"][data-owner=\"self\"]');\n\t\t\tawait expeditionZone.click();\n\n\t\t\t// Should fail and show error\n\t\t\tconst errorMessage = page.locator('[data-testid=\"error-message\"]');\n\t\t\texpect(await errorMessage.isVisible()).toBe(true);\n\n\t\t\t// Card should remain in hand\n\t\t\texpect(await highCostCard.isVisible()).toBe(true);\n\t\t}\n\n\t\t// Test 2: Exact mana cost\n\t\tconst exactCostCard = await findCardWithExactCost(page, availableMana);\n\t\tif (exactCostCard) {\n\t\t\tawait exactCostCard.click();\n\t\t\tawait expeditionZone.click();\n\n\t\t\tawait page.waitForTimeout(1000);\n\n\t\t\t// Should succeed and use all mana\n\t\t\tconst finalManaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\t\t\tconst finalMana = parseInt(finalManaDisplay?.split('/')[0] || '0');\n\t\t\texpect(finalMana).toBe(0);\n\t\t}\n\t});\n\n\ttest('Mana Zone Maximum Capacity', async ({ page }) => {\n\t\tawait navigateToGameplay(page);\n\n\t\t// Test if there's a maximum number of mana orbs\n\t\tlet expandCount = 0;\n\t\tconst maxExpands = 10; // Reasonable test limit\n\n\t\twhile (expandCount < maxExpands) {\n\t\t\tawait navigateToMorningPhase(page);\n\n\t\t\tconst handCards = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]');\n\t\t\tif ((await handCards.count()) > 0) {\n\t\t\t\tconst initialManaMax = await getManaMax(page);\n\n\t\t\t\tawait page.click('button:has-text(\"Expand Card\")');\n\t\t\t\tawait handCards.first().click();\n\n\t\t\t\tawait page.waitForTimeout(1000);\n\n\t\t\t\tconst finalManaMax = await getManaMax(page);\n\n\t\t\t\tif (finalManaMax === initialManaMax) {\n\t\t\t\t\t// Hit maximum capacity\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\texpect(finalManaMax).toBe(initialManaMax + 1);\n\t\t\t\texpandCount++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tawait advanceToNextDay(page);\n\t\t}\n\n\t\t// Should have successfully expanded multiple times or hit a reasonable limit\n\t\texpect(expandCount).toBeGreaterThan(0);\n\t});\n});\n\n// Helper functions for terrain and mana tests\nasync function setupTestDeck(page: any, deckName: string) {\n\tawait page.click('text=Browse Cards');\n\tawait page.waitForSelector('[data-testid=\"card-grid\"]', { timeout: 10000 });\n\tawait page.click('text=Create Deck');\n\tawait page.fill('input[placeholder=\"Enter deck name\"]', deckName);\n\tawait page.selectOption('select', 'Standard');\n\n\tconst cards = page.locator('[data-testid=\"card-item\"]');\n\tfor (let i = 0; i < 40; i++) {\n\t\tawait cards.nth(i).click();\n\t}\n\n\tawait page.click('button:has-text(\"Save Deck\")');\n\tawait page.click('text=My Decks');\n\tawait page.click('button:has-text(\"Play\")');\n\tawait page.waitForSelector('[data-testid=\"game-board\"]', { timeout: 15000 });\n}\n\nasync function navigateToGameplay(page: any) {\n\twhile (true) {\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\tif (phaseText?.includes('Afternoon')) {\n\t\t\tbreak;\n\t\t}\n\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\tawait page.waitForTimeout(1000);\n\t}\n}\n\nasync function navigateToMorningPhase(page: any) {\n\twhile (true) {\n\t\tconst dayText = await page.locator('[data-testid=\"day-display\"]').textContent();\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\n\t\tif (phaseText?.includes('Morning') && !dayText?.includes('Day: 1')) {\n\t\t\tbreak;\n\t\t}\n\n\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\tawait page.waitForTimeout(1000);\n\t}\n}\n\nasync function navigateToAfternoonTurn(page: any) {\n\twhile (true) {\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\t\tconst turnText = await page.locator('[data-testid=\"turn-indicator\"]').textContent();\n\n\t\tif (phaseText?.includes('Afternoon') && turnText?.includes('YOUR TURN')) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (turnText?.includes(\"OPPONENT'S TURN\")) {\n\t\t\tawait page.waitForTimeout(2000);\n\t\t} else {\n\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t}\n\t\tawait page.waitForTimeout(1000);\n\t}\n}\n\nasync function advanceToNextMorning(page: any) {\n\tconst currentDay = await page.locator('[data-testid=\"day-display\"]').textContent();\n\tconst dayNumber = parseInt(currentDay?.match(/Day: (\\d+)/)?.[1] || '1');\n\n\twhile (true) {\n\t\tconst newDay = await page.locator('[data-testid=\"day-display\"]').textContent();\n\t\tconst newDayNumber = parseInt(newDay?.match(/Day: (\\d+)/)?.[1] || '1');\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\n\t\tif (newDayNumber > dayNumber && phaseText?.includes('Morning')) {\n\t\t\tbreak;\n\t\t}\n\n\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\tawait page.waitForTimeout(1000);\n\t}\n}\n\nasync function advanceToNextDay(page: any) {\n\tconst currentDay = await page.locator('[data-testid=\"day-display\"]').textContent();\n\tconst dayNumber = parseInt(currentDay?.match(/Day: (\\d+)/)?.[1] || '1');\n\n\twhile (true) {\n\t\tconst newDay = await page.locator('[data-testid=\"day-display\"]').textContent();\n\t\tconst newDayNumber = parseInt(newDay?.match(/Day: (\\d+)/)?.[1] || '1');\n\n\t\tif (newDayNumber > dayNumber) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconst phaseText = await page.locator('[data-testid=\"phase-display\"]').textContent();\n\n\t\tif (phaseText?.includes('Afternoon')) {\n\t\t\tconst turnText = await page.locator('[data-testid=\"turn-indicator\"]').textContent();\n\t\t\tif (turnText?.includes('YOUR TURN')) {\n\t\t\t\tawait page.click('button:has-text(\"Pass Turn\")');\n\t\t\t} else {\n\t\t\t\tawait page.waitForTimeout(1000);\n\t\t\t}\n\t\t} else {\n\t\t\tawait page.click('button:has-text(\"Advance Phase\")');\n\t\t}\n\n\t\tawait page.waitForTimeout(1000);\n\t}\n}\n\nasync function spendMana(page: any, amount: number) {\n\tlet spentAmount = 0;\n\n\twhile (spentAmount < amount) {\n\t\tconst handCards = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]');\n\t\tconst cardCount = await handCards.count();\n\n\t\tif (cardCount === 0) break;\n\n\t\tfor (let i = 0; i < cardCount && spentAmount < amount; i++) {\n\t\t\tconst card = handCards.nth(i);\n\t\t\tconst costElement = card.locator('[data-testid=\"card-cost\"]');\n\t\t\tconst costText = await costElement.textContent();\n\t\t\tconst cost = parseInt(costText || '0');\n\n\t\t\tif (cost > 0 && cost <= amount - spentAmount) {\n\t\t\t\tawait card.click();\n\n\t\t\t\tconst expeditionZone = page.locator('[data-testid=\"expedition-zone\"][data-owner=\"self\"]');\n\t\t\t\tawait expeditionZone.click();\n\n\t\t\t\tawait page.waitForTimeout(1000);\n\t\t\t\tspentAmount += cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (spentAmount === 0) break; // No suitable cards found\n\t}\n}\n\nasync function findCardWithMinimumCost(page: any, minCost: number) {\n\tconst handCards = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]');\n\tconst cardCount = await handCards.count();\n\n\tfor (let i = 0; i < cardCount; i++) {\n\t\tconst card = handCards.nth(i);\n\t\tconst costElement = card.locator('[data-testid=\"card-cost\"]');\n\t\tconst costText = await costElement.textContent();\n\t\tconst cost = parseInt(costText || '0');\n\n\t\tif (cost >= minCost) {\n\t\t\treturn card;\n\t\t}\n\t}\n\treturn null;\n}\n\nasync function findCardWithExactCost(page: any, exactCost: number) {\n\tconst handCards = page.locator('[data-testid=\"player-hand\"] [data-testid=\"card\"]');\n\tconst cardCount = await handCards.count();\n\n\tfor (let i = 0; i < cardCount; i++) {\n\t\tconst card = handCards.nth(i);\n\t\tconst costElement = card.locator('[data-testid=\"card-cost\"]');\n\t\tconst costText = await costElement.textContent();\n\t\tconst cost = parseInt(costText || '0');\n\n\t\tif (cost === exactCost) {\n\t\t\treturn card;\n\t\t}\n\t}\n\treturn null;\n}\n\nasync function getManaMax(page: any): Promise<number> {\n\tconst manaDisplay = await page.locator('[data-testid=\"mana-display\"]').textContent();\n\treturn parseInt(manaDisplay?.split('/')[1] || '0');\n}\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/CardPlaySystem.test.ts",
		"messages": [
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'KeywordAbility' is not defined.",
				"line": 31,
				"column": 14,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 31,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 117,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 117,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [4117, 4118], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 134,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 134,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [4686, 4687], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 140,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 140,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [4928, 4929], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 141,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 141,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [4993, 4994], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 149,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 149,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [5303, 5304], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 151,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 151,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [5400, 5401], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 159,
				"column": 26,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 159,
				"endColumn": 33,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [5658, 5659], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 168,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 168,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [6053, 6054], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 173,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 173,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [6224, 6225], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 176,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 176,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [6336, 6337], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 182,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 182,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [6621, 6622], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 185,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 185,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [6687, 6688], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 194,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 194,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [6992, 6993], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 195,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 195,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [7057, 7058], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 204,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 204,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [7503, 7504], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 209,
				"column": 25,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 209,
				"endColumn": 77,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [7787, 7788], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 217,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 217,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [8118, 8119], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 222,
				"column": 25,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 222,
				"endColumn": 77,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [8376, 8377], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 228,
				"column": 27,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 228,
				"endColumn": 79
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 238,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 238,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [9072, 9073], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 253,
				"column": 35,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 253,
				"endColumn": 87
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 261,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 261,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [9914, 9915], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 282,
				"column": 35,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 282,
				"endColumn": 87
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 291,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 291,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10958, 10959], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 326,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 326,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [12314, 12315], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'expeditionZone' is assigned a value but never used.",
				"line": 334,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 334,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 334,
				"column": 27,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 334,
				"endColumn": 34,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [12653, 12654], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 360,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 360,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [13814, 13815], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 378,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 378,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [14678, 14679], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 379,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 379,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [14743, 14744], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 384,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 384,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [14971, 14972], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 394,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 394,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [15418, 15419], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 395,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 395,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [15456, 15457], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 399,
				"column": 27,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 399,
				"endColumn": 34,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [15678, 15679], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 401,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 401,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [15775, 15776], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 408,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 408,
				"endColumn": 57
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 437,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 437,
				"endColumn": 76
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'KeywordAbility' is not defined.",
				"line": 440,
				"column": 14,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 440,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 446,
				"column": 26,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 446,
				"endColumn": 33,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [17818, 17819], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 448,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 448,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [17921, 17922], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 458,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 458,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [18350, 18351], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 463,
				"column": 24,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 463,
				"endColumn": 31,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [18526, 18527], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 465,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 465,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [18622, 18623], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 471,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 471,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [18902, 18903], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 475,
				"column": 25,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 475,
				"endColumn": 32,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [19029, 19030], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 477,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 477,
				"endColumn": 24,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [19128, 19129], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 486,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 486,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [19472, 19473], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 490,
				"column": 25,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 490,
				"endColumn": 32,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [19609, 19610], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'KeywordAbility' is not defined.",
				"line": 499,
				"column": 20,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 499,
				"endColumn": 34
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 504,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 504,
				"endColumn": 24,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [20525, 20526], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 508,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 508,
				"endColumn": 57
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 517,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 517,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [21152, 21153], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 521,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 521,
				"endColumn": 57
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 535,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 535,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [21841, 21842], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 542,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 542,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [22192, 22193], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 547,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 547,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [22331, 22332], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 548,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 548,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [22402, 22403], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 549,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 549,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [22473, 22474], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'player' is assigned a value but never used.",
				"line": 555,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 555,
				"endColumn": 16
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'player' is assigned a value but never used.",
				"line": 578,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 578,
				"endColumn": 16
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 604,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 604,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [24330, 24331], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 607,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 607,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [24396, 24397], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 631,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 631,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [25292, 25293], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 6,
		"fatalErrorCount": 0,
		"warningCount": 58,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, test, expect, beforeEach } from 'bun:test';\nimport { CardPlaySystem } from '../../src/engine/CardPlaySystem';\nimport { GameStateManager } from '../../src/engine/GameStateManager';\nimport { EventBus } from '../../src/engine/EventBus';\nimport { CardType, StatusType, ZoneIdentifier, GamePhase } from '../../src/engine/types/enums';\nimport type { ICardDefinition } from '../../src/engine/types/cards';\n\n/**\n * Unit tests for CardPlaySystem - Rules 5.1 (Card Playing Process) and 5.2 (Playing from Reserve)\n * Following TDD methodology: write failing tests based on Altered rules, then fix implementation\n */\ndescribe('CardPlaySystem - Card Playing Rules', () => {\n\tlet cardPlaySystem: CardPlaySystem;\n\tlet gameStateManager: GameStateManager;\n\tlet eventBus: EventBus;\n\n\t// Define new card definitions as per requirements\n\tconst cardDef_FleetingTestSpell: ICardDefinition = {\n\t\tid: 'spell-fleeting-passive',\n\t\tname: 'Fleeting Passive Spell',\n\t\ttype: CardType.Spell,\n\t\tsubTypes: [],\n\t\thandCost: { total: 1 },\n\t\treserveCost: { total: 1 },\n\t\tfaction: 'Neutral',\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-passive-fleeting',\n\t\t\t\ttext: 'This spell is Fleeting.',\n\t\t\t\tabilityType: 'passive',\n\t\t\t\tkeyword: KeywordAbility.Fleeting, // Assuming KeywordAbility enum is imported\n\t\t\t\teffect: { steps: [] },\n\t\t\t\tisSupportAbility: false\n\t\t\t}\n\t\t],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_ExpeditionPermanent_001: ICardDefinition = {\n\t\tid: 'exp-permanent-001',\n\t\tname: 'Test Expedition Permanent',\n\t\ttype: CardType.Permanent,\n\t\tsubTypes: ['Gear'], // Example subType\n\t\tpermanentZoneType: ZoneIdentifier.ExpeditionZone, // Custom property to guide placement\n\t\thandCost: { total: 2 },\n\t\treserveCost: { total: 1 },\n\t\tfaction: 'Neutral',\n\t\tstatistics: {},\n\t\tabilities: [],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_LandmarkPermanent_001: ICardDefinition = {\n\t\tid: 'landmark-permanent-001',\n\t\tname: 'Test Landmark Permanent',\n\t\ttype: CardType.Permanent,\n\t\tsubTypes: ['Structure'], // Example subType\n\t\tpermanentZoneType: ZoneIdentifier.LandmarkZone, // Custom property to guide placement\n\t\thandCost: { total: 2 },\n\t\treserveCost: { total: 1 },\n\t\tfaction: 'Neutral',\n\t\tstatistics: {},\n\t\tabilities: [],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tbeforeEach(() => {\n\t\teventBus = new EventBus();\n\t\tconst mockCardDefinitions: ICardDefinition[] = [\n\t\t\t{\n\t\t\t\tid: 'character-001',\n\t\t\t\tname: 'Test Character',\n\t\t\t\ttype: CardType.Character,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 3, forest: 1, mountain: 1, water: 1 },\n\t\t\t\treserveCost: { total: 2, forest: 0, mountain: 1, water: 1 },\n\t\t\t\tfaction: 'Neutral',\n\t\t\t\tstatistics: { forest: 2, mountain: 1, water: 1 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'spell-001', // Non-fleeting spell\n\t\t\t\tname: 'Test Spell',\n\t\t\t\ttype: CardType.Spell,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 2, forest: 1, mountain: 0, water: 1 },\n\t\t\t\treserveCost: { total: 1, forest: 0, mountain: 0, water: 1 },\n\t\t\t\tfaction: 'Neutral',\n\t\t\t\tstatistics: { forest: 0, mountain: 0, water: 0 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t},\n\t\t\tcardDef_LandmarkPermanent_001, // Use the specific landmark permanent\n\t\t\tcardDef_FleetingTestSpell,\n\t\t\tcardDef_ExpeditionPermanent_001\n\t\t];\n\n\t\tgameStateManager = new GameStateManager(['player1', 'player2'], mockCardDefinitions, eventBus);\n\t\tcardPlaySystem = new CardPlaySystem(gameStateManager);\n\t\tgameStateManager.initializeGame();\n\t\tgameStateManager.setCurrentPhase(GamePhase.Afternoon); // Default to a phase where cards can be played\n\t\t// Clear any cost modifiers from previous tests if CardPlaySystem instance is reused across describe blocks (it's new here)\n\t\t// cardPlaySystem.clearCostModifiers('player1');\n\t\t// cardPlaySystem.clearCostModifiers('player2');\n\t});\n\n\tdescribe('Rule 5.1.2: Card Playing Process (4 Parts)', () => {\n\t\ttest('Rule 5.1.2.c: Part 1 - Declare Intent (reveal, choose modes, declare payment)', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\t\t\tplayer!.zones.handZone.add(card);\n\n\t\t\tconst intent = cardPlaySystem.declarePlayIntent('player1', card.id, {\n\t\t\t\tpaymentMethod: 'hand',\n\t\t\t\tchosenModes: [],\n\t\t\t\ttargetChoices: []\n\t\t\t});\n\n\t\t\texpect(intent.success).toBe(true);\n\t\t\texpect(intent.declaredCard).toBe(card.id);\n\t\t\texpect(intent.revealedToAll).toBe(true);\n\t\t\texpect(intent.paymentMethod).toBe('hand');\n\t\t});\n\n\t\ttest('Rule 5.1.2.g: Part 2 - Move to Limbo', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\t\t\tplayer!.zones.handZone.add(card);\n\n\t\t\tcardPlaySystem.declarePlayIntent('player1', card.id, { paymentMethod: 'hand' });\n\t\t\tconst moveResult = cardPlaySystem.moveToLimbo('player1', card.id);\n\n\t\t\texpect(moveResult.success).toBe(true);\n\t\t\texpect(player!.zones.handZone.contains(card.id)).toBe(false);\n\t\t\texpect(player!.zones.limboZone.contains(card.id)).toBe(true);\n\t\t});\n\n\t\ttest('Rule 5.1.2.h: Part 3 - Pay Costs (all costs paid simultaneously)', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\n\t\t\t// Setup mana\n\t\t\tplayer!.zones.manaZone.getAll().forEach((orb) => orb.statuses.delete(StatusType.Exhausted));\n\n\t\t\tplayer!.zones.limboZone.add(card);\n\n\t\t\tconst paymentResult = cardPlaySystem.payCosts('player1', card.id);\n\n\t\t\texpect(paymentResult.success).toBe(true);\n\t\t\texpect(paymentResult.costsDetail).toBeDefined();\n\n\t\t\t// Verify mana was spent\n\t\t\tconst exhaustedOrbs = player!.zones.manaZone\n\t\t\t\t.getAll()\n\t\t\t\t.filter((orb) => orb.statuses.has(StatusType.Exhausted));\n\t\t\texpect(exhaustedOrbs.length).toBeGreaterThan(0);\n\t\t});\n\n\t\ttest('Rule 5.1.2.i: Part 4 - Resolution (effect resolves, move to final zone)', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\t\t\tplayer!.zones.limboZone.add(card);\n\n\t\t\tconst resolutionResult = cardPlaySystem.resolveCard('player1', card.id);\n\n\t\t\texpect(resolutionResult.success).toBe(true);\n\t\t\texpect(player!.zones.limboZone.contains(card.id)).toBe(false);\n\n\t\t\t// Character should go to expedition zone\n\t\t\texpect(player!.zones.expeditionZone.contains(card.id)).toBe(true);\n\t\t});\n\n\t\ttest('Complete card playing process should work end-to-end', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\t\t\tplayer!.zones.handZone.add(card);\n\n\t\t\t// Setup sufficient mana\n\t\t\tplayer!.zones.manaZone.getAll().forEach((orb) => orb.statuses.delete(StatusType.Exhausted));\n\n\t\t\tconst playResult = cardPlaySystem._playCardForTestSteps('player1', card.id, {\n\t\t\t\tpaymentMethod: 'hand',\n\t\t\t\tchosenModes: [],\n\t\t\t\ttargetChoices: []\n\t\t\t});\n\n\t\t\texpect(playResult.success).toBe(true);\n\t\t\texpect(player!.zones.handZone.contains(card.id)).toBe(false);\n\t\t\texpect(player!.zones.expeditionZone.contains(card.id)).toBe(true);\n\t\t});\n\t});\n\n\tdescribe('Rule 5.1.2.d: Hand Cost vs Reserve Cost', () => {\n\t\ttest('Should use Hand Cost when playing from Hand', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\t\t\tconsole.log('[Test LOG] Created card object:', JSON.stringify(card, null, 2)); // Log the whole card\n\t\t\tplayer!.zones.handZone.add(card);\n\t\t\tconst idToPass = String(card?.id); // Use optional chaining for safety if id is indeed missing\n\n\t\t\tconst costCheck = cardPlaySystem.getPlayingCost('player1', idToPass, 'hand');\n\n\t\t\tconst expectedCost = gameStateManager.getCardDefinition('character-001')!.handCost;\n\t\t\texpect(costCheck.cost).toEqual(expectedCost);\n\t\t\texpect(costCheck.source).toBe('hand');\n\t\t});\n\n\t\ttest('Should use Reserve Cost when playing from Reserve', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\t\t\tplayer!.zones.reserveZone.add(card);\n\t\t\tconst idToPass = String(card.id); // Explicitly cast to string\n\n\t\t\tconst costCheck = cardPlaySystem.getPlayingCost('player1', idToPass, 'reserve');\n\n\t\t\tconst expectedCost = gameStateManager.getCardDefinition('character-001')!.reserveCost;\n\t\t\texpect(costCheck.cost).toEqual(expectedCost);\n\t\t\texpect(costCheck.source).toBe('reserve');\n\t\t});\n\n\t\ttest('Reserve cost should be lower than hand cost', () => {\n\t\t\tconst cardDefinition = gameStateManager.getCardDefinition('character-001')!; // Get definition for direct comparison\n\n\t\t\texpect(cardDefinition.reserveCost.total).toBeLessThan(cardDefinition.handCost.total);\n\t\t});\n\t});\n\n\tdescribe('Rule 5.1.2.e: Cost Alterations (Increases  Decreases  Restrictions)', () => {\n\t\ttest('Should apply cost increases first', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\t\t\tplayer!.zones.handZone.add(card); // ADDED THIS LINE\n\n\t\t\t// Add cost increase effect\n\t\t\tcardPlaySystem.addCostModifier('player1', {\n\t\t\t\ttype: 'increase',\n\t\t\t\tamount: { total: 1, forest: 0, mountain: 0, water: 0 },\n\t\t\t\tapplies: () => true\n\t\t\t});\n\t\t\tconst idToPassForIncrease = String(card.id); // Explicitly cast to string\n\n\t\t\tconst modifiedCostIncrease = cardPlaySystem.calculateModifiedCost(\n\t\t\t\t'player1',\n\t\t\t\tidToPassForIncrease,\n\t\t\t\t'hand'\n\t\t\t);\n\t\t\tconst cardDefinitionIncrease = gameStateManager.getCardDefinition('character-001')!;\n\n\t\t\texpect(modifiedCostIncrease.total).toBe(cardDefinitionIncrease.handCost.total + 1);\n\t\t});\n\n\t\ttest('Should apply cost decreases after increases', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\t\t\tplayer!.zones.handZone.add(card); // ADDED THIS LINE\n\n\t\t\t// Add both increase and decrease\n\t\t\tcardPlaySystem.addCostModifier('player1', {\n\t\t\t\ttype: 'increase',\n\t\t\t\tamount: { total: 2, forest: 0, mountain: 0, water: 0 },\n\t\t\t\tapplies: () => true\n\t\t\t});\n\n\t\t\tcardPlaySystem.addCostModifier('player1', {\n\t\t\t\ttype: 'decrease',\n\t\t\t\tamount: { total: 1, forest: 0, mountain: 0, water: 0 },\n\t\t\t\tapplies: () => true\n\t\t\t});\n\t\t\tconst idToPassForDecrease = String(card.id); // Explicitly cast to string\n\n\t\t\tconst modifiedCostDecrease = cardPlaySystem.calculateModifiedCost(\n\t\t\t\t'player1',\n\t\t\t\tidToPassForDecrease,\n\t\t\t\t'hand'\n\t\t\t);\n\t\t\tconst cardDefinitionDecrease = gameStateManager.getCardDefinition('character-001')!;\n\n\t\t\t// Should be original + 2 - 1 = original + 1\n\t\t\texpect(modifiedCostDecrease.total).toBe(cardDefinitionDecrease.handCost.total + 1);\n\t\t});\n\n\t\ttest('Should apply restrictions last', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\t\t\tplayer!.zones.handZone.add(card); // ADDED THIS LINE\n\n\t\t\t// Add restriction (e.g., can't be reduced below certain cost)\n\t\t\tcardPlaySystem.addCostModifier('player1', {\n\t\t\t\ttype: 'restriction',\n\t\t\t\trestriction: 'minimum',\n\t\t\t\tminimumCost: { total: 2, forest: 1, mountain: 1, water: 0 },\n\t\t\t\tapplies: () => true\n\t\t\t});\n\n\t\t\t// Try to reduce cost below minimum\n\t\t\tcardPlaySystem.addCostModifier('player1', {\n\t\t\t\ttype: 'decrease',\n\t\t\t\tamount: { total: 10, forest: 10, mountain: 10, water: 10 },\n\t\t\t\tapplies: () => true\n\t\t\t});\n\t\t\tconst idToPass = String(card.id); // Explicitly cast to string\n\n\t\t\tconst modifiedCost = cardPlaySystem.calculateModifiedCost('player1', idToPass, 'hand');\n\n\t\t\texpect(modifiedCost.total).toBeGreaterThanOrEqual(2);\n\t\t\texpect(modifiedCost.forest).toBeGreaterThanOrEqual(1);\n\t\t\texpect(modifiedCost.mountain).toBeGreaterThanOrEqual(1);\n\t\t});\n\t});\n\n\tdescribe('Rule 5.1.3: Character Card Placement', () => {\n\t\ttest('Characters should be placed in Expedition zone by default', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst character = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\n\t\t\tconst placementResult = cardPlaySystem.placeCharacter('player1', character.id);\n\n\t\t\texpect(placementResult.success).toBe(true);\n\t\t\texpect(placementResult.zone).toBe(ZoneIdentifier.Expedition);\n\t\t\texpect(player!.zones.expeditionZone.contains(character.id)).toBe(true);\n\t\t});\n\n\t\ttest('Should handle zone placement restrictions', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst character = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\n\t\t\t// Mock zone full condition\n\t\t\tconst expeditionZone = player!.zones.expeditionZone;\n\t\t\t// expeditionZone.setCapacity(0); // Force placement failure - BaseZone has no setCapacity\n\n\t\t\tconst placementResult = cardPlaySystem.placeCharacter('player1', character.id);\n\n\t\t\texpect(placementResult.success).toBe(false);\n\t\t\texpect(placementResult.error).toContain('zone full');\n\t\t});\n\t});\n\n\tdescribe('Rule 5.1.4: Permanent Card Placement', () => {\n\t\ttest('Landmark Permanents should be placed in Landmark zone', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\t// Use the specific landmark permanent ID\n\t\t\tconst permanent = gameStateManager.objectFactory.createCard(\n\t\t\t\tcardDef_LandmarkPermanent_001.id,\n\t\t\t\t'player1'\n\t\t\t);\n\n\t\t\t// Assuming placePermanent is called by resolveCard or a similar top-level play function\n\t\t\t// For this test, let's assume placePermanent correctly identifies it as a Landmark type\n\t\t\t// based on cardDef_LandmarkPermanent_001.permanentZoneType or other internal logic.\n\t\t\tconst placementResult = cardPlaySystem.placePermanent('player1', permanent.id);\n\n\t\t\texpect(placementResult.success).toBe(true);\n\t\t\texpect(placementResult.zone).toBe(ZoneIdentifier.LandmarkZone);\n\t\t\texpect(player!.zones.landmarkZone.contains(permanent.id)).toBe(true);\n\t\t});\n\n\t\ttest('Expedition Permanents should be placed in Expedition zone', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst permanent = gameStateManager.objectFactory.createCard(\n\t\t\t\tcardDef_ExpeditionPermanent_001.id,\n\t\t\t\t'player1'\n\t\t\t);\n\n\t\t\t// This test assumes that when cardPlaySystem.placePermanent is called,\n\t\t\t// it (or a preceding step like resolveCard) determines the correct zone.\n\t\t\t// If permanentZoneType is used, the system should respect it.\n\t\t\tconst placementResult = cardPlaySystem.placePermanent('player1', permanent.id);\n\n\t\t\texpect(placementResult.success).toBe(true);\n\t\t\t// The CardPlaySystem.placePermanent might be generic, and the actual zone determined by resolveCard.\n\t\t\t// Let's adjust to test via _playCardForTestSteps which handles resolution.\n\t\t\tplayer!.zones.handZone.add(permanent); // Add to hand to play\n\t\t\tplayer!.currentMana = 10; // Ensure mana\n\t\t\tconst playCompleteResult = cardPlaySystem._playCardForTestSteps('player1', permanent.id, {\n\t\t\t\tpaymentMethod: 'hand'\n\t\t\t});\n\t\t\texpect(playCompleteResult.success).toBe(true);\n\t\t\texpect(player!.zones.expeditionZone.contains(permanent.id)).toBe(true);\n\t\t});\n\t});\n\n\tdescribe('Rule 5.1.5 & 5.2.4.b: Spell Card Resolution Destination', () => {\n\t\ttest('Non-Fleeting Spells should resolve and go to Reserve (Rule 5.2.4.b)', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst spell = gameStateManager.objectFactory.createCard('spell-001', 'player1'); // spell-001 is non-Fleeting\n\n\t\t\t// Simulate full play process\n\t\t\tplayer!.zones.handZone.add(spell);\n\t\t\tplayer!.currentMana = 10;\n\t\t\tcardPlaySystem._playCardForTestSteps('player1', spell.id, { paymentMethod: 'hand' });\n\n\t\t\t// Assertion: Spell is in Reserve and not exhausted (unless it had Cooldown)\n\t\t\tconst spellInReserve = player!.zones.reserveZone.findById(spell.id);\n\t\t\texpect(spellInReserve).toBeDefined();\n\t\t\texpect(player!.zones.discardPileZone.contains(spell.id)).toBe(false);\n\t\t\t// Assuming Cooldown is a separate keyword that would make it exhausted.\n\t\t\t// For a basic spell, it should be ready in reserve.\n\t\t\texpect(spellInReserve?.statuses.has(StatusType.Exhausted)).toBe(false);\n\t\t});\n\n\t\ttest('Fleeting Spells should resolve and go to Discard pile (Rule 5.2.4.b implicitly, 2.4.6.e for spells)', async () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1')!;\n\t\t\tconst fleetingSpell = gameStateManager.objectFactory.createCard(\n\t\t\t\tcardDef_FleetingTestSpell.id,\n\t\t\t\tplayer.id\n\t\t\t);\n\t\t\tplayer.zones.handZone.add(fleetingSpell);\n\t\t\tplayer.currentMana = 10;\n\n\t\t\t// Play the fleeting spell\n\t\t\tconst playResult = cardPlaySystem._playCardForTestSteps(player.id, fleetingSpell.id, {\n\t\t\t\tpaymentMethod: 'hand'\n\t\t\t});\n\t\t\texpect(playResult.success).toBe(true);\n\n\t\t\t// Assertion: Spell is in Discard pile\n\t\t\texpect(player.zones.discardPileZone.findById(fleetingSpell.id)).toBeDefined();\n\t\t\texpect(player.zones.reserveZone.findById(fleetingSpell.id)).toBeUndefined();\n\t\t});\n\n\t\ttest('Spells with Cooldown should go to Reserve instead of Discard (and be Exhausted)', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst spell = gameStateManager.objectFactory.createCard('spell-001', 'player1'); // Normal spell\n\t\t\tplayer.zones.handZone.add(spell); // Add to hand to play\n\t\t\tplayer.currentMana = 10;\n\n\t\t\t// Manually add Cooldown to its definition for this test or have a specific Cooldown spell\n\t\t\t// For simplicity, let's assume a way to make THIS INSTANCE gain Cooldown for the test\n\t\t\t// or that the rule for Cooldown is checked by resolveSpell based on a property.\n\t\t\t// If Cooldown is a keyword:\n\t\t\tconst spellDef = gameStateManager.getCardDefinition(spell.definitionId)!;\n\t\t\tspellDef.abilities.push({\n\t\t\t\tabilityId: 'cooldown-abil',\n\t\t\t\tkeyword: KeywordAbility.Cooldown,\n\t\t\t\ttext: 'Cooldown'\n\t\t\t}); // Mock Cooldown\n\n\t\t\tcardPlaySystem._playCardForTestSteps('player1', spell.id, { paymentMethod: 'hand' });\n\n\t\t\tconst cardInReserve = player!.zones.reserveZone.findById(spell.id);\n\t\t\texpect(cardInReserve).toBeDefined();\n\t\t\texpect(cardInReserve!.statuses.has(StatusType.Exhausted)).toBe(true);\n\t\t\t// cleanup mock\n\t\t\tspellDef.abilities.pop();\n\t\t});\n\t});\n\n\tdescribe('Rule 5.2.4.a & 2.4.6.c: Fleeting Status Application and Resolution', () => {\n\t\ttest('Character played from Reserve should gain Fleeting in Limbo', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\t\t\tplayer!.zones.reserveZone.add(card);\n\n\t\t\t// Move to Limbo simulating playing from reserve\n\t\t\tcardPlaySystem.moveToLimbo('player1', card.id, 'reserve');\n\n\t\t\tconst cardInLimbo = player!.zones.limboZone.findById(card.id);\n\t\t\texpect(cardInLimbo).toBeDefined();\n\t\t\texpect(cardInLimbo!.statuses.has(StatusType.Fleeting)).toBe(true);\n\t\t});\n\n\t\ttest('Spell played from Reserve should gain Fleeting in Limbo', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst spell = gameStateManager.objectFactory.createCard('spell-001', 'player1');\n\t\t\tplayer!.zones.reserveZone.add(spell);\n\n\t\t\tcardPlaySystem.moveToLimbo('player1', spell.id, 'reserve');\n\n\t\t\tconst spellInLimbo = player!.zones.limboZone.findById(spell.id);\n\t\t\texpect(spellInLimbo).toBeDefined();\n\t\t\texpect(spellInLimbo!.statuses.has(StatusType.Fleeting)).toBe(true);\n\t\t});\n\n\t\ttest('Spell with passive Fleeting keyword gains Fleeting in Limbo when played from hand', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst fleetingSpell = gameStateManager.objectFactory.createCard(\n\t\t\t\tcardDef_FleetingTestSpell.id,\n\t\t\t\t'player1'\n\t\t\t);\n\t\t\tplayer!.zones.handZone.add(fleetingSpell);\n\n\t\t\tcardPlaySystem.moveToLimbo('player1', fleetingSpell.id, 'hand');\n\n\t\t\tconst spellInLimbo = player!.zones.limboZone.findById(fleetingSpell.id);\n\t\t\texpect(spellInLimbo).toBeDefined();\n\t\t\t// This relies on CardPlaySystem or ObjectFactory applying passive statuses when moving to Limbo or upon creation.\n\t\t\t// If not, this test might need adjustment to spy on status application or pre-apply it if passive handling is elsewhere.\n\t\t\t// For now, assume moveToLimbo (or a prior step in full play) handles passive status application.\n\t\t\t// A more robust way: check if the definition has passive fleeting, then the instance should get it.\n\t\t\tconst def = gameStateManager.getCardDefinition(fleetingSpell.definitionId);\n\t\t\tconst hasPassiveFleeting = def?.abilities.some(\n\t\t\t\t(a) =>\n\t\t\t\t\ta.keyword === KeywordAbility.Fleeting &&\n\t\t\t\t\t(a.abilityType === 'passive' || a.abilityType === 'keyword')\n\t\t\t);\n\t\t\texpect(hasPassiveFleeting).toBe(true);\n\t\t\t// And the instance should have it after moving to limbo\n\t\t\texpect(spellInLimbo!.statuses.has(StatusType.Fleeting)).toBe(true);\n\t\t});\n\n\t\ttest('Character played from Reserve (gains Fleeting) enters Expedition Zone with Fleeting', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1')!;\n\t\t\tconst character = gameStateManager.objectFactory.createCard('character-001', player.id);\n\t\t\tplayer.zones.reserveZone.add(character);\n\t\t\tplayer.currentMana = 10;\n\n\t\t\tcardPlaySystem._playCardForTestSteps(player.id, character.id, { paymentMethod: 'reserve' });\n\n\t\t\tconst charInExpedition = player.zones.expeditionZone.findById(character.id);\n\t\t\texpect(charInExpedition).toBeDefined();\n\t\t\texpect(charInExpedition!.statuses.has(StatusType.Fleeting)).toBe(true);\n\t\t});\n\n\t\ttest('Expedition Permanent played from Reserve (gains Fleeting) enters Expedition Zone with Fleeting', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1')!;\n\t\t\tconst expPermanent = gameStateManager.objectFactory.createCard(\n\t\t\t\tcardDef_ExpeditionPermanent_001.id,\n\t\t\t\tplayer.id\n\t\t\t);\n\t\t\tplayer.zones.reserveZone.add(expPermanent);\n\t\t\tplayer.currentMana = 10;\n\n\t\t\tcardPlaySystem._playCardForTestSteps(player.id, expPermanent.id, {\n\t\t\t\tpaymentMethod: 'reserve'\n\t\t\t});\n\n\t\t\tconst permInExpedition = player.zones.expeditionZone.findById(expPermanent.id);\n\t\t\texpect(permInExpedition).toBeDefined();\n\t\t\texpect(permInExpedition!.statuses.has(StatusType.Fleeting)).toBe(true);\n\t\t});\n\n\t\ttest('Fleeting card (Character) should go to Discard when leaving play from Expedition', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\t\t\tcard.statuses.add(StatusType.Fleeting);\n\t\t\tplayer!.zones.expeditionZone.add(card);\n\n\t\t\t// Simulate card leaving play\n\t\t\tcardPlaySystem.removeFromPlay('player1', card.id);\n\n\t\t\texpect(player!.zones.expeditionZone.contains(card.id)).toBe(false);\n\t\t\texpect(player!.zones.discardPileZone.contains(card.id)).toBe(true);\n\t\t\texpect(player!.zones.reserveZone.contains(card.id)).toBe(false); // Not to Reserve\n\t\t});\n\t});\n\n\tdescribe('Targeting and Validation', () => {\n\t\ttest('Should validate legal targets for card abilities', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst spell = gameStateManager.objectFactory.createCard('spell-001', 'player1');\n\n\t\t\t// Mock spell with targeting requirement\n\t\t\tspell.abilities = [\n\t\t\t\t{\n\t\t\t\t\ttype: 'triggered',\n\t\t\t\t\ttrigger: 'play',\n\t\t\t\t\teffect: 'deal_damage',\n\t\t\t\t\ttargets: ['character'],\n\t\t\t\t\tamount: 2\n\t\t\t\t}\n\t\t\t];\n\n\t\t\tconst targetValidation = cardPlaySystem.validateTargets('player1', spell.id, [\n\t\t\t\t'invalid-target'\n\t\t\t]);\n\n\t\t\texpect(targetValidation.valid).toBe(false);\n\t\t\texpect(targetValidation.errors).toContain('Invalid target');\n\t\t});\n\n\t\ttest('Should handle cards with no targeting requirements', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst character = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\n\t\t\tconst targetValidation = cardPlaySystem.validateTargets('player1', character.id, []);\n\n\t\t\texpect(targetValidation.valid).toBe(true);\n\t\t\texpect(targetValidation.errors).toHaveLength(0);\n\t\t});\n\t});\n\n\tdescribe('Error Handling', () => {\n\t\ttest('Should prevent playing cards not in valid zones', () => {\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\t\t\t// Card not in any zone\n\n\t\t\tconst playResult = cardPlaySystem._playCardForTestSteps('player1', card.id, {\n\t\t\t\tpaymentMethod: 'hand'\n\t\t\t});\n\n\t\t\texpect(playResult.success).toBe(false);\n\t\t\texpect(playResult.error).toBe('Card not found in playable zone');\n\t\t});\n\n\t\ttest('Should prevent playing with insufficient mana', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\t\t\tplayer!.zones.handZone.add(card);\n\n\t\t\t// Exhaust all mana orbs\n\t\t\tplayer!.zones.manaZone.getAll().forEach((orb) => orb.statuses.add(StatusType.Exhausted));\n\n\t\t\tconst playResult = cardPlaySystem._playCardForTestSteps('player1', card.id, {\n\t\t\t\tpaymentMethod: 'hand'\n\t\t\t});\n\n\t\t\texpect(playResult.success).toBe(false);\n\t\t\texpect(playResult.error).toBe('Insufficient mana');\n\t\t});\n\n\t\ttest('Should handle invalid player IDs', () => {\n\t\t\tconst playResult = cardPlaySystem._playCardForTestSteps('invalid-player', 'some-card', {\n\t\t\t\tpaymentMethod: 'hand'\n\t\t\t});\n\n\t\t\texpect(playResult.success).toBe(false);\n\t\t\texpect(playResult.error).toBe('Invalid player');\n\t\t});\n\n\t\ttest('Should prevent playing during incorrect phases', () => {\n\t\t\t// gameStateManager.setCurrentPhase(GamePhase.Dusk); // Cards can't be played during Dusk\n\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('character-001', 'player1');\n\t\t\tplayer!.zones.handZone.add(card);\n\n\t\t\tconst playResult = cardPlaySystem._playCardForTestSteps('player1', card.id, {\n\t\t\t\tpaymentMethod: 'hand'\n\t\t\t});\n\n\t\t\texpect(playResult.success).toBe(false);\n\t\t\texpect(playResult.error).toBe('Cannot play cards during current phase');\n\t\t});\n\t});\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/DeckMachine.test.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'DeckCard' is defined but never used.",
				"line": 4,
				"column": 15,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 4,
				"endColumn": 23
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'vi' is not defined.",
				"line": 56,
				"column": 1,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 56,
				"endColumn": 3
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'prevState' is assigned a value but never used.",
				"line": 269,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 269,
				"endColumn": 19
			}
		],
		"suppressedMessages": [],
		"errorCount": 3,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, it, expect, beforeEach } from 'bun:test';\nimport { createActor } from 'xstate';\nimport { deckMachine } from '../../src/lib/state/deckMachine';\nimport type { DeckCard } from '../../src/lib/deckValidation';\n\n// Mock card data matching DeckValidation.test.ts\nconst mockCardData = {\n\t// Axiom Hero\n\tALT_CORE_H_AX_01_C: {\n\t\tid: 'ALT_CORE_H_AX_01_C',\n\t\tname: 'Teija, Mage Intuitif',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Axiom',\n\t\trarity: 'Common',\n\t\timageUrl: 'test-url'\n\t},\n\t// Bravos Hero\n\tALT_CORE_H_BR_01_C: {\n\t\tid: 'ALT_CORE_H_BR_01_C',\n\t\tname: 'Rin, Soldat Dtermin',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Bravos',\n\t\trarity: 'Common',\n\t\timageUrl: 'test-url'\n\t},\n\t// Axiom Common Character\n\tALT_CORE_C_AX_01_C: {\n\t\tid: 'ALT_CORE_C_AX_01_C',\n\t\tname: 'Garde Axiome',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Axiom',\n\t\trarity: 'Common',\n\t\timageUrl: 'test-url'\n\t},\n\t// Axiom Rare Character\n\tALT_CORE_C_AX_02_R: {\n\t\tid: 'ALT_CORE_C_AX_02_R',\n\t\tname: 'Archiviste Axiome',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Axiom',\n\t\trarity: 'Rare',\n\t\timageUrl: 'test-url'\n\t},\n\t// Bravos Character (different faction)\n\tALT_CORE_C_BR_01_C: {\n\t\tid: 'ALT_CORE_C_BR_01_C',\n\t\tname: 'Guerrier Bravos',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Bravos',\n\t\trarity: 'Common',\n\t\timageUrl: 'test-url'\n\t}\n};\n\n// Mock the card data import\nvi.mock('../../src/data/cards', () => ({\n\tgetCardById: (id: string) => mockCardData[id as keyof typeof mockCardData] || null,\n\tallCards: Object.values(mockCardData)\n}));\n\ndescribe('Deck State Machine', () => {\n\tlet actor: ReturnType<typeof createActor>;\n\n\tbeforeEach(() => {\n\t\tactor = createActor(deckMachine);\n\t\tactor.start();\n\t});\n\n\tdescribe('Initial State', () => {\n\t\tit('should start in idle state', () => {\n\t\t\texpect(actor.getSnapshot().value).toBe('idle');\n\t\t});\n\n\t\tit('should have empty initial context', () => {\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.decks).toEqual([]);\n\t\t\texpect(snapshot.context.currentDeck).toBeNull();\n\t\t\texpect(snapshot.context.validationResult).toBeNull();\n\t\t\texpect(snapshot.context.error).toBeNull();\n\t\t});\n\t});\n\n\tdescribe('CREATE_DECK Action', () => {\n\t\tit('should create a new deck and transition to editing state', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck',\n\t\t\t\tdescription: 'A test deck',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.value).toBe('editing');\n\t\t\texpect(snapshot.context.currentDeck).not.toBeNull();\n\t\t\texpect(snapshot.context.currentDeck?.name).toBe('Test Deck');\n\t\t\texpect(snapshot.context.currentDeck?.description).toBe('A test deck');\n\t\t\texpect(snapshot.context.currentDeck?.format).toBe('constructed');\n\t\t\texpect(snapshot.context.currentDeck?.cards).toEqual([]);\n\t\t\texpect(snapshot.context.currentDeck?.heroId).toBeNull();\n\t\t\texpect(snapshot.context.currentDeck?.isValid).toBe(false);\n\t\t});\n\n\t\tit('should default to constructed format if not specified', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.format).toBe('constructed');\n\t\t});\n\n\t\tit('should create limited format deck when specified', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Limited Deck',\n\t\t\t\tformat: 'limited'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.format).toBe('limited');\n\t\t});\n\t});\n\n\tdescribe('SET_HERO Action', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\t\t});\n\n\t\tit('should set hero and trigger validation', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_HERO',\n\t\t\t\tcardId: 'ALT_CORE_H_AX_01_C'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.heroId).toBe('ALT_CORE_H_AX_01_C');\n\t\t\texpect(snapshot.context.validationResult).not.toBeNull();\n\t\t\texpect(snapshot.context.validationResult?.stats.heroCount).toBe(1);\n\t\t});\n\n\t\tit('should update deck validity based on validation', () => {\n\t\t\t// Add 39 cards to make deck valid\n\t\t\tfor (let i = 0; i < 39; i++) {\n\t\t\t\tactor.send({\n\t\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_HERO',\n\t\t\t\tcardId: 'ALT_CORE_H_AX_01_C'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.isValid).toBe(true);\n\t\t\texpect(snapshot.context.validationResult?.isValid).toBe(true);\n\t\t});\n\t});\n\n\tdescribe('ADD_CARD Action', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_HERO',\n\t\t\t\tcardId: 'ALT_CORE_H_AX_01_C'\n\t\t\t});\n\t\t});\n\n\t\tit('should add valid card to deck', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.cards).toHaveLength(1);\n\t\t\texpect(snapshot.context.currentDeck?.cards[0]).toEqual({\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C',\n\t\t\t\tquantity: 1\n\t\t\t});\n\t\t\texpect(snapshot.context.error).toBeNull();\n\t\t});\n\n\t\tit('should increment quantity for existing card', () => {\n\t\t\t// Add first copy\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t});\n\n\t\t\t// Add second copy\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.cards).toHaveLength(1);\n\t\t\texpect(snapshot.context.currentDeck?.cards[0]).toEqual({\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C',\n\t\t\t\tquantity: 2\n\t\t\t});\n\t\t});\n\n\t\tit('should prevent adding more than 3 copies in constructed format', () => {\n\t\t\t// Add 3 copies\n\t\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t\tactor.send({\n\t\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Try to add 4th copy\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.cards[0].quantity).toBe(3);\n\t\t\texpect(snapshot.context.error).toContain('Maximum 3 copies per card');\n\t\t});\n\n\t\tit('should prevent adding cards of wrong faction', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'ALT_CORE_C_BR_01_C' // Bravos card with Axiom hero\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.cards).toHaveLength(0);\n\t\t\texpect(snapshot.context.error).toContain(\n\t\t\t\t'Card faction (Bravos) must match Hero faction (Axiom)'\n\t\t\t);\n\t\t});\n\n\t\tit('should trigger validation after adding card', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.validationResult).not.toBeNull();\n\t\t\texpect(snapshot.context.validationResult?.stats.totalCards).toBe(2); // 1 card + 1 hero\n\t\t});\n\n\t\tit('should respect guard - canAddCard', () => {\n\t\t\t// Fill deck to limit for rare cards (15)\n\t\t\tfor (let i = 0; i < 15; i++) {\n\t\t\t\tactor.send({\n\t\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\t\tcardId: 'ALT_CORE_C_AX_02_R'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// This should be blocked by the guard before reaching the action\n\t\t\tconst prevState = actor.getSnapshot();\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_02_R'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\t// The guard should prevent this action from executing\n\t\t\t// The error should be set explaining why\n\t\t\texpect(snapshot.context.error).toContain('Maximum 15 rare cards allowed');\n\t\t});\n\t});\n\n\tdescribe('REMOVE_CARD Action', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_HERO',\n\t\t\t\tcardId: 'ALT_CORE_H_AX_01_C'\n\t\t\t});\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t});\n\t\t});\n\n\t\tit('should remove card from deck', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'REMOVE_CARD',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.cards).toHaveLength(0);\n\t\t});\n\n\t\tit('should trigger validation after removing card', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'REMOVE_CARD',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.validationResult).not.toBeNull();\n\t\t\texpect(snapshot.context.validationResult?.stats.totalCards).toBe(1); // Only hero left\n\t\t});\n\t});\n\n\tdescribe('UPDATE_CARD_QUANTITY Action', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_HERO',\n\t\t\t\tcardId: 'ALT_CORE_H_AX_01_C'\n\t\t\t});\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t});\n\t\t});\n\n\t\tit('should update card quantity', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'UPDATE_CARD_QUANTITY',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C',\n\t\t\t\tquantity: 3\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.cards[0].quantity).toBe(3);\n\t\t});\n\n\t\tit('should enforce maximum 3 copies in constructed format', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'UPDATE_CARD_QUANTITY',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C',\n\t\t\t\tquantity: 5\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.cards[0].quantity).toBe(3); // Capped at 3\n\t\t});\n\n\t\tit('should remove card if quantity is 0', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'UPDATE_CARD_QUANTITY',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C',\n\t\t\t\tquantity: 0\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.cards).toHaveLength(0);\n\t\t});\n\n\t\tit('should trigger validation after updating quantity', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'UPDATE_CARD_QUANTITY',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C',\n\t\t\t\tquantity: 2\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.validationResult).not.toBeNull();\n\t\t\texpect(snapshot.context.validationResult?.stats.totalCards).toBe(3); // 2 cards + 1 hero\n\t\t});\n\t});\n\n\tdescribe('SET_FORMAT Action', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\t\t});\n\n\t\tit('should change deck format', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_FORMAT',\n\t\t\t\tformat: 'limited'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.format).toBe('limited');\n\t\t});\n\n\t\tit('should trigger validation after format change', () => {\n\t\t\t// Add 5 copies of same card (invalid in constructed, valid in limited)\n\t\t\tfor (let i = 0; i < 5; i++) {\n\t\t\t\tactor.send({\n\t\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Should be invalid in constructed due to copy limit\n\t\t\tlet snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.validationResult?.isValid).toBe(false);\n\n\t\t\t// Switch to limited format\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_FORMAT',\n\t\t\t\tformat: 'limited'\n\t\t\t});\n\n\t\t\tsnapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.validationResult).not.toBeNull();\n\t\t\t// Should now be valid in limited format (no copy restrictions)\n\t\t\tconst hasValidQuantity = !snapshot.context.validationResult?.errors.some((e) =>\n\t\t\t\te.includes('copies')\n\t\t\t);\n\t\t\texpect(hasValidQuantity).toBe(true);\n\t\t});\n\t});\n\n\tdescribe('VALIDATE_DECK Action', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\t\t});\n\n\t\tit('should manually trigger validation', () => {\n\t\t\tactor.send({ type: 'VALIDATE_DECK' });\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.validationResult).not.toBeNull();\n\t\t\texpect(snapshot.context.validationResult?.isValid).toBe(false); // Missing hero and cards\n\t\t});\n\n\t\tit('should update deck validity based on validation result', () => {\n\t\t\t// Create a valid deck\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_HERO',\n\t\t\t\tcardId: 'ALT_CORE_H_AX_01_C'\n\t\t\t});\n\n\t\t\tfor (let i = 0; i < 39; i++) {\n\t\t\t\tactor.send({\n\t\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tactor.send({ type: 'VALIDATE_DECK' });\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.isValid).toBe(true);\n\t\t\texpect(snapshot.context.validationResult?.isValid).toBe(true);\n\t\t});\n\t});\n\n\tdescribe('Format-Specific Behavior', () => {\n\t\tdescribe('Constructed Format', () => {\n\t\t\tbeforeEach(() => {\n\t\t\t\tactor.send({\n\t\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\t\tname: 'Constructed Deck',\n\t\t\t\t\tformat: 'constructed'\n\t\t\t\t});\n\t\t\t\tactor.send({\n\t\t\t\t\ttype: 'SET_HERO',\n\t\t\t\t\tcardId: 'ALT_CORE_H_AX_01_C'\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should create a valid constructed deck following all rules', () => {\n\t\t\t\t// Add exactly 39 cards to meet minimum requirement\n\t\t\t\tfor (let i = 0; i < 39; i++) {\n\t\t\t\t\tactor.send({\n\t\t\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\t\texpect(snapshot.context.currentDeck?.isValid).toBe(true);\n\t\t\t\texpect(snapshot.context.validationResult?.isValid).toBe(true);\n\t\t\t\texpect(snapshot.context.validationResult?.stats.totalCards).toBe(40); // 39 + 1 hero\n\t\t\t\texpect(snapshot.context.validationResult?.errors).toHaveLength(0);\n\t\t\t});\n\n\t\t\tit('should reject deck below minimum size', () => {\n\t\t\t\t// Add only 30 cards (below 39 minimum)\n\t\t\t\tfor (let i = 0; i < 30; i++) {\n\t\t\t\t\tactor.send({\n\t\t\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\t\texpect(snapshot.context.currentDeck?.isValid).toBe(false);\n\t\t\t\texpect(snapshot.context.validationResult?.errors).toContain(\n\t\t\t\t\t'A constructed deck must include at least 39 non-Hero cards (currently 30)'\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('Limited Format', () => {\n\t\t\tbeforeEach(() => {\n\t\t\t\tactor.send({\n\t\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\t\tname: 'Limited Deck',\n\t\t\t\t\tformat: 'limited'\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should create valid limited deck without hero', () => {\n\t\t\t\t// Add 29 cards (minimum for limited)\n\t\t\t\tfor (let i = 0; i < 29; i++) {\n\t\t\t\t\tactor.send({\n\t\t\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\t\texpect(snapshot.context.currentDeck?.isValid).toBe(true);\n\t\t\t\texpect(snapshot.context.validationResult?.isValid).toBe(true);\n\t\t\t\texpect(snapshot.context.validationResult?.stats.totalCards).toBe(29);\n\t\t\t\texpect(snapshot.context.validationResult?.stats.heroCount).toBe(0);\n\t\t\t});\n\n\t\t\tit('should create valid limited deck with hero', () => {\n\t\t\t\tactor.send({\n\t\t\t\t\ttype: 'SET_HERO',\n\t\t\t\t\tcardId: 'ALT_CORE_H_AX_01_C'\n\t\t\t\t});\n\n\t\t\t\t// Add 29 cards (minimum for limited with hero)\n\t\t\t\tfor (let i = 0; i < 29; i++) {\n\t\t\t\t\tactor.send({\n\t\t\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\t\texpect(snapshot.context.currentDeck?.isValid).toBe(true);\n\t\t\t\texpect(snapshot.context.validationResult?.stats.totalCards).toBe(30); // 29 + 1 hero\n\t\t\t});\n\n\t\t\tit('should allow multiple copies beyond constructed limits', () => {\n\t\t\t\t// Add 10 copies of same card (would be invalid in constructed)\n\t\t\t\tfor (let i = 0; i < 29; i++) {\n\t\t\t\t\tactor.send({\n\t\t\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\t\tconst hasValidQuantity = !snapshot.context.validationResult?.errors.some((e) =>\n\t\t\t\t\te.includes('copies')\n\t\t\t\t);\n\t\t\t\texpect(hasValidQuantity).toBe(true);\n\t\t\t\texpect(snapshot.context.validationResult?.warnings).toContain(\n\t\t\t\t\t'Multiple copies of the same card - consider deck diversity'\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('Error Handling', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\t\t});\n\n\t\tit('should handle attempts to add non-existent cards', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'NON_EXISTENT_CARD'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.error).toContain('Card not found');\n\t\t});\n\n\t\tit('should clear errors when valid actions are performed', () => {\n\t\t\t// Cause an error\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'NON_EXISTENT_CARD'\n\t\t\t});\n\n\t\t\texpect(actor.getSnapshot().context.error).not.toBeNull();\n\n\t\t\t// Perform valid action\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_HERO',\n\t\t\t\tcardId: 'ALT_CORE_H_AX_01_C'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.error).toBeNull();\n\t\t});\n\t});\n\n\tdescribe('State Transitions', () => {\n\t\tit('should stay in editing state during deck building', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck'\n\t\t\t});\n\n\t\t\texpect(actor.getSnapshot().value).toBe('editing');\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_HERO',\n\t\t\t\tcardId: 'ALT_CORE_H_AX_01_C'\n\t\t\t});\n\n\t\t\texpect(actor.getSnapshot().value).toBe('editing');\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t});\n\n\t\t\texpect(actor.getSnapshot().value).toBe('editing');\n\n\t\t\tactor.send({ type: 'VALIDATE_DECK' });\n\n\t\t\texpect(actor.getSnapshot().value).toBe('editing');\n\t\t});\n\n\t\tit('should require deck to exist before deck actions', () => {\n\t\t\t// Try to add card without creating deck\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_01_C'\n\t\t\t});\n\n\t\t\t// Should not have transitioned or added card\n\t\t\texpect(actor.getSnapshot().value).toBe('idle');\n\t\t\texpect(actor.getSnapshot().context.currentDeck).toBeNull();\n\t\t});\n\t});\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/DeckMachineDirect.test.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'beforeSnapshot' is assigned a value but never used.",
				"line": 415,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 415,
				"endColumn": 24
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, it, expect, beforeEach, vi } from 'bun:test'; // Or from 'vitest' if that's the environment\nimport { createActor } from 'xstate';\nimport { deckMachine } from '../../src/lib/state/deckMachine';\nimport * as cardData from '../../src/data/cards';\n\n// Add this at the top of tests/unit/DeckMachineDirect.test.ts\nvi.mock('../../src/data/cards', async (importOriginal) => {\n\tconst actual = await importOriginal<typeof cardData>();\n\tconst mockCardsDb = new Map<string, cardData.AlteredCard | null>();\n\n\t// Helper to add mock cards\n\tconst addMockCard = (card: cardData.AlteredCard) => mockCardsDb.set(card.id, card);\n\n\t// Define mock cards\n\taddMockCard({\n\t\tid: 'hero_axiom_common',\n\t\tname: 'Axiom Common Hero',\n\t\ttype: 'Hros',\n\t\tfaction: 'Axiom',\n\t\trarity: 'Commun',\n\t\tcost: 0,\n\t\trecallCost: 0\n\t});\n\taddMockCard({\n\t\tid: 'hero_lyra_common',\n\t\tname: 'Lyra Common Hero',\n\t\ttype: 'Hros',\n\t\tfaction: 'Lyra',\n\t\trarity: 'Commun',\n\t\tcost: 0,\n\t\trecallCost: 0\n\t});\n\n\tfor (let i = 1; i <= 20; i++) {\n\t\t// For rare card limit tests\n\t\taddMockCard({\n\t\t\tid: `rare_ax_${i}`,\n\t\t\tname: `Rare Axiom Card ${i}`,\n\t\t\ttype: 'Personnage',\n\t\t\tfaction: 'Axiom',\n\t\t\trarity: 'Rare',\n\t\t\tcost: 1,\n\t\t\trecallCost: 1\n\t\t});\n\t}\n\tfor (let i = 1; i <= 5; i++) {\n\t\t// For unique card limit tests\n\t\taddMockCard({\n\t\t\tid: `unique_ax_${i}`,\n\t\t\tname: `Unique Axiom Card ${i}`,\n\t\t\ttype: 'Personnage',\n\t\t\tfaction: 'Axiom',\n\t\t\trarity: 'UNIQUE',\n\t\t\tcost: 1,\n\t\t\trecallCost: 1\n\t\t});\n\t}\n\tfor (let i = 0; i < 40; i++) {\n\t\t// For filler cards\n\t\taddMockCard({\n\t\t\tid: `common_ax_card_${i}`,\n\t\t\tname: `Common Axiom Card ${i}`,\n\t\t\ttype: 'Personnage',\n\t\t\tfaction: 'Axiom',\n\t\t\trarity: 'Commun',\n\t\t\tcost: 1,\n\t\t\trecallCost: 1\n\t\t});\n\t}\n\n\taddMockCard({\n\t\tid: 'rare_lyra_fs_card_1',\n\t\tname: 'Lyra FS Rare Card 1',\n\t\ttype: 'Personnage',\n\t\tfaction: 'Lyra',\n\t\trarity: 'Rare',\n\t\tcost: 1,\n\t\trecallCost: 1\n\t});\n\taddMockCard({\n\t\tid: 'neutral_common_card_1',\n\t\tname: 'Neutral Common Card 1',\n\t\ttype: 'Personnage',\n\t\tfaction: 'Neutre',\n\t\trarity: 'Commun',\n\t\tcost: 1,\n\t\trecallCost: 1\n\t});\n\taddMockCard({\n\t\tid: 'neutral_unique_card_1',\n\t\tname: 'Neutral Unique Card 1',\n\t\ttype: 'Personnage',\n\t\tfaction: 'Neutre',\n\t\trarity: 'UNIQUE',\n\t\tcost: 1,\n\t\trecallCost: 1\n\t});\n\taddMockCard({\n\t\tid: 'neutral_unique_card_2',\n\t\tname: 'Neutral Unique Card 2',\n\t\ttype: 'Personnage',\n\t\tfaction: 'Neutre',\n\t\trarity: 'UNIQUE',\n\t\tcost: 1,\n\t\trecallCost: 1\n\t});\n\n\taddMockCard({\n\t\tid: 'common_muna_card_1',\n\t\tname: 'Muna Common Card 1',\n\t\ttype: 'Personnage',\n\t\tfaction: 'Muna',\n\t\trarity: 'Commun',\n\t\tcost: 1,\n\t\trecallCost: 1\n\t});\n\taddMockCard({\n\t\tid: 'common_yzmir_card_1',\n\t\tname: 'Yzmir Common Card 1',\n\t\ttype: 'Personnage',\n\t\tfaction: 'Yzmir',\n\t\trarity: 'Commun',\n\t\tcost: 1,\n\t\trecallCost: 1\n\t});\n\n\treturn {\n\t\t...actual,\n\t\tgetCardById: vi.fn((cardId: string) => {\n\t\t\tif (mockCardsDb.has(cardId)) {\n\t\t\t\treturn Promise.resolve(mockCardsDb.get(cardId) ?? null);\n\t\t\t}\n\t\t\t// Fallback for any card ID not explicitly mocked, useful for other tests if they use real IDs.\n\t\t\t// For new tests, ensure all required card IDs are in mockCardsDb.\n\t\t\t// console.warn(`[Mock getCardById] Card ID not found, returning null: ${cardId}`);\n\t\t\treturn Promise.resolve(null); // Default to null if not in mock map for these tests\n\t\t})\n\t};\n});\n\ndescribe('Deck State Machine - Direct Tests', () => {\n\tlet actor: ReturnType<typeof createActor>;\n\n\tbeforeEach(() => {\n\t\tactor = createActor(deckMachine);\n\t\tactor.start();\n\t});\n\n\tdescribe('Initial State and Context', () => {\n\t\tit('should start in idle state with empty context', () => {\n\t\t\tconst snapshot = actor.getSnapshot();\n\n\t\t\texpect(snapshot.value).toBe('idle');\n\t\t\texpect(snapshot.context.decks).toEqual([]);\n\t\t\texpect(snapshot.context.currentDeck).toBeNull();\n\t\t\texpect(snapshot.context.selectedCards).toEqual([]);\n\t\t\texpect(snapshot.context.searchQuery).toBe('');\n\t\t\texpect(snapshot.context.filters).toEqual({});\n\t\t\texpect(snapshot.context.validationResult).toBeNull();\n\t\t\texpect(snapshot.context.isLoading).toBe(false);\n\t\t\texpect(snapshot.context.error).toBeNull();\n\t\t});\n\t});\n\n\tdescribe('CREATE_DECK Transition', () => {\n\t\tit('should transition from idle to editing on CREATE_DECK', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck',\n\t\t\t\tdescription: 'Test Description'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.value).toBe('editing');\n\t\t});\n\n\t\tit('should create deck with provided parameters', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'My Deck',\n\t\t\t\tdescription: 'My Description',\n\t\t\t\tformat: 'limited'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\tconst deck = snapshot.context.currentDeck;\n\n\t\t\texpect(deck).not.toBeNull();\n\t\t\texpect(deck?.name).toBe('My Deck');\n\t\t\texpect(deck?.description).toBe('My Description');\n\t\t\texpect(deck?.format).toBe('limited');\n\t\t\texpect(deck?.cards).toEqual([]);\n\t\t\texpect(deck?.heroId).toBeNull();\n\t\t\texpect(deck?.isValid).toBe(false);\n\t\t});\n\n\t\tit('should default to constructed format when not specified', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Default Deck'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.format).toBe('constructed');\n\t\t});\n\n\t\tit('should generate unique deck IDs', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Deck 1'\n\t\t\t});\n\t\t\tconst firstDeckId = actor.getSnapshot().context.currentDeck?.id;\n\n\t\t\t// Create a new machine for second deck\n\t\t\tconst actor2 = createActor(deckMachine);\n\t\t\tactor2.start();\n\t\t\tactor2.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Deck 2'\n\t\t\t});\n\t\t\tconst secondDeckId = actor2.getSnapshot().context.currentDeck?.id;\n\n\t\t\texpect(firstDeckId).toBeDefined();\n\t\t\texpect(secondDeckId).toBeDefined();\n\t\t\texpect(firstDeckId).not.toBe(secondDeckId);\n\t\t});\n\n\t\tit('should set created and updated timestamps', () => {\n\t\t\tconst beforeCreate = new Date();\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck'\n\t\t\t});\n\n\t\t\tconst deck = actor.getSnapshot().context.currentDeck;\n\t\t\tconst afterCreate = new Date();\n\n\t\t\texpect(deck?.createdAt).toBeDefined();\n\t\t\texpect(deck?.updatedAt).toBeDefined();\n\t\t\texpect(deck?.createdAt.getTime()).toBeGreaterThanOrEqual(beforeCreate.getTime());\n\t\t\texpect(deck?.createdAt.getTime()).toBeLessThanOrEqual(afterCreate.getTime());\n\t\t\texpect(deck?.updatedAt.getTime()).toBeGreaterThanOrEqual(deck?.createdAt.getTime());\n\t\t});\n\t});\n\n\tdescribe('State Persistence in Editing', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\t\t});\n\n\t\tit('should remain in editing state during deck operations', () => {\n\t\t\texpect(actor.getSnapshot().value).toBe('editing');\n\n\t\t\tactor.send({ type: 'VALIDATE_DECK' });\n\t\t\texpect(actor.getSnapshot().value).toBe('editing');\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'SEARCH_CARDS',\n\t\t\t\tquery: 'test'\n\t\t\t});\n\t\t\texpect(actor.getSnapshot().value).toBe('editing');\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'APPLY_FILTERS',\n\t\t\t\tfilters: { faction: 'Axiom' }\n\t\t\t});\n\t\t\texpect(actor.getSnapshot().value).toBe('editing');\n\t\t});\n\t});\n\n\tdescribe('SET_HERO Action', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck'\n\t\t\t});\n\t\t});\n\n\t\tit('should set hero ID and update timestamp', () => {\n\t\t\tconst beforeUpdate = actor.getSnapshot().context.currentDeck?.updatedAt;\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_HERO',\n\t\t\t\tcardId: 'hero_123'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\tconst deck = snapshot.context.currentDeck;\n\n\t\t\texpect(deck?.heroId).toBe('hero_123');\n\t\t\texpect(deck?.updatedAt.getTime()).toBeGreaterThan(beforeUpdate?.getTime() || 0);\n\t\t});\n\n\t\tit('should trigger validation after setting hero', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_HERO',\n\t\t\t\tcardId: 'hero_123'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.validationResult).not.toBeNull();\n\t\t});\n\t});\n\n\tdescribe('SET_FORMAT Action', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\t\t});\n\n\t\tit('should change deck format', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_FORMAT',\n\t\t\t\tformat: 'limited'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.format).toBe('limited');\n\t\t});\n\n\t\tit('should update timestamp when format changes', () => {\n\t\t\tconst beforeUpdate = actor.getSnapshot().context.currentDeck?.updatedAt;\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_FORMAT',\n\t\t\t\tformat: 'limited'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.updatedAt.getTime()).toBeGreaterThan(\n\t\t\t\tbeforeUpdate?.getTime() || 0\n\t\t\t);\n\t\t});\n\n\t\tit('should trigger validation after format change', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_FORMAT',\n\t\t\t\tformat: 'limited'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.validationResult).not.toBeNull();\n\t\t});\n\t});\n\n\tdescribe('ADD_CARD Action', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck'\n\t\t\t});\n\t\t});\n\n\t\tit('should require existing deck', () => {\n\t\t\t// Create new actor without deck\n\t\t\tconst newActor = createActor(deckMachine);\n\t\t\tnewActor.start();\n\n\t\t\tnewActor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'card_123'\n\t\t\t});\n\n\t\t\t// Should not transition from idle since no deck exists\n\t\t\texpect(newActor.getSnapshot().value).toBe('idle');\n\t\t\texpect(newActor.getSnapshot().context.currentDeck).toBeNull();\n\t\t});\n\n\t\tit('should update timestamp when adding cards', () => {\n\t\t\tconst beforeUpdate = actor.getSnapshot().context.currentDeck?.updatedAt;\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'card_123'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\tconst updatedAt = snapshot.context.currentDeck?.updatedAt;\n\n\t\t\t// May not add card due to validation, but timestamp should update if action processed\n\t\t\tif (snapshot.context.currentDeck) {\n\t\t\t\texpect(updatedAt?.getTime()).toBeGreaterThanOrEqual(beforeUpdate?.getTime() || 0);\n\t\t\t}\n\t\t});\n\n\t\tit('should trigger validation after attempting to add card', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'card_123'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\t// Validation should be triggered even if card addition fails\n\t\t\texpect(snapshot.context.validationResult).not.toBeNull();\n\t\t});\n\t});\n\n\tdescribe('REMOVE_CARD Action', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck'\n\t\t\t});\n\t\t});\n\n\t\tit('should handle removing non-existent cards gracefully', () => {\n\t\t\tconst beforeSnapshot = actor.getSnapshot();\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'REMOVE_CARD',\n\t\t\t\tcardId: 'non_existent_card'\n\t\t\t});\n\n\t\t\tconst afterSnapshot = actor.getSnapshot();\n\n\t\t\t// Should not crash and should remain in editing state\n\t\t\texpect(afterSnapshot.value).toBe('editing');\n\t\t\texpect(afterSnapshot.context.currentDeck?.cards).toEqual([]);\n\t\t});\n\n\t\tit('should update timestamp when removing cards', () => {\n\t\t\tconst beforeUpdate = actor.getSnapshot().context.currentDeck?.updatedAt;\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'REMOVE_CARD',\n\t\t\t\tcardId: 'card_123'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.updatedAt.getTime()).toBeGreaterThan(\n\t\t\t\tbeforeUpdate?.getTime() || 0\n\t\t\t);\n\t\t});\n\t});\n\n\tdescribe('UPDATE_CARD_QUANTITY Action', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck'\n\t\t\t});\n\t\t});\n\n\t\tit('should handle quantity updates for non-existent cards', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'UPDATE_CARD_QUANTITY',\n\t\t\t\tcardId: 'non_existent_card',\n\t\t\t\tquantity: 5\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.value).toBe('editing');\n\t\t\texpect(snapshot.context.currentDeck?.cards).toEqual([]);\n\t\t});\n\n\t\tit('should enforce quantity limits', () => {\n\t\t\t// First add a card, then try to update its quantity\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'card_123'\n\t\t\t});\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'UPDATE_CARD_QUANTITY',\n\t\t\t\tcardId: 'card_123',\n\t\t\t\tquantity: 10 // Higher than constructed limit\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\tconst deck = snapshot.context.currentDeck;\n\n\t\t\tif (deck && deck.cards.length > 0) {\n\t\t\t\t// Should be capped at format limit (3 for constructed)\n\t\t\t\texpect(deck.cards[0].quantity).toBeLessThanOrEqual(3);\n\t\t\t}\n\t\t});\n\n\t\tit('should remove cards with zero quantity', () => {\n\t\t\t// Add a card first\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'card_123'\n\t\t\t});\n\n\t\t\t// Set quantity to 0\n\t\t\tactor.send({\n\t\t\t\ttype: 'UPDATE_CARD_QUANTITY',\n\t\t\t\tcardId: 'card_123',\n\t\t\t\tquantity: 0\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\tconst cardExists = snapshot.context.currentDeck?.cards.some((c) => c.cardId === 'card_123');\n\t\t\texpect(cardExists).toBe(false);\n\t\t});\n\t});\n\n\tdescribe('VALIDATE_DECK Action', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck'\n\t\t\t});\n\t\t});\n\n\t\tit('should trigger manual validation', () => {\n\t\t\t// Clear any existing validation\n\t\t\texpect(actor.getSnapshot().context.validationResult).toBeNull();\n\n\t\t\tactor.send({ type: 'VALIDATE_DECK' });\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.validationResult).not.toBeNull();\n\t\t});\n\n\t\tit('should update deck validity based on validation', () => {\n\t\t\tactor.send({ type: 'VALIDATE_DECK' });\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\tconst deck = snapshot.context.currentDeck;\n\t\t\tconst validation = snapshot.context.validationResult;\n\n\t\t\texpect(deck?.isValid).toBe(validation?.isValid);\n\t\t});\n\t});\n\n\tdescribe('Search and Filter Actions', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck'\n\t\t\t});\n\t\t});\n\n\t\tit('should update search query', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'SEARCH_CARDS',\n\t\t\t\tquery: 'test search'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.searchQuery).toBe('test search');\n\t\t});\n\n\t\tit('should update filters', () => {\n\t\t\tconst filters = { faction: 'Axiom', rarity: 'Rare' };\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'APPLY_FILTERS',\n\t\t\t\tfilters\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.filters).toEqual(filters);\n\t\t});\n\n\t\tit('should clear filters', () => {\n\t\t\t// First set some filters\n\t\t\tactor.send({\n\t\t\t\ttype: 'APPLY_FILTERS',\n\t\t\t\tfilters: { faction: 'Axiom' }\n\t\t\t});\n\n\t\t\t// Then clear them\n\t\t\tactor.send({ type: 'CLEAR_FILTERS' });\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.filters).toEqual({});\n\t\t\texpect(snapshot.context.searchQuery).toBe('');\n\t\t});\n\t});\n\n\tdescribe('Error Handling', () => {\n\t\tbeforeEach(() => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck'\n\t\t\t});\n\t\t});\n\n\t\tit('should clear error on successful actions', () => {\n\t\t\t// Set an error manually (this would normally happen through validation)\n\t\t\tconst currentSnapshot = actor.getSnapshot();\n\t\t\tif (currentSnapshot.context.error) {\n\t\t\t\t// Error exists, now perform successful action\n\t\t\t\tactor.send({\n\t\t\t\t\ttype: 'SET_HERO',\n\t\t\t\t\tcardId: 'valid_hero'\n\t\t\t\t});\n\n\t\t\t\tconst newSnapshot = actor.getSnapshot();\n\t\t\t\texpect(newSnapshot.context.error).toBeNull();\n\t\t\t}\n\t\t});\n\n\t\tit('should preserve state consistency during errors', () => {\n\t\t\tconst beforeSnapshot = actor.getSnapshot();\n\n\t\t\t// Try an action that might cause an error\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'invalid_card'\n\t\t\t});\n\n\t\t\tconst afterSnapshot = actor.getSnapshot();\n\n\t\t\t// State should remain consistent\n\t\t\texpect(afterSnapshot.value).toBe('editing');\n\t\t\texpect(afterSnapshot.context.currentDeck?.name).toBe(\n\t\t\t\tbeforeSnapshot.context.currentDeck?.name\n\t\t\t);\n\t\t});\n\t});\n\n\tdescribe('Guards and Transitions', () => {\n\t\tit('should prevent invalid transitions', () => {\n\t\t\t// Try to save without a deck\n\t\t\tactor.send({ type: 'SAVE_DECK' });\n\n\t\t\t// Should remain in idle state\n\t\t\texpect(actor.getSnapshot().value).toBe('idle');\n\t\t});\n\n\t\tit('should allow valid transitions', () => {\n\t\t\t// Create deck should transition to editing\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck'\n\t\t\t});\n\n\t\t\texpect(actor.getSnapshot().value).toBe('editing');\n\t\t});\n\t});\n\n\tdescribe('Context Immutability', () => {\n\t\tit('should create new context objects on state changes', () => {\n\t\t\tconst initialContext = actor.getSnapshot().context;\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck'\n\t\t\t});\n\n\t\t\tconst newContext = actor.getSnapshot().context;\n\n\t\t\texpect(newContext).not.toBe(initialContext);\n\t\t\texpect(newContext.currentDeck).toBeDefined();\n\t\t});\n\n\t\tit('should preserve unchanged context properties', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Test Deck'\n\t\t\t});\n\n\t\t\tconst afterCreateContext = actor.getSnapshot().context;\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'SEARCH_CARDS',\n\t\t\t\tquery: 'test'\n\t\t\t});\n\n\t\t\tconst afterSearchContext = actor.getSnapshot().context;\n\n\t\t\t// Deck should remain the same reference when only search changes\n\t\t\texpect(afterSearchContext.currentDeck).toBe(afterCreateContext.currentDeck);\n\t\t\texpect(afterSearchContext.searchQuery).toBe('test');\n\t\t});\n\t});\n\n\tdescribe('Constructed Deck Validation Rules (based on Rulebook)', () => {\n\t\tlet constructedActor: ReturnType<typeof createActor>;\n\n\t\tbeforeEach(() => {\n\t\t\tconstructedActor = createActor(deckMachine);\n\t\t\tconstructedActor.start();\n\t\t\tconstructedActor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Constructed Rules Test Deck',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\t\t\tconstructedActor.send({ type: 'SET_HERO', cardId: 'hero_axiom_common' });\n\t\t\t// Pre-fill with 35 common Axiom cards to be close to minimums for focused tests\n\t\t\tfor (let i = 0; i < 35; i++) {\n\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: `common_ax_card_${i}` });\n\t\t\t}\n\t\t});\n\n\t\tdescribe('Unique Card Rule (1.1.4.g - Max 3 UNIQUE)', () => {\n\t\t\tit('should allow up to 3 unique cards', () => {\n\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: 'unique_ax_1' });\n\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: 'unique_ax_2' });\n\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: 'unique_ax_3' });\n\t\t\t\tconstructedActor.send({ type: 'VALIDATE_DECK' });\n\t\t\t\tconst snapshot = constructedActor.getSnapshot();\n\t\t\t\texpect(\n\t\t\t\t\tsnapshot.context.validationResult?.errors.some((e) =>\n\t\t\t\t\t\te.includes('Maximum 3 unique cards allowed')\n\t\t\t\t\t)\n\t\t\t\t).toBe(false);\n\t\t\t\t// Total cards include hero (1) + 35 common + 3 unique = 39. Min non-hero is 39. So this is valid.\n\t\t\t\texpect(snapshot.context.validationResult?.isValid).toBe(true);\n\t\t\t});\n\n\t\t\tit('should invalidate and error when adding a 4th distinct unique card', () => {\n\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: 'unique_ax_1' });\n\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: 'unique_ax_2' });\n\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: 'unique_ax_3' });\n\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: 'unique_ax_4' }); // 4th unique\n\t\t\t\tconstructedActor.send({ type: 'VALIDATE_DECK' });\n\t\t\t\tconst snapshot = constructedActor.getSnapshot();\n\t\t\t\texpect(snapshot.context.validationResult?.errors).toContain(\n\t\t\t\t\t'Maximum 3 unique cards allowed (currently 4)'\n\t\t\t\t);\n\t\t\t\texpect(snapshot.context.validationResult?.isValid).toBe(false);\n\t\t\t});\n\n\t\t\tit('should prevent adding more than 3 copies of the *same named* unique card (due to general 3-copy rule)', () => {\n\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: 'unique_ax_1' }); // qty 1\n\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: 'unique_ax_1' }); // qty 2\n\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: 'unique_ax_1' }); // qty 3\n\t\t\t\tconstructedActor.send({ type: 'VALIDATE_DECK' });\n\t\t\t\tlet snapshot = constructedActor.getSnapshot();\n\t\t\t\texpect(\n\t\t\t\t\tsnapshot.context.validationResult?.errors.some((e) =>\n\t\t\t\t\t\te.includes('Maximum 3 copies of \"Unique Axiom Card 1\" allowed')\n\t\t\t\t\t)\n\t\t\t\t).toBe(false);\n\n\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: 'unique_ax_1' }); // Attempt 4th copy\n\t\t\t\tconstructedActor.send({ type: 'VALIDATE_DECK' });\n\t\t\t\tsnapshot = constructedActor.getSnapshot();\n\t\t\t\texpect(snapshot.context.validationResult?.errors).toContain(\n\t\t\t\t\t'Maximum 3 copies of \"Unique Axiom Card 1\" allowed (currently 4)'\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('Rare Card Rule (1.1.4.f - Max 15 Rare/Faction-Shifted Rare)', () => {\n\t\t\tit('should allow up to 15 cards with rarity \"Rare\"', () => {\n\t\t\t\t// Deck has 35 commons + 1 hero. Add 4 more commons to meet 39 non-hero minimum.\n\t\t\t\tfor (let i = 35; i < 39; i++) {\n\t\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: `common_ax_card_${i}` });\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 1; i <= 15; i++) {\n\t\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: `rare_ax_${i}` });\n\t\t\t\t}\n\t\t\t\tconstructedActor.send({ type: 'VALIDATE_DECK' });\n\t\t\t\tconst snapshot = constructedActor.getSnapshot();\n\t\t\t\texpect(\n\t\t\t\t\tsnapshot.context.validationResult?.errors.some((e) =>\n\t\t\t\t\t\te.includes('Maximum 15 rare cards allowed')\n\t\t\t\t\t)\n\t\t\t\t).toBe(false);\n\t\t\t\texpect(snapshot.context.validationResult?.isValid).toBe(true);\n\t\t\t});\n\n\t\t\tit('should invalidate and error when adding a 16th card with rarity \"Rare\"', () => {\n\t\t\t\tfor (let i = 1; i <= 16; i++) {\n\t\t\t\t\t// Add 16 rare cards\n\t\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: `rare_ax_${i}` });\n\t\t\t\t}\n\t\t\t\tconstructedActor.send({ type: 'VALIDATE_DECK' });\n\t\t\t\tconst snapshot = constructedActor.getSnapshot();\n\t\t\t\texpect(snapshot.context.validationResult?.errors).toContain(\n\t\t\t\t\t'Maximum 15 rare cards allowed (currently 16)'\n\t\t\t\t);\n\t\t\t\texpect(snapshot.context.validationResult?.isValid).toBe(false);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('Neutral Card Rule (1.1.4.d)', () => {\n\t\t\tit('should allow Neutral cards and not count them against faction rules', () => {\n\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: 'neutral_common_card_1' });\n\t\t\t\tconstructedActor.send({ type: 'VALIDATE_DECK' });\n\t\t\t\tlet snapshot = constructedActor.getSnapshot();\n\t\t\t\t// Initial deck (35 commons + 1 hero + 1 neutral = 37 cards) is not yet 39 non-hero.\n\t\t\t\texpect(\n\t\t\t\t\tsnapshot.context.validationResult?.errors.some((e) =>\n\t\t\t\t\t\te.includes('All cards must be the same faction as the Hero')\n\t\t\t\t\t)\n\t\t\t\t).toBe(false);\n\t\t\t\texpect(\n\t\t\t\t\tsnapshot.context.currentDeck?.cards.some((c) => c.cardId === 'neutral_common_card_1')\n\t\t\t\t).toBe(true);\n\n\t\t\t\t// Add more cards to satisfy count\n\t\t\t\tfor (let i = 35; i < 38; i++) {\n\t\t\t\t\tconstructedActor.send({ type: 'ADD_CARD', cardId: `common_ax_card_${i}` });\n\t\t\t\t}\n\t\t\t\tconstructedActor.send({ type: 'VALIDATE_DECK' });\n\t\t\t\tsnapshot = constructedActor.getSnapshot();\n\t\t\t\texpect(snapshot.context.validationResult?.isValid).toBe(true);\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('Limited Deck Validation Rules (based on Rulebook)', () => {\n\t\tlet limitedActor: ReturnType<typeof createActor>;\n\t\tbeforeEach(() => {\n\t\t\tlimitedActor = createActor(deckMachine);\n\t\t\tlimitedActor.start();\n\t\t\tlimitedActor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Limited Rules Test Deck',\n\t\t\t\tformat: 'limited'\n\t\t\t});\n\t\t\t// Fill with 29 common Axiom cards for a base\n\t\t\tfor (let i = 0; i < 29; i++) {\n\t\t\t\tlimitedActor.send({ type: 'ADD_CARD', cardId: `common_ax_card_${i}` });\n\t\t\t}\n\t\t});\n\n\t\tit('should be valid with 0 heroes and 29 non-hero cards from 1 faction', () => {\n\t\t\tlimitedActor.send({ type: 'VALIDATE_DECK' });\n\t\t\tconst snapshot = limitedActor.getSnapshot();\n\t\t\texpect(snapshot.context.validationResult?.isValid).toBe(true);\n\t\t});\n\n\t\tit('should be valid with 1 hero and 29 non-hero cards (total 30 cards) from 1 faction', () => {\n\t\t\tlimitedActor.send({ type: 'SET_HERO', cardId: 'hero_axiom_common' });\n\t\t\tlimitedActor.send({ type: 'VALIDATE_DECK' });\n\t\t\tconst snapshot = limitedActor.getSnapshot();\n\t\t\texpect(snapshot.context.validationResult?.isValid).toBe(true);\n\t\t});\n\n\t\tit('should error if more than 1 hero is added', () => {\n\t\t\tlimitedActor.send({ type: 'SET_HERO', cardId: 'hero_axiom_common' });\n\t\t\t// deckMachine does not allow setting another hero directly if one is set.\n\t\t\t// This rule is typically enforced by how heroes are handled (usually only one slot).\n\t\t\t// The validator's heroCount > 1 check is more for data integrity if context somehow gets >1 hero.\n\t\t\t// For DeckMachine, adding a second hero isn't a direct event.\n\t\t\t// We can test the validator's output if the context was manually set, but direct machine test is tricky.\n\t\t\t// Let's assume the machine prevents >1 hero by its structure.\n\t\t\t// The validator part is tested in deckValidation.test.ts\n\t\t\tconst snapshot = limitedActor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.heroId).toBe('hero_axiom_common');\n\t\t\t// No direct way to send \"ADD_SECOND_HERO\" to machine.\n\t\t});\n\n\t\tit('should error if non-hero cards are less than 29', () => {\n\t\t\tlimitedActor.send({ type: 'CREATE_DECK', name: 'Too Few Cards Deck', format: 'limited' });\n\t\t\tlimitedActor.send({ type: 'SET_HERO', cardId: 'hero_axiom_common' });\n\t\t\tfor (let i = 0; i < 28; i++) {\n\t\t\t\t// Only 28 non-hero cards\n\t\t\t\tlimitedActor.send({ type: 'ADD_CARD', cardId: `common_ax_card_${i}` });\n\t\t\t}\n\t\t\tlimitedActor.send({ type: 'VALIDATE_DECK' });\n\t\t\tconst snapshot = limitedActor.getSnapshot();\n\t\t\texpect(snapshot.context.validationResult?.errors).toContain(\n\t\t\t\t'A limited deck must include at least 29 non-Hero cards (currently 28)'\n\t\t\t);\n\t\t});\n\n\t\tit('should allow up to 3 factions (hero faction + 2 others)', () => {\n\t\t\tlimitedActor.send({ type: 'SET_HERO', cardId: 'hero_axiom_common' }); // Faction 1: Axiom (cards are already Axiom)\n\t\t\tlimitedActor.send({ type: 'ADD_CARD', cardId: 'rare_lyra_fs_card_1' }); // Faction 2: Lyra\n\t\t\tlimitedActor.send({ type: 'ADD_CARD', cardId: 'common_muna_card_1' }); // Faction 3: Muna\n\t\t\tlimitedActor.send({ type: 'VALIDATE_DECK' });\n\t\t\tconst snapshot = limitedActor.getSnapshot();\n\t\t\texpect(\n\t\t\t\tsnapshot.context.validationResult?.errors.some((e) =>\n\t\t\t\t\te.includes('Maximum 3 factions allowed')\n\t\t\t\t)\n\t\t\t).toBe(false);\n\t\t\texpect(snapshot.context.validationResult?.isValid).toBe(true);\n\t\t});\n\n\t\tit('should error if more than 3 factions are present', () => {\n\t\t\tlimitedActor.send({ type: 'SET_HERO', cardId: 'hero_axiom_common' }); // Faction 1: Axiom\n\t\t\tlimitedActor.send({ type: 'ADD_CARD', cardId: 'rare_lyra_fs_card_1' }); // Faction 2: Lyra\n\t\t\tlimitedActor.send({ type: 'ADD_CARD', cardId: 'common_muna_card_1' }); // Faction 3: Muna\n\t\t\tlimitedActor.send({ type: 'ADD_CARD', cardId: 'common_yzmir_card_1' }); // Faction 4: Yzmir\n\t\t\tlimitedActor.send({ type: 'VALIDATE_DECK' });\n\t\t\tconst snapshot = limitedActor.getSnapshot();\n\t\t\t// The error message includes the hero's faction, then the others.\n\t\t\texpect(snapshot.context.validationResult?.errors).toContain(\n\t\t\t\t'Maximum 3 factions allowed in limited format (currently 4: Axiom, Lyra, Muna, Yzmir)'\n\t\t\t);\n\t\t});\n\n\t\tit('should have no unique/rare card limits in limited format', () => {\n\t\t\tfor (let i = 1; i <= 5; i++) {\n\t\t\t\t// Add 5 unique cards\n\t\t\t\tlimitedActor.send({ type: 'ADD_CARD', cardId: `unique_ax_${i}` });\n\t\t\t}\n\t\t\tfor (let i = 1; i <= 20; i++) {\n\t\t\t\t// Add 20 rare cards\n\t\t\t\tlimitedActor.send({ type: 'ADD_CARD', cardId: `rare_ax_${i}` });\n\t\t\t}\n\t\t\tlimitedActor.send({ type: 'VALIDATE_DECK' });\n\t\t\tconst snapshot = limitedActor.getSnapshot();\n\t\t\t// Deck size will be large, so it won't be \"isValid\" due to card count if not enough fillers\n\t\t\t// But no errors for rare/unique limits.\n\t\t\texpect(\n\t\t\t\tsnapshot.context.validationResult?.errors.some((e) => e.includes('unique cards allowed'))\n\t\t\t).toBe(false);\n\t\t\texpect(\n\t\t\t\tsnapshot.context.validationResult?.errors.some((e) => e.includes('rare cards allowed'))\n\t\t\t).toBe(false);\n\t\t});\n\t});\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/DeckMachineRealCards.test.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/DeckRulesEdgeCases.test.ts",
		"messages": [
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'vi' is not defined.",
				"line": 168,
				"column": 1,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 168,
				"endColumn": 3
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'cards' is assigned a value but never used.",
				"line": 397,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 397,
				"endColumn": 15
			}
		],
		"suppressedMessages": [],
		"errorCount": 2,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, it, expect, beforeEach } from 'bun:test';\nimport { DeckValidator, type DeckCard } from '../../src/lib/deckValidation';\nimport { createActor } from 'xstate';\nimport { deckMachine } from '../../src/lib/state/deckMachine';\n\n// Comprehensive mock card data covering edge cases\nconst mockCardData = {\n\t// Heroes from different factions\n\tALT_CORE_H_AX_01_C: {\n\t\tid: 'ALT_CORE_H_AX_01_C',\n\t\tname: 'Teija, Mage Intuitif',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Axiom',\n\t\trarity: 'Common'\n\t},\n\tALT_CORE_H_BR_01_C: {\n\t\tid: 'ALT_CORE_H_BR_01_C',\n\t\tname: 'Rin, Soldat Dtermin',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Bravos',\n\t\trarity: 'Common'\n\t},\n\tALT_CORE_H_LY_01_C: {\n\t\tid: 'ALT_CORE_H_LY_01_C',\n\t\tname: 'Sigrid, Veilleuse de Mmoire',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Lyra',\n\t\trarity: 'Common'\n\t},\n\tALT_CORE_H_MU_01_C: {\n\t\tid: 'ALT_CORE_H_MU_01_C',\n\t\tname: 'Kojo, Guide Spirituel',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Muna',\n\t\trarity: 'Common'\n\t},\n\n\t// Characters with same name but different transformations and factions (Rule 1.1.4 remark)\n\tALT_CORE_C_AX_01_C: {\n\t\tid: 'ALT_CORE_C_AX_01_C',\n\t\tname: 'Polymorphe',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Axiom',\n\t\trarity: 'Common'\n\t},\n\tALT_CORE_C_AX_01_R1: {\n\t\tid: 'ALT_CORE_C_AX_01_R1',\n\t\tname: 'Polymorphe',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Bravos',\n\t\trarity: 'Common' // Same name, different faction\n\t},\n\tALT_CORE_C_AX_01_R2: {\n\t\tid: 'ALT_CORE_C_AX_01_R2',\n\t\tname: 'Polymorphe',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Lyra',\n\t\trarity: 'Rare' // Same name, different faction and rarity\n\t},\n\n\t// Multiple rarity versions of same card\n\tALT_CORE_C_AX_02_C: {\n\t\tid: 'ALT_CORE_C_AX_02_C',\n\t\tname: 'Garde Versatile',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Axiom',\n\t\trarity: 'Common'\n\t},\n\tALT_CORE_C_AX_02_R: {\n\t\tid: 'ALT_CORE_C_AX_02_R',\n\t\tname: 'Garde Versatile',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Axiom',\n\t\trarity: 'Rare' // Same name/faction, different rarity\n\t},\n\tALT_CORE_C_AX_02_U: {\n\t\tid: 'ALT_CORE_C_AX_02_U',\n\t\tname: 'Garde Versatile',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Axiom',\n\t\trarity: 'Unique' // Same name/faction, unique rarity\n\t},\n\n\t// Regular cards for testing limits\n\tALT_CORE_C_AX_03_C: {\n\t\tid: 'ALT_CORE_C_AX_03_C',\n\t\tname: 'Soldat Axiome',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Axiom',\n\t\trarity: 'Common'\n\t},\n\tALT_CORE_C_AX_04_R: {\n\t\tid: 'ALT_CORE_C_AX_04_R',\n\t\tname: 'Elite Axiome',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Axiom',\n\t\trarity: 'Rare'\n\t},\n\tALT_CORE_C_AX_05_U: {\n\t\tid: 'ALT_CORE_C_AX_05_U',\n\t\tname: 'Champion Axiome',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Axiom',\n\t\trarity: 'Unique'\n\t},\n\n\t// Bravos cards for faction mixing tests\n\tALT_CORE_C_BR_01_C: {\n\t\tid: 'ALT_CORE_C_BR_01_C',\n\t\tname: 'Guerrier Bravos',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Bravos',\n\t\trarity: 'Common'\n\t},\n\tALT_CORE_C_BR_02_R: {\n\t\tid: 'ALT_CORE_C_BR_02_R',\n\t\tname: 'Veteran Bravos',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Bravos',\n\t\trarity: 'Rare'\n\t},\n\n\t// Lyra cards\n\tALT_CORE_C_LY_01_C: {\n\t\tid: 'ALT_CORE_C_LY_01_C',\n\t\tname: 'Sage Lyra',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Lyra',\n\t\trarity: 'Common'\n\t},\n\n\t// Muna cards\n\tALT_CORE_C_MU_01_C: {\n\t\tid: 'ALT_CORE_C_MU_01_C',\n\t\tname: 'Druide Muna',\n\t\ttype: 'CHARACTER',\n\t\tfaction: 'Muna',\n\t\trarity: 'Common'\n\t},\n\n\t// Cards without factions (edge case)\n\tALT_CORE_N_01_C: {\n\t\tid: 'ALT_CORE_N_01_C',\n\t\tname: 'Artefact Neutre',\n\t\ttype: 'PERMANENT',\n\t\tfaction: null,\n\t\trarity: 'Common'\n\t},\n\n\t// Non-character cards\n\tALT_CORE_S_AX_01_C: {\n\t\tid: 'ALT_CORE_S_AX_01_C',\n\t\tname: 'Sort Axiome',\n\t\ttype: 'SPELL',\n\t\tfaction: 'Axiom',\n\t\trarity: 'Common'\n\t},\n\tALT_CORE_P_AX_01_R: {\n\t\tid: 'ALT_CORE_P_AX_01_R',\n\t\tname: 'Monument Axiome',\n\t\ttype: 'PERMANENT',\n\t\tfaction: 'Axiom',\n\t\trarity: 'Rare'\n\t}\n};\n\n// Mock the card functions\nvi.mock('../../src/data/cards', () => ({\n\tgetCardById: (id: string) => mockCardData[id as keyof typeof mockCardData] || null,\n\tallCards: Object.values(mockCardData)\n}));\n\ndescribe('Deck Rules Edge Cases', () => {\n\tlet validator: DeckValidator;\n\n\tbeforeEach(() => {\n\t\tvalidator = new DeckValidator('constructed');\n\t});\n\n\tdescribe('Same Name, Different Characteristics (Rule 1.1.4 remark)', () => {\n\t\tit('should count cards with same name but different factions toward copy limit', () => {\n\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_01_C', quantity: 2 }, // Polymorphe (Axiom)\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_01_R1', quantity: 2 }, // Polymorphe (Bravos) - same name\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 35 } // Fill remaining\n\t\t\t];\n\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C'; // Axiom Hero\n\n\t\t\tconst result = validator.validate(cards, heroId);\n\n\t\t\t// Should fail because we have 4 total \"Polymorphe\" cards (exceeds 3 copy limit)\n\t\t\texpect(result.isValid).toBe(false);\n\t\t\texpect(result.errors).toContain('Maximum 3 copies of \"Polymorphe\" allowed (currently 4)');\n\n\t\t\t// Should also fail faction restriction (Bravos cards with Axiom hero)\n\t\t\texpect(result.errors.some((e) => e.includes('faction'))).toBe(true);\n\t\t});\n\n\t\tit('should count cards with same name but different rarities toward copy limit', () => {\n\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_C', quantity: 2 }, // Garde Versatile (Common)\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_R', quantity: 2 }, // Garde Versatile (Rare) - same name\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 35 } // Fill remaining\n\t\t\t];\n\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\tconst result = validator.validate(cards, heroId);\n\n\t\t\t// Should fail copy limit (4 total \"Garde Versatile\")\n\t\t\texpect(result.isValid).toBe(false);\n\t\t\texpect(result.errors).toContain(\n\t\t\t\t'Maximum 3 copies of \"Garde Versatile\" allowed (currently 4)'\n\t\t\t);\n\t\t});\n\n\t\tit('should respect rarity limits even with same-name cards', () => {\n\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_C', quantity: 1 }, // Garde Versatile (Common)\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_R', quantity: 1 }, // Garde Versatile (Rare)\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_U', quantity: 1 }, // Garde Versatile (Unique)\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_04_R', quantity: 14 }, // 14 more rares\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_05_U', quantity: 3 }, // 3 more uniques (total 4)\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 19 } // Fill remaining\n\t\t\t];\n\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\tconst result = validator.validate(cards, heroId);\n\n\t\t\t// Should pass copy limit (3 total \"Garde Versatile\")\n\t\t\texpect(result.stats.copyViolations.length).toBe(0);\n\n\t\t\t// Should pass rare limit (15 total rares)\n\t\t\texpect(result.stats.rarityBreakdown['Rare']).toBe(15);\n\n\t\t\t// Should fail unique limit (4 total uniques, max 3)\n\t\t\texpect(result.isValid).toBe(false);\n\t\t\texpect(result.errors).toContain('Maximum 3 unique cards allowed (currently 4)');\n\t\t});\n\t});\n\n\tdescribe('Boundary Conditions', () => {\n\t\tdescribe('Exact Limits', () => {\n\t\t\tit('should accept deck with exactly 39 non-Hero cards in constructed', () => {\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 39 }];\n\t\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.stats.totalCards).toBe(40); // 39 + 1 hero\n\t\t\t\texpect(result.errors.filter((e) => e.includes('39 non-Hero cards')).length).toBe(0);\n\t\t\t});\n\n\t\t\tit('should accept deck with exactly 15 rare cards in constructed', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_AX_04_R', quantity: 15 },\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 24 }\n\t\t\t\t];\n\t\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.stats.rarityBreakdown['Rare']).toBe(15);\n\t\t\t\texpect(result.errors.filter((e) => e.includes('rare cards')).length).toBe(0);\n\t\t\t});\n\n\t\t\tit('should accept deck with exactly 3 unique cards in constructed', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_AX_05_U', quantity: 3 },\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 36 }\n\t\t\t\t];\n\t\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.stats.rarityBreakdown['Unique']).toBe(3);\n\t\t\t\texpect(result.errors.filter((e) => e.includes('unique cards')).length).toBe(0);\n\t\t\t});\n\n\t\t\tit('should accept deck with exactly 29 non-Hero cards in limited', () => {\n\t\t\t\tvalidator.setFormat('limited');\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 29 }];\n\t\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.stats.totalCards).toBe(30); // 29 + 1 hero\n\t\t\t\texpect(result.errors.filter((e) => e.includes('29 non-Hero cards')).length).toBe(0);\n\t\t\t});\n\n\t\t\tit('should accept limited deck with exactly 3 factions', () => {\n\t\t\t\tvalidator.setFormat('limited');\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 10 }, // Axiom\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_BR_01_C', quantity: 10 }, // Bravos\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_LY_01_C', quantity: 9 } // Lyra\n\t\t\t\t];\n\n\t\t\t\tconst result = validator.validate(cards);\n\t\t\t\texpect(Object.keys(result.stats.factionBreakdown).length).toBe(3);\n\t\t\t\texpect(result.errors.filter((e) => e.includes('faction')).length).toBe(0);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('Off-by-One Errors', () => {\n\t\t\tit('should reject deck with 38 non-Hero cards in constructed', () => {\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 38 }];\n\t\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.isValid).toBe(false);\n\t\t\t\texpect(result.errors).toContain(\n\t\t\t\t\t'A constructed deck must include at least 39 non-Hero cards (currently 38)'\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tit('should reject deck with 16 rare cards in constructed', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_AX_04_R', quantity: 16 },\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 23 }\n\t\t\t\t];\n\t\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.isValid).toBe(false);\n\t\t\t\texpect(result.errors).toContain('Maximum 15 rare cards allowed (currently 16)');\n\t\t\t});\n\n\t\t\tit('should reject deck with 4 unique cards in constructed', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_AX_05_U', quantity: 4 },\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 35 }\n\t\t\t\t];\n\t\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.isValid).toBe(false);\n\t\t\t\texpect(result.errors).toContain('Maximum 3 unique cards allowed (currently 4)');\n\t\t\t});\n\n\t\t\tit('should reject deck with 28 non-Hero cards in limited', () => {\n\t\t\t\tvalidator.setFormat('limited');\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 28 }];\n\t\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.isValid).toBe(false);\n\t\t\t\texpect(result.errors).toContain(\n\t\t\t\t\t'A limited deck must include at least 29 non-Hero cards (currently 28)'\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tit('should reject limited deck with 4 factions', () => {\n\t\t\t\tvalidator.setFormat('limited');\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 8 }, // Axiom\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_BR_01_C', quantity: 7 }, // Bravos\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_LY_01_C', quantity: 7 }, // Lyra\n\t\t\t\t\t{ cardId: 'ALT_CORE_C_MU_01_C', quantity: 7 } // Muna (4th faction)\n\t\t\t\t];\n\n\t\t\t\tconst result = validator.validate(cards);\n\t\t\t\texpect(result.isValid).toBe(false);\n\t\t\t\texpect(result.errors).toContain(\n\t\t\t\t\t'Maximum 3 factions allowed in limited format (currently 4: Axiom, Bravos, Lyra, Muna)'\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('Complex Combinations', () => {\n\t\tit('should handle deck with maximum everything in constructed', () => {\n\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t// 15 rare cards (maximum)\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_04_R', quantity: 3 },\n\t\t\t\t{ cardId: 'ALT_CORE_P_AX_01_R', quantity: 3 },\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_R', quantity: 3 },\n\t\t\t\t{ cardId: 'ALT_CORE_C_BR_02_R', quantity: 3 }, // This will cause faction error but test rarity counting\n\t\t\t\t{ cardId: 'ALT_CORE_C_BR_02_R', quantity: 3 }, // Duplicate to reach 15\n\n\t\t\t\t// 3 unique cards (maximum)\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_05_U', quantity: 3 },\n\n\t\t\t\t// Fill remaining 21 cards with commons\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 21 }\n\t\t\t];\n\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\tconst result = validator.validate(cards, heroId);\n\n\t\t\t// Should have correct stats even if invalid due to factions\n\t\t\texpect(result.stats.totalCards).toBe(40); // 39 + 1 hero\n\t\t\texpect(result.stats.rarityBreakdown['Rare']).toBe(15);\n\t\t\texpect(result.stats.rarityBreakdown['Unique']).toBe(3);\n\n\t\t\t// Should fail faction restriction\n\t\t\texpect(result.isValid).toBe(false);\n\t\t\texpect(result.errors.some((e) => e.includes('faction'))).toBe(true);\n\t\t});\n\n\t\tit('should handle valid constructed deck with mixed rarities and exact limits', () => {\n\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t// 15 rare cards exactly\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_04_R', quantity: 3 },\n\t\t\t\t{ cardId: 'ALT_CORE_P_AX_01_R', quantity: 3 },\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_R', quantity: 3 },\n\t\t\t\t{ cardId: 'ALT_CORE_S_AX_01_C', quantity: 6 }, // This should be common, let's adjust\n\n\t\t\t\t// 3 unique cards exactly\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_05_U', quantity: 3 },\n\n\t\t\t\t// Remaining commons to reach exactly 39\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 30 }\n\t\t\t];\n\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\t// Recalculate to ensure we have exactly 15 rares\n\t\t\tconst validCards: DeckCard[] = [\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_04_R', quantity: 3 }, // 3 rares\n\t\t\t\t{ cardId: 'ALT_CORE_P_AX_01_R', quantity: 3 }, // 3 rares\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_R', quantity: 3 }, // 3 rares\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_C', quantity: 3 }, // 3 commons (same name as rare is allowed)\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_U', quantity: 3 }, // 3 uniques (same name)\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 24 } // 24 commons\n\t\t\t];\n\n\t\t\tconst result = validator.validate(validCards, heroId);\n\n\t\t\texpect(result.stats.totalCards).toBe(40);\n\t\t\texpect(result.stats.rarityBreakdown['Rare']).toBe(9); // Only 9 rares in this config\n\t\t\texpect(result.stats.rarityBreakdown['Unique']).toBe(3);\n\t\t\texpect(result.stats.copyViolations.length).toBe(0); // No copy violations\n\t\t\texpect(result.isValid).toBe(true);\n\t\t});\n\n\t\tit('should handle complex limited deck with multiple factions and no restrictions', () => {\n\t\t\tvalidator.setFormat('limited');\n\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t// Mix of factions (allowed in limited)\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 10 }, // Axiom commons\n\t\t\t\t{ cardId: 'ALT_CORE_C_BR_01_C', quantity: 10 }, // Bravos commons\n\t\t\t\t{ cardId: 'ALT_CORE_C_LY_01_C', quantity: 9 } // Lyra commons\n\n\t\t\t\t// Many copies of same card (allowed in limited)\n\t\t\t\t// No restrictions on rarity or copies\n\t\t\t];\n\n\t\t\tconst result = validator.validate(cards);\n\n\t\t\texpect(result.stats.totalCards).toBe(29);\n\t\t\texpect(Object.keys(result.stats.factionBreakdown).length).toBe(3);\n\t\t\texpect(result.isValid).toBe(true);\n\t\t\texpect(result.errors.length).toBe(0);\n\t\t});\n\t});\n\n\tdescribe('State Machine Integration Edge Cases', () => {\n\t\tlet actor: ReturnType<typeof createActor>;\n\n\t\tbeforeEach(() => {\n\t\t\tactor = createActor(deckMachine);\n\t\t\tactor.start();\n\t\t});\n\n\t\tit('should handle rapid format switching with validation', () => {\n\t\t\t// Create deck in constructed format\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Switch Test',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\n\t\t\t// Add cards that are invalid in constructed but valid in limited\n\t\t\tfor (let i = 0; i < 5; i++) {\n\t\t\t\tactor.send({\n\t\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\t\tcardId: 'ALT_CORE_C_AX_03_C'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.validationResult?.errors.some((e) => e.includes('copies'))).toBe(\n\t\t\t\ttrue\n\t\t\t);\n\n\t\t\t// Switch to limited\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_FORMAT',\n\t\t\t\tformat: 'limited'\n\t\t\t});\n\n\t\t\tsnapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.format).toBe('limited');\n\t\t\texpect(\n\t\t\t\tsnapshot.context.validationResult?.errors.filter((e) => e.includes('copies')).length\n\t\t\t).toBe(0);\n\n\t\t\t// Switch back to constructed\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_FORMAT',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\n\t\t\tsnapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.currentDeck?.format).toBe('constructed');\n\t\t\texpect(snapshot.context.validationResult?.errors.some((e) => e.includes('copies'))).toBe(\n\t\t\t\ttrue\n\t\t\t);\n\t\t});\n\n\t\tit('should prevent adding cards that would exceed rare limit', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Rare Limit Test',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_HERO',\n\t\t\t\tcardId: 'ALT_CORE_H_AX_01_C'\n\t\t\t});\n\n\t\t\t// Add 15 rare cards (maximum)\n\t\t\tfor (let i = 0; i < 15; i++) {\n\t\t\t\tactor.send({\n\t\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\t\tcardId: 'ALT_CORE_C_AX_04_R'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Try to add 16th rare card - should be prevented by guard\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'ALT_CORE_P_AX_01_R'\n\t\t\t});\n\n\t\t\tconst snapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.error).toContain('Maximum 15 rare cards allowed');\n\n\t\t\t// Verify that 16th rare card was not added\n\t\t\tconst rareCount = snapshot.context.validationResult?.stats.rarityBreakdown['Rare'] || 0;\n\t\t\texpect(rareCount).toBe(15);\n\t\t});\n\n\t\tit('should handle edge case of hero changing with existing cards', () => {\n\t\t\tactor.send({\n\t\t\t\ttype: 'CREATE_DECK',\n\t\t\t\tname: 'Hero Change Test',\n\t\t\t\tformat: 'constructed'\n\t\t\t});\n\n\t\t\t// Set Axiom hero and add Axiom cards\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_HERO',\n\t\t\t\tcardId: 'ALT_CORE_H_AX_01_C'\n\t\t\t});\n\n\t\t\tactor.send({\n\t\t\t\ttype: 'ADD_CARD',\n\t\t\t\tcardId: 'ALT_CORE_C_AX_03_C'\n\t\t\t});\n\n\t\t\tlet snapshot = actor.getSnapshot();\n\t\t\texpect(\n\t\t\t\tsnapshot.context.validationResult?.errors.filter((e) => e.includes('faction')).length\n\t\t\t).toBe(0);\n\n\t\t\t// Change to Bravos hero - should make existing Axiom cards invalid\n\t\t\tactor.send({\n\t\t\t\ttype: 'SET_HERO',\n\t\t\t\tcardId: 'ALT_CORE_H_BR_01_C'\n\t\t\t});\n\n\t\t\tsnapshot = actor.getSnapshot();\n\t\t\texpect(snapshot.context.validationResult?.errors.some((e) => e.includes('faction'))).toBe(\n\t\t\t\ttrue\n\t\t\t);\n\t\t\texpect(\n\t\t\t\tsnapshot.context.validationResult?.errors.some(\n\t\t\t\t\t(e) => e.includes('Axiom') && e.includes('Bravos')\n\t\t\t\t)\n\t\t\t).toBe(true);\n\t\t});\n\t});\n\n\tdescribe('canAddCard Edge Cases', () => {\n\t\tbeforeEach(() => {\n\t\t\tvalidator.setFormat('constructed');\n\t\t});\n\n\t\tit('should handle cards with null faction', () => {\n\t\t\tconst existingCards: DeckCard[] = [];\n\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\tconst result = validator.canAddCard(existingCards, 'ALT_CORE_N_01_C', heroId);\n\t\t\t// Cards without faction should be addable regardless of hero faction\n\t\t\texpect(result.canAdd).toBe(true);\n\t\t});\n\n\t\tit('should handle hero with null faction', () => {\n\t\t\tconst existingCards: DeckCard[] = [];\n\n\t\t\t// Test with undefined hero (edge case)\n\t\t\tconst result = validator.canAddCard(existingCards, 'ALT_CORE_C_AX_03_C', undefined);\n\t\t\texpect(result.canAdd).toBe(true); // Should allow when no hero restrictions\n\t\t});\n\n\t\tit('should handle non-existent card ID', () => {\n\t\t\tconst existingCards: DeckCard[] = [];\n\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\tconst result = validator.canAddCard(existingCards, 'NON_EXISTENT_CARD', heroId);\n\t\t\texpect(result.canAdd).toBe(false);\n\t\t\texpect(result.reason).toBe('Card not found');\n\t\t});\n\n\t\tit('should correctly calculate quantity for same-name cards with different IDs', () => {\n\t\t\tconst existingCards: DeckCard[] = [\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_C', quantity: 2 }, // Garde Versatile (Common)\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_R', quantity: 1 } // Garde Versatile (Rare)\n\t\t\t];\n\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\t// Try to add another copy (would be 4 total \"Garde Versatile\")\n\t\t\tconst result = validator.canAddCard(existingCards, 'ALT_CORE_C_AX_02_U', heroId);\n\t\t\texpect(result.canAdd).toBe(false);\n\t\t\texpect(result.reason).toBe('Maximum 3 copies per card in constructed format');\n\t\t});\n\t});\n\n\tdescribe('Statistical Edge Cases', () => {\n\t\tit('should correctly count statistics with complex deck composition', () => {\n\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t// Same name, different rarities\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_C', quantity: 1 }, // Common\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_R', quantity: 1 }, // Rare (same name)\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_02_U', quantity: 1 }, // Unique (same name)\n\n\t\t\t\t// Regular cards\n\t\t\t\t{ cardId: 'ALT_CORE_C_AX_03_C', quantity: 36 }\n\t\t\t];\n\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\tconst result = validator.validate(cards, heroId);\n\n\t\t\texpect(result.stats.totalCards).toBe(40); // 39 + 1 hero\n\t\t\texpect(result.stats.rarityBreakdown['Common']).toBe(38); // 1 + 36 + 1 hero\n\t\t\texpect(result.stats.rarityBreakdown['Rare']).toBe(1);\n\t\t\texpect(result.stats.rarityBreakdown['Unique']).toBe(1);\n\t\t\texpect(result.stats.factionBreakdown['Axiom']).toBe(40); // All Axiom including hero\n\t\t\texpect(result.stats.copyViolations.length).toBe(0); // 3 total of same name is ok\n\t\t\texpect(result.isValid).toBe(true);\n\t\t});\n\n\t\tit('should handle empty deck statistics', () => {\n\t\t\tconst cards: DeckCard[] = [];\n\n\t\t\tconst result = validator.validate(cards);\n\n\t\t\texpect(result.stats.totalCards).toBe(0);\n\t\t\texpect(result.stats.heroCount).toBe(0);\n\t\t\texpect(Object.keys(result.stats.factionBreakdown).length).toBe(0);\n\t\t\texpect(Object.keys(result.stats.rarityBreakdown).length).toBe(0);\n\t\t\texpect(result.stats.copyViolations.length).toBe(0);\n\t\t\texpect(result.isValid).toBe(false); // Invalid due to missing requirements\n\t\t});\n\n\t\tit('should handle deck with only hero', () => {\n\t\t\tconst cards: DeckCard[] = [];\n\t\t\tconst heroId = 'ALT_CORE_H_AX_01_C';\n\n\t\t\tconst result = validator.validate(cards, heroId);\n\n\t\t\texpect(result.stats.totalCards).toBe(1); // Only hero\n\t\t\texpect(result.stats.heroCount).toBe(1);\n\t\t\texpect(result.stats.factionBreakdown['Axiom']).toBe(1);\n\t\t\texpect(result.stats.rarityBreakdown['Common']).toBe(1);\n\t\t\texpect(result.isValid).toBe(false); // Invalid due to insufficient cards\n\t\t});\n\t});\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/DeckValidation.test.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'DeckFormat' is defined but never used.",
				"line": 2,
				"column": 45,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 2,
				"endColumn": 55
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, it, expect, beforeEach } from 'bun:test';\nimport { DeckValidator, type DeckCard, type DeckFormat } from '../../src/lib/deckValidation';\n\ndescribe('DeckValidator', () => {\n\tlet validator: DeckValidator;\n\n\t// Real card IDs from altered_optimized.json\n\tconst REAL_CARDS = {\n\t\t// Heroes\n\t\tHERO_AXIOM: 'ALT_ALIZE_B_AX_01_C', // Sierra & Oddball (Axiom Hero)\n\t\tHERO_BRAVOS: 'ALT_ALIZE_B_BR_01_C', // Kojo & Booda (Bravos Hero)\n\t\tHERO_LYRA: 'ALT_ALIZE_B_LY_02_C', // Lyra Hero\n\n\t\t// Axiom cards (same faction as HERO_AXIOM)\n\t\tAX_CHAR_COMMON: 'ALT_ALIZE_A_AX_35_C', // Vaike, l'nergticienne (Common)\n\t\tAX_CHAR_RARE: 'ALT_ALIZE_A_AX_35_R1', // Vaike, l'nergticienne (Rare)\n\t\tAX_LANDMARK_COMMON: 'ALT_ALIZE_A_AX_46_C', // Galeries Saisies par les Glaces (Common)\n\t\tAX_SPELL_COMMON: 'ALT_ALIZE_B_AX_41_C', // Livraison Gele (Common)\n\t\tAX_CHAR2_COMMON: 'ALT_ALIZE_B_AX_32_C', // La Machine dans la Glace (Common)\n\t\tAX_CHAR3_COMMON: 'ALT_ALIZE_B_AX_33_C', // Macareux  Roquettes (Common)\n\t\tAX_CHAR4_COMMON: 'ALT_ALIZE_B_AX_34_C', // La Petite Fille aux Allumettes (Common)\n\t\tAX_CHAR5_COMMON: 'ALT_ALIZE_B_AX_36_C', // claireur Morse (Common)\n\t\tAX_CHAR6_COMMON: 'ALT_ALIZE_B_AX_37_C', // Porteuse Intrpide (Common)\n\t\tAX_CHAR7_COMMON: 'ALT_ALIZE_B_AX_38_C', // Prototype Dfectueux (Common)\n\t\tAX_SCARABOT: 'ALT_ALIZE_B_AX_31_C', // Scarabot (Common)\n\t\tAX_VISHVAKARMA: 'ALT_ALIZE_B_AX_39_C', // Vishvakarma (Common)\n\t\tAX_GIBIL: 'ALT_ALIZE_B_AX_40_C', // Gibil (Common)\n\t\tAX_LANDMARK_RARE: 'ALT_ALIZE_A_AX_46_R1', // Galeries Saisies par les Glaces (Rare)\n\n\t\t// Bravos cards (different faction)\n\t\tBR_CHAR_COMMON: 'ALT_ALIZE_A_BR_37_C', // Gericht, Bretteur Honor (Common)\n\n\t\t// Cards with same name but different transformations\n\t\tVAIKE_AX_COMMON: 'ALT_ALIZE_A_AX_35_C', // Vaike (Axiom Common)\n\t\tVAIKE_AX_RARE: 'ALT_ALIZE_A_AX_35_R1', // Vaike (Axiom Rare)\n\n\t\t// Unknown cards for testing\n\t\tUNKNOWN_CARD: 'INVALID_CARD_ID_12345',\n\t\tUNKNOWN_HERO: 'INVALID_HERO_ID_67890'\n\t};\n\n\tbeforeEach(() => {\n\t\tvalidator = new DeckValidator('constructed');\n\t});\n\n\tdescribe('Constructed Format Rules (Rule 1.1.4)', () => {\n\t\tdescribe('Hero Requirements (Rule 1.1.4.b)', () => {\n\t\t\tit('should require exactly 1 Hero', () => {\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 30 }];\n\n\t\t\t\t// No hero provided\n\t\t\t\tconst result = validator.validate(cards);\n\t\t\t\texpect(result.isValid).toBe(false);\n\t\t\t\texpect(result.errors).toContain('A constructed deck must include exactly 1 Hero');\n\t\t\t});\n\n\t\t\tit('should accept exactly 1 Hero', () => {\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 39 }];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.stats.heroCount).toBe(1);\n\t\t\t\texpect(result.errors.filter((e) => e.includes('Hero')).length).toBe(0);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('Minimum Deck Size (Rule 1.1.4.c)', () => {\n\t\t\tit('should require at least 39 non-Hero cards', () => {\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 20 }];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.isValid).toBe(false);\n\t\t\t\texpect(result.errors).toContain(\n\t\t\t\t\t'A constructed deck must include at least 39 non-Hero cards (currently 20)'\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tit('should accept exactly 39 non-Hero cards + 1 Hero = 40 total', () => {\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 39 }];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.stats.totalCards).toBe(40); // 39 + 1 hero\n\t\t\t\texpect(result.errors.filter((e) => e.includes('39 non-Hero cards')).length).toBe(0);\n\t\t\t});\n\n\t\t\tit('should accept more than 39 non-Hero cards', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 3 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR2_COMMON, quantity: 3 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR3_COMMON, quantity: 3 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR4_COMMON, quantity: 3 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR5_COMMON, quantity: 3 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR6_COMMON, quantity: 3 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR7_COMMON, quantity: 3 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_SCARABOT, quantity: 3 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_VISHVAKARMA, quantity: 3 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_GIBIL, quantity: 3 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_LANDMARK_COMMON, quantity: 3 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_SPELL_COMMON, quantity: 3 },\n\t\t\t\t\t{ cardId: 'ALT_ALIZE_B_AX_42_C', quantity: 3 }, // Avalanche\n\t\t\t\t\t{ cardId: 'ALT_ALIZE_A_BR_46_R2', quantity: 3 }, // Pic Saisi par les Glaces\n\t\t\t\t\t{ cardId: 'ALT_ALIZE_A_YZ_46_R2', quantity: 2 } // Col Saisi par les Glaces (total: 44)\n\t\t\t\t];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.stats.totalCards).toBe(45); // 44 + 1 hero\n\t\t\t\texpect(result.errors.filter((e) => e.includes('39 non-Hero cards')).length).toBe(0);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('Faction Restrictions (Rule 1.1.4.d)', () => {\n\t\t\tit('should only allow cards of same faction as Hero', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 20 }, // Axiom cards\n\t\t\t\t\t{ cardId: REAL_CARDS.BR_CHAR_COMMON, quantity: 19 } // Bravos card - INVALID\n\t\t\t\t];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM; // Axiom Hero\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.isValid).toBe(false);\n\t\t\t\texpect(\n\t\t\t\t\tresult.errors.some((e) =>\n\t\t\t\t\t\te.includes(\n\t\t\t\t\t\t\t'All cards must be the same faction as the Hero (Axiom). Found cards from: Bravos'\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t).toBe(true);\n\t\t\t});\n\n\t\t\tit('should accept cards matching Hero faction', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 30 }, // Axiom cards\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_SPELL_COMMON, quantity: 9 } // Axiom spell\n\t\t\t\t];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM; // Axiom Hero\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.errors.filter((e) => e.includes('faction')).length).toBe(0);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('Copy Restrictions (Rule 1.1.4.e)', () => {\n\t\t\tit('should limit to maximum 3 cards with same name', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 4 }, // 4 copies - INVALID\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR2_COMMON, quantity: 35 }\n\t\t\t\t];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.isValid).toBe(false);\n\t\t\t\texpect(result.errors.some((e) => e.includes('Maximum 3 copies'))).toBe(true);\n\t\t\t});\n\n\t\t\tit('should count cards with same name but different IDs/transformations', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.VAIKE_AX_COMMON, quantity: 2 }, // 2 common Vaike\n\t\t\t\t\t{ cardId: REAL_CARDS.VAIKE_AX_RARE, quantity: 2 }, // 2 rare Vaike (same name)\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR2_COMMON, quantity: 35 }\n\t\t\t\t];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.isValid).toBe(false);\n\t\t\t\texpect(\n\t\t\t\t\tresult.errors.some((e) => e.includes('Maximum 3 copies') && e.includes('Vaike'))\n\t\t\t\t).toBe(true);\n\t\t\t});\n\n\t\t\tit('should allow exactly 3 copies of same name', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.VAIKE_AX_COMMON, quantity: 2 }, // 2 common Vaike\n\t\t\t\t\t{ cardId: REAL_CARDS.VAIKE_AX_RARE, quantity: 1 }, // 1 rare Vaike = 3 total\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR2_COMMON, quantity: 36 }\n\t\t\t\t];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.stats.copyViolations.length).toBe(1); // 36 copies of AX_CHAR2_COMMON is violation\n\t\t\t});\n\t\t});\n\n\t\tdescribe('Rarity Restrictions (Rule 1.1.4.f & 1.1.4.g)', () => {\n\t\t\tit('should limit to maximum 15 rare cards', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_RARE, quantity: 3 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_LANDMARK_RARE, quantity: 3 },\n\t\t\t\t\t{ cardId: 'ALT_ALIZE_B_AX_32_R1', quantity: 3 }, // Machine rare\n\t\t\t\t\t{ cardId: 'ALT_ALIZE_B_AX_33_R1', quantity: 3 }, // Macareux rare\n\t\t\t\t\t{ cardId: 'ALT_ALIZE_B_AX_34_R1', quantity: 3 }, // Petite Fille rare\n\t\t\t\t\t{ cardId: 'ALT_ALIZE_B_AX_36_R1', quantity: 2 }, // claireur rare (17 total rares)\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 22 }\n\t\t\t\t];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.isValid).toBe(false);\n\t\t\t\texpect(result.errors.some((e) => e.includes('Maximum 15 rare cards'))).toBe(true);\n\t\t\t});\n\n\t\t\tit('should allow exactly 15 rare cards', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_RARE, quantity: 3 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_LANDMARK_RARE, quantity: 3 },\n\t\t\t\t\t{ cardId: 'ALT_ALIZE_B_AX_32_R1', quantity: 3 }, // Machine rare\n\t\t\t\t\t{ cardId: 'ALT_ALIZE_B_AX_33_R1', quantity: 3 }, // Macareux rare\n\t\t\t\t\t{ cardId: 'ALT_ALIZE_B_AX_34_R1', quantity: 3 }, // Petite Fille rare (15 total)\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 24 }\n\t\t\t\t];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.errors.filter((e) => e.includes('Maximum 15 rare cards')).length).toBe(0);\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('Limited Format Rules (Rule 1.1.5)', () => {\n\t\tbeforeEach(() => {\n\t\t\tvalidator.setFormat('limited');\n\t\t});\n\n\t\tdescribe('Hero Requirements (Rule 1.1.5.b)', () => {\n\t\t\tit('should allow deck without Hero', () => {\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 29 }];\n\n\t\t\t\tconst result = validator.validate(cards); // No hero\n\t\t\t\texpect(result.errors.filter((e) => e.includes('Hero')).length).toBe(0);\n\t\t\t\texpect(result.stats.heroCount).toBe(0);\n\t\t\t});\n\n\t\t\tit('should allow deck with Hero', () => {\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 29 }];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.stats.heroCount).toBe(1);\n\t\t\t\texpect(result.stats.totalCards).toBe(30); // 29 + 1 hero\n\t\t\t});\n\n\t\t\tit('should reject more than 1 Hero', () => {\n\t\t\t\t// Can't easily test this with current API since heroId is a single string\n\t\t\t\t// This would require multiple heroes in the cards array, which isn't how the API works\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 29 }];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.stats.heroCount).toBe(1); // Should be exactly 1\n\t\t\t});\n\t\t});\n\n\t\tdescribe('Minimum Deck Size (Rule 1.1.5.c)', () => {\n\t\t\tit('should require at least 29 non-Hero cards', () => {\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 25 }];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.isValid).toBe(false);\n\t\t\t\texpect(result.errors).toContain(\n\t\t\t\t\t'A limited deck must include at least 29 non-Hero cards (currently 25)'\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tit('should accept exactly 29 non-Hero cards', () => {\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 29 }];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.stats.totalCards).toBe(30); // 29 + 1 hero\n\t\t\t\texpect(result.errors.filter((e) => e.includes('29 non-Hero cards')).length).toBe(0);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('Faction Restrictions (Rule 1.1.5.d)', () => {\n\t\t\tit('should allow cards from different factions', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 10 }, // Axiom\n\t\t\t\t\t{ cardId: REAL_CARDS.BR_CHAR_COMMON, quantity: 10 }, // Bravos\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR2_COMMON, quantity: 9 } // More Axiom\n\t\t\t\t];\n\n\t\t\t\tconst result = validator.validate(cards);\n\t\t\t\texpect(result.errors.filter((e) => e.includes('faction')).length).toBe(0);\n\t\t\t\texpect(Object.keys(result.stats.factionBreakdown).length).toBeLessThanOrEqual(3);\n\t\t\t});\n\n\t\t\tit('should reject more than 3 factions', () => {\n\t\t\t\t// This test would require 4 different factions, which might be hard to achieve\n\t\t\t\t// with limited card variety. Let's test the boundary case instead.\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 10 }, // Axiom\n\t\t\t\t\t{ cardId: REAL_CARDS.BR_CHAR_COMMON, quantity: 10 }, // Bravos\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR2_COMMON, quantity: 9 } // Axiom again\n\t\t\t\t];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_LYRA; // Lyra (3rd faction)\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\t// Should have 3 factions: Axiom, Bravos, Lyra\n\t\t\t\texpect(Object.keys(result.stats.factionBreakdown).length).toBe(3);\n\t\t\t\texpect(result.errors.filter((e) => e.includes('Maximum 3 factions')).length).toBe(0);\n\t\t\t});\n\n\t\t\tit('should count Hero faction as one of the three if Hero is included', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 15 }, // Axiom\n\t\t\t\t\t{ cardId: REAL_CARDS.BR_CHAR_COMMON, quantity: 14 } // Bravos\n\t\t\t\t];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_LYRA; // Lyra (3rd faction)\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\t// Should have 3 factions: Axiom, Bravos, Lyra\n\t\t\t\texpect(Object.keys(result.stats.factionBreakdown).length).toBe(3);\n\t\t\t\texpect(result.stats.factionBreakdown['Lyra']).toBe(1); // Hero counts\n\t\t\t});\n\t\t});\n\n\t\tdescribe('No Rarity/Copy Restrictions in Limited (Rule 1.1.5 remark)', () => {\n\t\t\tit('should allow any number of copies of same card', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 29 } // 29 copies of same card\n\t\t\t\t];\n\n\t\t\t\tconst result = validator.validate(cards);\n\t\t\t\texpect(result.errors.filter((e) => e.includes('copies')).length).toBe(0);\n\t\t\t\texpect(result.warnings.some((w) => w.includes('Multiple copies'))).toBe(true);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('Complete Valid Limited Deck', () => {\n\t\t\tit('should validate a legal limited deck with hero', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 10 },\n\t\t\t\t\t{ cardId: REAL_CARDS.BR_CHAR_COMMON, quantity: 10 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR2_COMMON, quantity: 9 }\n\t\t\t\t];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.validate(cards, heroId);\n\t\t\t\texpect(result.isValid).toBe(true);\n\t\t\t\texpect(result.errors.length).toBe(0);\n\t\t\t\texpect(result.stats.totalCards).toBe(30);\n\t\t\t\texpect(result.stats.heroCount).toBe(1);\n\t\t\t});\n\n\t\t\tit('should validate a legal limited deck without hero', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 10 },\n\t\t\t\t\t{ cardId: REAL_CARDS.BR_CHAR_COMMON, quantity: 10 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR2_COMMON, quantity: 9 }\n\t\t\t\t];\n\n\t\t\t\tconst result = validator.validate(cards);\n\t\t\t\texpect(result.isValid).toBe(true);\n\t\t\t\texpect(result.errors.length).toBe(0);\n\t\t\t\texpect(result.stats.totalCards).toBe(29);\n\t\t\t\texpect(result.stats.heroCount).toBe(0);\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('Format Switching', () => {\n\t\tit('should switch validation rules when format changes', () => {\n\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 5 }, // 5 copies - invalid in constructed\n\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR2_COMMON, quantity: 24 }\n\t\t\t];\n\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t// Constructed format - should fail copy limit\n\t\t\tvalidator.setFormat('constructed');\n\t\t\tconst constructedResult = validator.validate(cards, heroId);\n\t\t\texpect(constructedResult.isValid).toBe(false);\n\t\t\texpect(constructedResult.errors.some((e) => e.includes('copies'))).toBe(true);\n\n\t\t\t// Limited format - should pass (no copy restrictions)\n\t\t\tvalidator.setFormat('limited');\n\t\t\tconst limitedResult = validator.validate(cards, heroId);\n\t\t\texpect(limitedResult.errors.filter((e) => e.includes('copies')).length).toBe(0);\n\t\t});\n\t});\n\n\tdescribe('canAddCard Method', () => {\n\t\tdescribe('Constructed Format', () => {\n\t\t\tbeforeEach(() => {\n\t\t\t\tvalidator.setFormat('constructed');\n\t\t\t});\n\n\t\t\tit('should prevent adding 4th copy of same card', () => {\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 3 }];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.canAddCard(cards, REAL_CARDS.AX_CHAR_COMMON, heroId);\n\t\t\t\texpect(result.canAdd).toBe(false);\n\t\t\t\texpect(result.reason).toBe('Maximum 3 copies of \"Vaike, l\\'nergticienne\" allowed');\n\t\t\t});\n\n\t\t\tit('should prevent adding card with wrong faction', () => {\n\t\t\t\tconst cards: DeckCard[] = [];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM; // Axiom hero\n\n\t\t\t\tconst result = validator.canAddCard(cards, REAL_CARDS.BR_CHAR_COMMON, heroId); // Bravos card\n\t\t\t\texpect(result.canAdd).toBe(false);\n\t\t\t\texpect(result.reason).toContain('faction');\n\t\t\t});\n\n\t\t\tit('should prevent adding 16th rare card', () => {\n\t\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_RARE, quantity: 3 },\n\t\t\t\t\t{ cardId: REAL_CARDS.AX_LANDMARK_RARE, quantity: 3 },\n\t\t\t\t\t{ cardId: 'ALT_ALIZE_B_AX_32_R1', quantity: 3 }, // Machine rare\n\t\t\t\t\t{ cardId: 'ALT_ALIZE_B_AX_33_R1', quantity: 3 }, // Macareux rare\n\t\t\t\t\t{ cardId: 'ALT_ALIZE_B_AX_34_R1', quantity: 3 } // Petite Fille rare (15 total)\n\t\t\t\t];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.canAddCard(cards, 'ALT_ALIZE_B_AX_36_R1', heroId); // Try to add 16th rare\n\t\t\t\texpect(result.canAdd).toBe(false);\n\t\t\t\texpect(result.reason).toBe('Maximum 15 rare cards allowed');\n\t\t\t});\n\n\t\t\tit('should prevent adding 4th unique card', () => {\n\t\t\t\t// This test would need unique cards to be available in the dataset\n\t\t\t\t// For now, let's just verify the method exists and works\n\t\t\t\tconst cards: DeckCard[] = [];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.canAddCard(cards, REAL_CARDS.AX_CHAR_COMMON, heroId);\n\t\t\t\texpect(result.canAdd).toBe(true);\n\t\t\t});\n\n\t\t\tit('should allow adding valid card', () => {\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 2 }];\n\t\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM;\n\n\t\t\t\tconst result = validator.canAddCard(cards, REAL_CARDS.AX_CHAR2_COMMON, heroId);\n\t\t\t\texpect(result.canAdd).toBe(true);\n\t\t\t\texpect(result.reason).toBeUndefined();\n\t\t\t});\n\t\t});\n\n\t\tdescribe('Limited Format', () => {\n\t\t\tbeforeEach(() => {\n\t\t\t\tvalidator.setFormat('limited');\n\t\t\t});\n\n\t\t\tit('should allow adding multiple copies in limited format', () => {\n\t\t\t\tconst cards: DeckCard[] = [{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 10 }];\n\n\t\t\t\tconst result = validator.canAddCard(cards, REAL_CARDS.AX_CHAR_COMMON);\n\t\t\t\texpect(result.canAdd).toBe(true);\n\t\t\t\texpect(result.reason).toBeUndefined();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('Statistics Calculation', () => {\n\t\tit('should correctly calculate deck statistics', () => {\n\t\t\tconst cards: DeckCard[] = [\n\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_COMMON, quantity: 10 }, // 10 common characters\n\t\t\t\t{ cardId: REAL_CARDS.AX_CHAR_RARE, quantity: 5 }, // 5 rare characters\n\t\t\t\t{ cardId: REAL_CARDS.AX_LANDMARK_COMMON, quantity: 24 } // 24 common landmarks\n\t\t\t];\n\t\t\tconst heroId = REAL_CARDS.HERO_AXIOM; // Common hero\n\n\t\t\tconst result = validator.validate(cards, heroId);\n\n\t\t\texpect(result.stats.totalCards).toBe(40); // 39 + 1 hero\n\t\t\texpect(result.stats.heroCount).toBe(1);\n\t\t\texpect(result.stats.factionBreakdown['Axiom']).toBe(40); // All Axiom\n\t\t\texpect(result.stats.rarityBreakdown['Commun']).toBe(35); // 10 + 24 + 1 hero\n\t\t\texpect(result.stats.rarityBreakdown['Rare']).toBe(5);\n\t\t});\n\t});\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/DeckValidationDirect.test.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/DeckValidationRealCards.test.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/GameStateManager.test.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 88,
				"column": 12,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 88,
				"endColumn": 20,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [2775, 2776], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 89,
				"column": 12,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 89,
				"endColumn": 20,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [2857, 2858], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 114,
				"column": 23,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 114,
				"endColumn": 31,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3900, 3901], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 115,
				"column": 23,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 115,
				"endColumn": 31,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3947, 3948], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 135,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 135,
				"endColumn": 27,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [4627, 4628], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 136,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 136,
				"endColumn": 27,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [4670, 4671], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 153,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 153,
				"endColumn": 27,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [5252, 5253], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 154,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 154,
				"endColumn": 27,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [5295, 5296], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 171,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 171,
				"endColumn": 27,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [5830, 5831], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 172,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 172,
				"endColumn": 27,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [5873, 5874], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 200,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 200,
				"endColumn": 19,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [7006, 7007], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 201,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 201,
				"endColumn": 19,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [7085, 7086], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 202,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 202,
				"endColumn": 19,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [7148, 7149], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 203,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 203,
				"endColumn": 19,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [7206, 7207], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 206,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 206,
				"endColumn": 19,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [7332, 7333], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 207,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 207,
				"endColumn": 19,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [7391, 7392], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'player' is assigned a value but never used.",
				"line": 274,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 274,
				"endColumn": 16
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 16,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, test, expect, beforeEach } from 'bun:test';\nimport { GameStateManager } from '../../src/engine/GameStateManager';\nimport { EventBus } from '../../src/engine/EventBus';\nimport { GamePhase, ZoneIdentifier, CardType, StatusType } from '../../src/engine/types/enums';\nimport type { ICardDefinition } from '../../src/engine/types/cards';\n\n/**\n * Unit tests for GameStateManager - Rules 4.1 (Game Setup) and core game state management\n * Following TDD methodology: write failing tests based on Altered rules, then fix implementation\n */\ndescribe('GameStateManager - Rule Compliance Tests', () => {\n\tlet gameStateManager: GameStateManager;\n\tlet eventBus: EventBus;\n\tlet mockCardDefinitions: ICardDefinition[];\n\n\tbeforeEach(() => {\n\t\teventBus = new EventBus();\n\t\tmockCardDefinitions = [\n\t\t\t{\n\t\t\t\tid: 'hero-001',\n\t\t\t\tname: 'Test Hero',\n\t\t\t\ttype: CardType.Hero,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 0, forest: 0, mountain: 0, water: 0 },\n\t\t\t\treserveCost: { total: 0, forest: 0, mountain: 0, water: 0 },\n\t\t\t\tfaction: 'Neutral',\n\t\t\t\tstatistics: { forest: 2, mountain: 1, water: 1 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'companion-001',\n\t\t\t\tname: 'Test Companion',\n\t\t\t\ttype: CardType.Character,\n\t\t\t\tsubTypes: ['Companion'],\n\t\t\t\thandCost: { total: 2, forest: 1, mountain: 0, water: 1 },\n\t\t\t\treserveCost: { total: 1, forest: 0, mountain: 0, water: 1 },\n\t\t\t\tfaction: 'Neutral',\n\t\t\t\tstatistics: { forest: 1, mountain: 2, water: 0 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t}\n\t\t];\n\n\t\t// Add enough cards for deck construction (need at least 6 for drawing)\n\t\tfor (let i = 2; i <= 10; i++) {\n\t\t\tmockCardDefinitions.push({\n\t\t\t\tid: `card-${i}`,\n\t\t\t\tname: `Test Card ${i}`,\n\t\t\t\ttype: CardType.Spell,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 1, forest: 0, mountain: 0, water: 0 },\n\t\t\t\treserveCost: { total: 1, forest: 0, mountain: 0, water: 0 },\n\t\t\t\tfaction: 'Neutral',\n\t\t\t\tstatistics: { forest: 0, mountain: 0, water: 0 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t});\n\t\t}\n\n\t\tgameStateManager = new GameStateManager(['player1', 'player2'], mockCardDefinitions, eventBus);\n\t});\n\n\tdescribe('Rule 4.1: Game Setup Phase', () => {\n\t\ttest('Rule 4.1.a: Each player should have all required zones created', () => {\n\t\t\tconst player1 = gameStateManager.getPlayer('player1');\n\t\t\tconst player2 = gameStateManager.getPlayer('player2');\n\n\t\t\texpect(player1).toBeDefined();\n\t\t\texpect(player2).toBeDefined();\n\n\t\t\t// Rule 4.1.a: Players must have all required zones\n\t\t\tconst requiredZones = [\n\t\t\t\t'deckZone',\n\t\t\t\t'handZone',\n\t\t\t\t'discardPileZone',\n\t\t\t\t'expeditionZone',\n\t\t\t\t'manaZone',\n\t\t\t\t'reserveZone',\n\t\t\t\t'landmarkZone',\n\t\t\t\t'heroZone'\n\t\t\t];\n\n\t\t\trequiredZones.forEach((zoneName) => {\n\t\t\t\texpect(player1!.zones[zoneName as keyof typeof player1.zones]).toBeDefined();\n\t\t\t\texpect(player2!.zones[zoneName as keyof typeof player2.zones]).toBeDefined();\n\t\t\t});\n\t\t});\n\n\t\ttest('Rule 4.1.b: Adventure zone should be initialized with Hero and Companion regions', async () => {\n\t\t\tawait gameStateManager.initializeGame();\n\n\t\t\t// Adventure zone should contain regions for Hero and Companion\n\t\t\tconst adventureZone = gameStateManager.state.sharedZones.adventure;\n\t\t\texpect(adventureZone.getAll().length).toBeGreaterThanOrEqual(2); // Hero + Companion regions\n\n\t\t\t// Should contain 3 face-down Tumult cards between regions (Rule 4.1.c)\n\t\t\tconst tumultCards = adventureZone\n\t\t\t\t.getAll()\n\t\t\t\t.filter((entity) => entity.type === 'TumultCard' && entity.faceDown === true);\n\t\t\texpect(tumultCards).toHaveLength(3);\n\t\t});\n\n\t\ttest('Rule 4.1.h: Heroes should be revealed and placed in Hero zones', async () => {\n\t\t\t// Test assumes game setup has been called\n\t\t\tawait gameStateManager.initializeGame();\n\n\t\t\tconst player1 = gameStateManager.getPlayer('player1');\n\t\t\tconst player2 = gameStateManager.getPlayer('player2');\n\n\t\t\tconst p1HeroZone = player1!.zones.heroZone;\n\t\t\tconst p2HeroZone = player2!.zones.heroZone;\n\n\t\t\texpect(p1HeroZone.getAll().length).toBe(1);\n\t\t\texpect(p2HeroZone.getAll().length).toBe(1);\n\n\t\t\tconst p1Hero = p1HeroZone.getAll()[0];\n\t\t\tconst p2Hero = p2HeroZone.getAll()[0];\n\n\t\t\texpect(p1Hero.type).toBe(CardType.Hero);\n\t\t\texpect(p2Hero.type).toBe(CardType.Hero);\n\t\t\texpect(p1Hero.faceDown).toBe(false); // Heroes are revealed\n\t\t\texpect(p2Hero.faceDown).toBe(false);\n\t\t});\n\n\t\ttest('Rule 4.1.i: Each player deck should be shuffled and placed in Deck zone', async () => {\n\t\t\tawait gameStateManager.initializeGame();\n\n\t\t\tconst player1 = gameStateManager.getPlayer('player1');\n\t\t\tconst player2 = gameStateManager.getPlayer('player2');\n\n\t\t\tconst p1Deck = player1!.zones.deckZone;\n\t\t\tconst p2Deck = player2!.zones.deckZone;\n\n\t\t\texpect(p1Deck.getAll().length).toBeGreaterThan(0);\n\t\t\texpect(p2Deck.getAll().length).toBeGreaterThan(0);\n\n\t\t\t// Cards in deck are instances (hidden zone), not game objects\n\t\t\tp1Deck.getAll().forEach((card) => {\n\t\t\t\texpect(card.ownerId).toBeDefined(); // Verify they are valid card instances\n\t\t\t});\n\t\t});\n\n\t\ttest('Rule 4.1.j: Each player should draw 6 cards', async () => {\n\t\t\tawait gameStateManager.initializeGame();\n\n\t\t\tconst player1 = gameStateManager.getPlayer('player1');\n\t\t\tconst player2 = gameStateManager.getPlayer('player2');\n\n\t\t\tconst p1Hand = player1!.zones.handZone;\n\t\t\tconst p2Hand = player2!.zones.handZone;\n\n\t\t\texpect(p1Hand.getAll().length).toBe(6);\n\t\t\texpect(p2Hand.getAll().length).toBe(6);\n\n\t\t\t// Cards in hand should be face-up for the owner\n\t\t\tp1Hand.getAll().forEach((card) => {\n\t\t\t\texpect(card.faceDown).toBe(false);\n\t\t\t});\n\t\t});\n\n\t\ttest('Rule 4.1.k: Each player should start with 3 Mana Orbs face-down and ready', async () => {\n\t\t\tawait gameStateManager.initializeGame();\n\n\t\t\tconst player1 = gameStateManager.getPlayer('player1');\n\t\t\tconst player2 = gameStateManager.getPlayer('player2');\n\n\t\t\tconst p1Mana = player1!.zones.manaZone;\n\t\t\tconst p2Mana = player2!.zones.manaZone;\n\n\t\t\texpect(p1Mana.getAll().length).toBe(3);\n\t\t\texpect(p2Mana.getAll().length).toBe(3);\n\n\t\t\t// All mana orbs should be face-down and ready (not exhausted)\n\t\t\tp1Mana.getAll().forEach((orb) => {\n\t\t\t\texpect(orb.faceDown).toBe(true);\n\t\t\t\texpect(orb.statuses.has(StatusType.Exhausted)).toBe(false);\n\t\t\t\texpect(orb.type).toBe(CardType.ManaOrb); // Should be converted to Mana Orb type\n\t\t\t});\n\t\t});\n\n\t\ttest('Rule 4.1.l: Game should start on Day 1, first Morning phase should be skipped', async () => {\n\t\t\tawait gameStateManager.initializeGame();\n\n\t\t\texpect(gameStateManager.state.currentDay).toBe(1);\n\t\t\texpect(gameStateManager.state.currentPhase).toBe(GamePhase.Noon); // First Morning skipped\n\t\t\texpect(gameStateManager.state.firstMorningSkipped).toBe(true);\n\t\t});\n\n\t\ttest('Rule 4.1: Expedition counters should be placed in corresponding regions', async () => {\n\t\t\tawait gameStateManager.initializeGame();\n\n\t\t\tconst player1 = gameStateManager.getPlayer('player1');\n\t\t\tconst player2 = gameStateManager.getPlayer('player2');\n\n\t\t\t// Each player should have expedition counters in Hero and Companion regions\n\t\t\texpect(player1!.expeditionState.heroPosition).toBe(0); // Starting position\n\t\t\texpect(player1!.expeditionState.companionPosition).toBe(0);\n\t\t\texpect(player2!.expeditionState.heroPosition).toBe(0);\n\t\t\texpect(player2!.expeditionState.companionPosition).toBe(0);\n\n\t\t\t// Expeditions should be active and tracking their regions\n\t\t\texpect(player1!.expeditionState.heroActive).toBe(true);\n\t\t\texpect(player1!.expeditionState.companionActive).toBe(true);\n\t\t});\n\t});\n\n\tdescribe('Core Game State Management', () => {\n\t\ttest('should maintain proper turn order and initiative', async () => {\n\t\t\tawait gameStateManager.initializeGame();\n\n\t\t\t// First player should be determined (Rule 1.4.5: Initiative Order)\n\t\t\texpect(gameStateManager.state.firstPlayerId).toBeDefined();\n\t\t\texpect(['player1', 'player2']).toContain(gameStateManager.state.firstPlayerId);\n\n\t\t\t// Current player should start as first player\n\t\t\texpect(gameStateManager.state.currentPlayerId).toBe(gameStateManager.state.firstPlayerId);\n\t\t});\n\n\t\ttest('should handle phase transitions correctly', async () => {\n\t\t\tawait gameStateManager.initializeGame();\n\n\t\t\tconst initialPhase = gameStateManager.state.currentPhase;\n\t\t\texpect(initialPhase).toBe(GamePhase.Noon);\n\n\t\t\t// Should be able to advance to next phase\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Afternoon);\n\t\t\texpect(gameStateManager.state.currentPhase).toBe(GamePhase.Afternoon);\n\t\t});\n\n\t\ttest('should track victory conditions', async () => {\n\t\t\tawait gameStateManager.initializeGame();\n\n\t\t\t// Game should not be over initially\n\t\t\texpect(gameStateManager.state.gameEnded).toBe(false);\n\t\t\texpect(gameStateManager.state.winner).toBeUndefined();\n\n\t\t\t// Should be able to set winner\n\t\t\tgameStateManager.setGameWinner('player1');\n\t\t\texpect(gameStateManager.state.gameEnded).toBe(true);\n\t\t\texpect(gameStateManager.state.winner).toBe('player1');\n\t\t});\n\n\t\ttest('should handle tiebreaker state correctly', async () => {\n\t\t\tawait gameStateManager.initializeGame();\n\n\t\t\t// Should not be in tiebreaker initially\n\t\t\texpect(gameStateManager.state.tiebreakerMode).toBe(false);\n\n\t\t\t// Should be able to enter tiebreaker mode\n\t\t\tgameStateManager.enterTiebreakerMode();\n\t\t\texpect(gameStateManager.state.tiebreakerMode).toBe(true);\n\n\t\t\t// Adventure zone should be replaced with Arena\n\t\t\tconst adventureZone = gameStateManager.state.sharedZones.adventure;\n\n\t\t\t// Arena should have all three terrain types (Rule 4.3.e)\n\t\t\tconst arenaRegions = adventureZone.getAll().filter((entity) => entity.type === 'ArenaRegion');\n\t\t\texpect(arenaRegions).toHaveLength(3); // V, M, O terrains\n\t\t});\n\t});\n\n\tdescribe('Error Handling', () => {\n\t\ttest('should handle invalid player IDs gracefully', () => {\n\t\t\tconst invalidPlayer = gameStateManager.getPlayer('nonexistent');\n\t\t\texpect(invalidPlayer).toBeUndefined();\n\t\t});\n\n\t\ttest('should validate zone operations', async () => {\n\t\t\tawait gameStateManager.initializeGame();\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Should prevent invalid zone moves\n\t\t\texpect(() => {\n\t\t\t\tgameStateManager.moveCard(\n\t\t\t\t\t'invalid-card-id',\n\t\t\t\t\tZoneIdentifier.Hand,\n\t\t\t\t\tZoneIdentifier.Discard,\n\t\t\t\t\t'player1'\n\t\t\t\t);\n\t\t\t}).toThrow();\n\t\t});\n\n\t\ttest('should handle missing card definitions', async () => {\n\t\t\tconst emptyDefinitions: ICardDefinition[] = [];\n\t\t\tconst emptyGameState = new GameStateManager(['player1'], emptyDefinitions, eventBus);\n\n\t\t\tawait expect(emptyGameState.initializeGame()).rejects.toThrow(\n\t\t\t\t'No card definitions available'\n\t\t\t);\n\t\t});\n\t});\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/KeywordRules.test.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'StatusType' is defined but never used.",
				"line": 7,
				"column": 2,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 7,
				"endColumn": 12
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 461,
				"column": 3,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 461,
				"endColumn": 21,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [11409, 11410], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 462,
				"column": 3,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 462,
				"endColumn": 21,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [11448, 11449], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 466,
				"column": 18,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 466,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 510,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 510,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 511,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 511,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 560,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 560,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 573,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 573,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 574,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 574,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 606,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 606,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 607,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 607,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'p2CompanionWeak' is assigned a value but never used.",
				"line": 630,
				"column": 9,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 630,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 688,
				"column": 13,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 688,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 949,
				"column": 13,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 949,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 962,
				"column": 28,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 962,
				"endColumn": 94
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 969,
				"column": 31,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 971,
				"endColumn": 6
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 1073,
				"column": 9,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 1073,
				"endColumn": 27
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 1074,
				"column": 9,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 1074,
				"endColumn": 27
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 1092,
				"column": 22,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 1092,
				"endColumn": 89
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 1099,
				"column": 22,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 1099,
				"endColumn": 89
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 1106,
				"column": 22,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 1106,
				"endColumn": 89
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 1120,
				"column": 23,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 1120,
				"endColumn": 94
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 1121,
				"column": 23,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 1121,
				"endColumn": 94
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'initialManaP2' is assigned a value but never used.",
				"line": 1196,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 1196,
				"endColumn": 23
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'initialManaP2' is assigned a value but never used.",
				"line": 1218,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 1218,
				"endColumn": 23
			}
		],
		"suppressedMessages": [],
		"errorCount": 4,
		"fatalErrorCount": 0,
		"warningCount": 21,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, test, expect, beforeEach } from 'bun:test';\nimport { GameStateManager } from '../../src/engine/GameStateManager';\nimport { EventBus } from '../../src/engine/EventBus';\nimport {\n\tCardType,\n\tGamePhase,\n\tStatusType,\n\tZoneIdentifier,\n\tKeywordAbility\n} from '../../src/engine/types/enums';\nimport type { ICardDefinition } from '../../src/engine/types/cards';\nimport type { IGameObject } from '../../src/engine/types/objects';\nimport { isGameObject } from '../../src/engine/types/objects';\n\ndescribe('GameStateManager - Keyword Rule Compliance (Rule 7.4)', () => {\n\tlet gsm: GameStateManager;\n\tlet eventBus: EventBus;\n\tconst P1 = 'player1';\n\tconst P2 = 'player2';\n\n\t// Card Definitions\n\tconst cardDef_EternalChar: ICardDefinition = {\n\t\tid: 'char-eternal',\n\t\tname: 'Eternal Warrior',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 3,\n\t\treserveCost: 3,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 3, mountain: 3, water: 3 },\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-eternal',\n\t\t\t\ttext: 'This character is Eternal.',\n\t\t\t\tabilityType: 'passive',\n\t\t\t\tkeyword: KeywordAbility.Eternal,\n\t\t\t\teffect: { steps: [] },\n\t\t\t\tisSupportAbility: false\n\t\t\t}\n\t\t],\n\t\trarity: 'Rare',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_NormalChar_K: ICardDefinition = {\n\t\tid: 'char-normal-k',\n\t\tname: 'Regular Fighter',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 2,\n\t\treserveCost: 2,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 2, mountain: 2, water: 2 },\n\t\tabilities: [],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_DefenderChar: ICardDefinition = {\n\t\tid: 'char-defender',\n\t\tname: 'Steadfast Guardian',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 1,\n\t\treserveCost: 1,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 5, mountain: 5, water: 5 },\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-def',\n\t\t\t\ttext: 'This character has Defender.',\n\t\t\t\tabilityType: 'passive',\n\t\t\t\tkeyword: KeywordAbility.Defender,\n\t\t\t\teffect: { steps: [] },\n\t\t\t\tisSupportAbility: false\n\t\t\t}\n\t\t],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_OpponentChar_K: ICardDefinition = {\n\t\tid: 'char-opponent-k',\n\t\tname: 'Weak Opponent',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 1,\n\t\treserveCost: 1,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 1, mountain: 1, water: 1 },\n\t\tabilities: [],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_StrongNonDefenderChar_K: ICardDefinition = {\n\t\tid: 'char-strong-non-defender-k',\n\t\tname: 'Mighty Attacker',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 3,\n\t\treserveCost: 3,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 6, mountain: 6, water: 6 },\n\t\tabilities: [],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_GiganticChar: ICardDefinition = {\n\t\tid: 'char-gigantic',\n\t\tname: 'Towering Behemoth',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 5,\n\t\treserveCost: 5,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 5, mountain: 5, water: 5 },\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-gig',\n\t\t\t\ttext: 'This character is Gigantic.', // Corrected from 'description'\n\t\t\t\tabilityType: 'passive',\n\t\t\t\tkeyword: KeywordAbility.Gigantic,\n\t\t\t\t// sourceObjectId: 'char-gigantic', // ObjectFactory will set this\n\t\t\t\teffect: { steps: [] }, // Corrected from async () => {}\n\t\t\t\tisSupportAbility: false\n\t\t\t}\n\t\t],\n\t\trarity: 'Rare',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_P2_HeroChar_Stats10: ICardDefinition = {\n\t\tid: 'p2-hero-stats10',\n\t\tname: 'P2 Hero Strong',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 1,\n\t\treserveCost: 1,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 10, mountain: 10, water: 10 },\n\t\tabilities: [],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_P2_CompanionChar_Stats3: ICardDefinition = {\n\t\tid: 'p2-comp-stats3',\n\t\tname: 'P2 Companion Weak',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 1,\n\t\treserveCost: 1,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 3, mountain: 3, water: 3 },\n\t\tabilities: [],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\t// Scout Card Definitions\n\tconst cardDef_ScoutChar_Cost2_Scout1: ICardDefinition = {\n\t\tid: 'char-scout-cost2-scout1',\n\t\tname: 'Scouting Ranger',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 2,\n\t\treserveCost: 2,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 1, mountain: 1, water: 1 },\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-scout1',\n\t\t\t\ttext: 'Scout 1',\n\t\t\t\tabilityType: 'keyword',\n\t\t\t\tkeyword: KeywordAbility.Scout,\n\t\t\t\tvalue: 1,\n\t\t\t\teffect: { steps: [] }, // Scout keyword effect is handled by rules engine\n\t\t\t\tisSupportAbility: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tabilityId: 'abil-scout-j-draw',\n\t\t\t\ttext: 'j You may draw a card.',\n\t\t\t\tabilityType: 'reaction',\n\t\t\t\ttrigger: 'onSelfEnterPlay', // Assuming 'onSelfEnterPlay' is the correct trigger for 'j'\n\t\t\t\teffect: {\n\t\t\t\t\tsteps: [{ type: 'drawCard', player: 'self', quantity: 1, isOptional: true }]\n\t\t\t\t},\n\t\t\t\tisSupportAbility: false\n\t\t\t}\n\t\t],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_ScoutChar_Cost3_Scout2_Reaction: ICardDefinition = {\n\t\tid: 'char-scout-cost3-scout2-reaction',\n\t\tname: 'Veteran Scout',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 3,\n\t\treserveCost: 3,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 2, mountain: 2, water: 2 },\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-scout2',\n\t\t\t\ttext: 'Scout 2',\n\t\t\t\tabilityType: 'keyword',\n\t\t\t\tkeyword: KeywordAbility.Scout,\n\t\t\t\tvalue: 2,\n\t\t\t\teffect: { steps: [] },\n\t\t\t\tisSupportAbility: false\n\t\t\t},\n\t\t\t{\n\t\t\t\tabilityId: 'abil-scout-h-boost',\n\t\t\t\ttext: 'h Gain 1 boost.',\n\t\t\t\tabilityType: 'reaction',\n\t\t\t\ttrigger: 'onSelfPlayedFromHand', // Assuming 'onSelfPlayedFromHand' is correct for 'h'\n\t\t\t\teffect: {\n\t\t\t\t\tsteps: [{ type: 'gainBoost', player: 'self', quantity: 1 }]\n\t\t\t\t},\n\t\t\t\tisSupportAbility: false\n\t\t\t}\n\t\t],\n\t\trarity: 'Uncommon',\n\t\tversion: '1.0'\n\t};\n\n\t// Seasoned Card Definitions\n\tconst cardDef_SeasonedChar: ICardDefinition = {\n\t\tid: 'char-seasoned',\n\t\tname: 'Seasoned Veteran',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 3,\n\t\treserveCost: 3,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 2, mountain: 2, water: 2 },\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-seasoned',\n\t\t\t\ttext: 'Seasoned',\n\t\t\t\tabilityType: 'keyword',\n\t\t\t\tkeyword: KeywordAbility.Seasoned,\n\t\t\t\teffect: { steps: [] }, // Seasoned keyword effect is handled by rules engine\n\t\t\t\tisSupportAbility: false\n\t\t\t}\n\t\t],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_NonSeasonedChar_Boosts: ICardDefinition = {\n\t\t// Renamed for clarity\n\t\tid: 'char-non-seasoned-for-boosts',\n\t\tname: 'Boostable Recruit',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 1,\n\t\treserveCost: 1,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 1, mountain: 1, water: 1 },\n\t\tabilities: [],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_MoveCharacterToReserveSpell: ICardDefinition = {\n\t\tid: 'spell-move-to-reserve',\n\t\tname: 'Tactical Withdrawal',\n\t\ttype: CardType.Spell,\n\t\tsubTypes: [],\n\t\thandCost: 1,\n\t\tfaction: 'Neutral',\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-move-to-reserve',\n\t\t\t\ttext: 'Move target character you control from your Expedition to your Reserve.',\n\t\t\t\tabilityType: 'effect',\n\t\t\t\teffect: {\n\t\t\t\t\ttargetType: 'single',\n\t\t\t\t\ttargetFilter: {\n\t\t\t\t\t\tzone: ZoneIdentifier.Expedition,\n\t\t\t\t\t\tcontroller: 'self',\n\t\t\t\t\t\tcardType: CardType.Character\n\t\t\t\t\t},\n\t\t\t\t\tsteps: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: 'moveObject',\n\t\t\t\t\t\t\ttarget: 'targetObject', // Special keyword for the target of the spell\n\t\t\t\t\t\t\ttoZone: ZoneIdentifier.Reserve,\n\t\t\t\t\t\t\tcontroller: 'self'\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tisSupportAbility: false\n\t\t\t}\n\t\t],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\t// Tough Card Definitions\n\tconst cardDef_Tough1Char_P1: ICardDefinition = {\n\t\tid: 'p1-char-tough1',\n\t\tname: 'P1 Tough Defender 1',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 2,\n\t\treserveCost: 2,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 2, mountain: 2, water: 2 },\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-tough1',\n\t\t\t\ttext: 'Tough 1',\n\t\t\t\tabilityType: 'keyword',\n\t\t\t\tkeyword: KeywordAbility.Tough,\n\t\t\t\tvalue: 1,\n\t\t\t\teffect: { steps: [] },\n\t\t\t\tisSupportAbility: false\n\t\t\t}\n\t\t],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_Tough2Char_P1: ICardDefinition = {\n\t\tid: 'p1-char-tough2',\n\t\tname: 'P1 Tough Defender 2',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 3,\n\t\treserveCost: 3,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 3, mountain: 3, water: 3 },\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-tough2',\n\t\t\t\ttext: 'Tough 2',\n\t\t\t\tabilityType: 'keyword',\n\t\t\t\tkeyword: KeywordAbility.Tough,\n\t\t\t\tvalue: 2,\n\t\t\t\teffect: { steps: [] },\n\t\t\t\tisSupportAbility: false\n\t\t\t}\n\t\t],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_NormalChar_P1: ICardDefinition = {\n\t\tid: 'p1-char-normal',\n\t\tname: 'P1 Regular Attacker',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: 2,\n\t\treserveCost: 2,\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 2, mountain: 2, water: 2 },\n\t\tabilities: [],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_TargetingSpell_P2: ICardDefinition = {\n\t\tid: 'p2-spell-target-char',\n\t\tname: 'P2 Zap',\n\t\ttype: CardType.Spell,\n\t\tsubTypes: [],\n\t\thandCost: 1, // Simple cost for easier mana calculation\n\t\tfaction: 'Neutral',\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-zap',\n\t\t\t\ttext: 'Target character gets -1/-1/-1 this turn.', // Example effect\n\t\t\t\tabilityType: 'effect',\n\t\t\t\teffect: {\n\t\t\t\t\ttargetType: 'single',\n\t\t\t\t\ttargetFilter: { zone: ZoneIdentifier.Expedition, cardType: CardType.Character }, // Can target any char in expedition\n\t\t\t\t\tsteps: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: 'modifyStats', // Assuming a stat modification effect type\n\t\t\t\t\t\t\ttarget: 'targetObject',\n\t\t\t\t\t\t\tpayload: { forest: -1, mountain: -1, water: -1, durationTurns: 1 } // Temporary effect\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tisSupportAbility: false\n\t\t\t}\n\t\t],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_TargetingSpell_P1: ICardDefinition = {\n\t\tid: 'p1-spell-target-char',\n\t\tname: 'P1 Reinforce', // Could be a buff to make sense for self-target\n\t\ttype: CardType.Spell,\n\t\tsubTypes: [],\n\t\thandCost: 1,\n\t\tfaction: 'Neutral',\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-reinforce',\n\t\t\t\ttext: 'Target character gets +1/+1/+1 this turn.',\n\t\t\t\tabilityType: 'effect',\n\t\t\t\teffect: {\n\t\t\t\t\ttargetType: 'single',\n\t\t\t\t\ttargetFilter: {\n\t\t\t\t\t\tzone: ZoneIdentifier.Expedition,\n\t\t\t\t\t\tcardType: CardType.Character,\n\t\t\t\t\t\tcontroller: 'self'\n\t\t\t\t\t}, // Target self\n\t\t\t\t\tsteps: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: 'modifyStats',\n\t\t\t\t\t\t\ttarget: 'targetObject',\n\t\t\t\t\t\t\tpayload: { forest: 1, mountain: 1, water: 1, durationTurns: 1 }\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\tisSupportAbility: false\n\t\t\t}\n\t\t],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\t// Consolidated beforeEach\n\tbeforeEach(async () => {\n\t\teventBus = new EventBus();\n\t\tgsm = new GameStateManager(\n\t\t\t[P1, P2],\n\t\t\t[\n\t\t\t\tcardDef_EternalChar,\n\t\t\t\tcardDef_NormalChar_K,\n\t\t\t\tcardDef_DefenderChar,\n\t\t\t\tcardDef_OpponentChar_K,\n\t\t\t\tcardDef_StrongNonDefenderChar_K,\n\t\t\t\tcardDef_GiganticChar,\n\t\t\t\tcardDef_P2_HeroChar_Stats10,\n\t\t\t\tcardDef_P2_CompanionChar_Stats3,\n\t\t\t\tcardDef_ScoutChar_Cost2_Scout1,\n\t\t\t\tcardDef_ScoutChar_Cost3_Scout2_Reaction,\n\t\t\t\tcardDef_SeasonedChar,\n\t\t\t\tcardDef_NonSeasonedChar_Boosts,\n\t\t\t\tcardDef_MoveCharacterToReserveSpell,\n\t\t\t\tcardDef_Tough1Char_P1,\n\t\t\t\tcardDef_Tough2Char_P1,\n\t\t\t\tcardDef_NormalChar_P1,\n\t\t\t\tcardDef_TargetingSpell_P1,\n\t\t\t\tcardDef_TargetingSpell_P2 // Added new tough cards\n\t\t\t],\n\t\t\teventBus\n\t\t);\n\t\tawait gsm.initializeGame();\n\t\t// Ensure players start with some mana for tests\n\t\tgsm.getPlayer(P1)!.currentMana = 10;\n\t\tgsm.getPlayer(P2)!.currentMana = 10;\n\t});\n\n\ttest('Rule 7.4.3: Eternal character is not sent to Reserve during Rest', async () => {\n\t\tconst player = gsm.getPlayer(P1)!;\n\t\tconst expeditionZone = player.zones.expeditionZone;\n\t\tconst reserveZone = player.zones.reserveZone;\n\n\t\tconst eternalCharInst = gsm.objectFactory.createCardInstance(cardDef_EternalChar.id, P1);\n\t\tconst eternalChar = gsm.objectFactory.createGameObject(eternalCharInst, P1);\n\t\texpeditionZone.add(eternalChar);\n\t\tconst eternalCharId = eternalChar.objectId;\n\n\t\tconst normalCharInst = gsm.objectFactory.createCardInstance(cardDef_NormalChar_K.id, P1);\n\t\tconst normalChar = gsm.objectFactory.createGameObject(normalCharInst, P1);\n\t\texpeditionZone.add(normalChar);\n\t\tconst normalCharId = normalChar.objectId;\n\n\t\tgsm.ruleAdjudicator.applyAllPassiveAbilities();\n\n\t\tconst processedEternalCharFromGsm = gsm.getObject(eternalCharId);\n\t\texpect(processedEternalCharFromGsm).toBeDefined();\n\t\texpect(processedEternalCharFromGsm?.currentCharacteristics.isEternal).toBe(true);\n\n\t\tplayer.heroExpedition.hasMoved = true;\n\t\tawait gsm.restPhase();\n\n\t\tconst eternalCharAfterRest = expeditionZone.findById(eternalCharId);\n\t\texpect(eternalCharAfterRest).toBeDefined();\n\t\texpect(reserveZone.findById(eternalCharId)).toBeUndefined();\n\n\t\texpect(\n\t\t\texpeditionZone\n\t\t\t\t.getAll()\n\t\t\t\t.find(\n\t\t\t\t\t(o) =>\n\t\t\t\t\t\tisGameObject(o) &&\n\t\t\t\t\t\to.definitionId === cardDef_NormalChar_K.id &&\n\t\t\t\t\t\to.objectId === normalCharId\n\t\t\t\t)\n\t\t).toBeUndefined();\n\t\tconst normalCharInReserve = reserveZone\n\t\t\t.getAll()\n\t\t\t.find((o) => isGameObject(o) && o.definitionId === cardDef_NormalChar_K.id);\n\t\texpect(normalCharInReserve).toBeDefined();\n\t});\n\n\ttest('Rule 7.4.2: Expedition with Defender character does not move during Progress', async () => {\n\t\tconst player1 = gsm.getPlayer(P1)!;\n\t\tconst player2 = gsm.getPlayer(P2)!;\n\n\t\tconst defenderCharInst = gsm.objectFactory.createCardInstance(cardDef_DefenderChar.id, P1);\n\t\tconst defenderChar = gsm.objectFactory.createGameObject(defenderCharInst, P1);\n\t\tplayer1.zones.expeditionZone.add(defenderChar);\n\t\tconst defenderCharId = defenderChar.objectId;\n\n\t\tconst opponentCharInst = gsm.objectFactory.createCardInstance(cardDef_OpponentChar_K.id, P2);\n\t\tconst opponentChar = gsm.objectFactory.createGameObject(opponentCharInst, P2);\n\t\tplayer2.zones.expeditionZone.add(opponentChar);\n\n\t\tgsm.ruleAdjudicator.applyAllPassiveAbilities();\n\n\t\tconst processedDefenderChar = gsm.getObject(defenderCharId);\n\t\texpect(processedDefenderChar?.currentCharacteristics.hasDefender).toBe(true);\n\n\t\tplayer1.heroExpedition.hasMoved = false;\n\t\tplayer1.heroExpedition.position = 0;\n\t\tplayer2.heroExpedition.hasMoved = false;\n\t\tplayer2.heroExpedition.position = 0;\n\n\t\tawait gsm.progressPhase();\n\n\t\texpect(player1.heroExpedition.hasMoved).toBe(false);\n\t\texpect(player1.heroExpedition.position).toBe(0);\n\t\texpect(player2.heroExpedition.hasMoved).toBe(false);\n\t\texpect(player2.heroExpedition.position).toBe(0);\n\n\t\tconst strongNonDefenderInst = gsm.objectFactory.createCardInstance(\n\t\t\tcardDef_StrongNonDefenderChar_K.id,\n\t\t\tP2\n\t\t);\n\t\tconst strongNonDefender = gsm.objectFactory.createGameObject(strongNonDefenderInst, P2);\n\t\tplayer2.zones.expeditionZone.add(strongNonDefender);\n\n\t\tplayer1.heroExpedition.hasMoved = false;\n\t\tplayer1.heroExpedition.position = 0;\n\t\tplayer2.heroExpedition.hasMoved = false;\n\t\tplayer2.heroExpedition.position = 0;\n\n\t\tawait gsm.progressPhase();\n\n\t\texpect(player1.heroExpedition.hasMoved).toBe(false);\n\t\texpect(player1.heroExpedition.position).toBe(0);\n\t\texpect(player2.heroExpedition.hasMoved).toBe(true);\n\t\texpect(player2.heroExpedition.position).toBe(1);\n\t});\n\n\ttest('Rule 7.4.4: Gigantic characteristic is applied', async () => {\n\t\tconst player1 = gsm.getPlayer(P1)!;\n\t\tconst giganticCharInst = gsm.objectFactory.createCardInstance(cardDef_GiganticChar.id, P1);\n\t\tconst giganticChar = gsm.objectFactory.createGameObject(giganticCharInst, P1);\n\t\tplayer1.zones.expeditionZone.add(giganticChar);\n\t\tconst giganticCharId = giganticChar.objectId;\n\n\t\tgsm.ruleAdjudicator.applyAllPassiveAbilities();\n\n\t\tconst processedGiganticChar = gsm.getObject(giganticCharId);\n\t\texpect(processedGiganticChar?.currentCharacteristics.isGigantic).toBe(true);\n\t});\n\n\ttest('Rule 7.4.4.e: Gigantic character stats count in its own expedition for Progress', async () => {\n\t\tconst player1 = gsm.getPlayer(P1)!;\n\t\tconst player2 = gsm.getPlayer(P2)!;\n\n\t\t// P1 has Gigantic Char (stats 5) in their Hero Expedition.\n\t\tconst giganticCharInst = gsm.objectFactory.createCardInstance(cardDef_GiganticChar.id, P1);\n\t\tconst giganticChar = gsm.objectFactory.createGameObject(giganticCharInst, P1);\n\t\tplayer1.zones.expeditionZone.add(giganticChar); // Assuming this one expedition zone is used for both hero/companion conceptual expeditions\n\n\t\t// P2 has Opponent Char (stats 1) in their Hero Expedition.\n\t\tconst p2HeroCharInst = gsm.objectFactory.createCardInstance(cardDef_OpponentChar_K.id, P2); // stats 1\n\t\tconst p2HeroChar = gsm.objectFactory.createGameObject(p2HeroCharInst, P2);\n\t\tplayer2.zones.expeditionZone.add(p2HeroChar);\n\n\t\t// P2 Companion expedition is weak (empty or another weak char for clearer test)\n\t\t// For simplicity, let's ensure P2's companion side is empty or very weak.\n\t\t// If player2.zones.expeditionZone is shared, then p2HeroChar is also on companion side.\n\n\t\tgsm.ruleAdjudicator.applyAllPassiveAbilities();\n\n\t\tawait gsm.progressPhase();\n\n\t\t// P1 Hero (5) vs P2 Hero (1) -> P1 Hero moves\n\t\texpect(player1.heroExpedition.hasMoved).toBe(true);\n\t\texpect(player1.heroExpedition.position).toBe(1);\n\n\t\t// P1 Companion (5, due to Gigantic) vs P2 Companion (1, as p2HeroChar counts for both for P2)\n\t\t// Or, if P2 companion side is \"empty\" conceptually, then P2 companion stats = 0.\n\t\t// P1 Companion (5) vs P2 Companion (1 if p2HeroChar is its only char, or 0 if conceptually empty) -> P1 Companion moves\n\t\texpect(player1.companionExpedition.hasMoved).toBe(true);\n\t\texpect(player1.companionExpedition.position).toBe(1);\n\t});\n\n\ttest(\"Rule 7.4.4.e: Gigantic character stats count in controller's other expedition for Progress\", async () => {\n\t\tconst player1 = gsm.getPlayer(P1)!;\n\t\tconst player2 = gsm.getPlayer(P2)!;\n\n\t\t// P1 has Gigantic Char (stats 5) in their (conceptual) Hero Expedition.\n\t\t// For the test, it's just in player1.zones.expeditionZone\n\t\tconst giganticCharInst = gsm.objectFactory.createCardInstance(cardDef_GiganticChar.id, P1);\n\t\tconst giganticChar = gsm.objectFactory.createGameObject(giganticCharInst, P1);\n\t\tplayer1.zones.expeditionZone.add(giganticChar);\n\n\t\t// P1's Companion Expedition is conceptually empty (no other chars in player1.zones.expeditionZone for companion-specific role)\n\n\t\t// P2 has strong Hero char (stats 10)\n\t\tconst p2HeroStrongInst = gsm.objectFactory.createCardInstance(\n\t\t\tcardDef_P2_HeroChar_Stats10.id,\n\t\t\tP2\n\t\t);\n\t\tconst p2HeroStrong = gsm.objectFactory.createGameObject(p2HeroStrongInst, P2);\n\t\tplayer2.zones.expeditionZone.add(p2HeroStrong);\n\n\t\t// P2 has weak Companion char (stats 3)\n\t\tconst p2CompanionWeakInst = gsm.objectFactory.createCardInstance(\n\t\t\tcardDef_P2_CompanionChar_Stats3.id,\n\t\t\tP2\n\t\t);\n\t\tconst p2CompanionWeak = gsm.objectFactory.createGameObject(p2CompanionWeakInst, P2);\n\t\t// To make P2's companion side distinct, we'd need separate expedition zones or a way to tag chars.\n\t\t// Current model: all P2 chars (p2HeroStrong + p2CompanionWeak) are in player2.zones.expeditionZone.\n\t\t// So P2 Hero stats = 10+3=13, P2 Companion stats = 10+3=13.\n\n\t\tgsm.ruleAdjudicator.applyAllPassiveAbilities();\n\n\t\t// Re-evaluate P2 setup for clarity:\n\t\t// P2 Hero Expedition total stats = 13. P2 Companion Expedition total stats = 13.\n\t\t// P1 Hero Expedition total stats = 5 (Gigantic). P1 Companion Expedition total stats = 5 (Gigantic).\n\n\t\tawait gsm.progressPhase();\n\n\t\t// P1 Hero (5) vs P2 Hero (13) -> P1 Hero does NOT move\n\t\texpect(player1.heroExpedition.hasMoved).toBe(false);\n\t\texpect(player1.heroExpedition.position).toBe(0);\n\n\t\t// P1 Companion (5) vs P2 Companion (13) -> P1 Companion does NOT move\n\t\t// This assertion will test if Gigantic char's stats (5) apply to P1's companion expedition\n\t\t// when compared against P2's companion expedition (stats 3 in the original intent, but 13 with current model).\n\t\t// To make the test work as intended (P1 companion moves), P2 companion stats need to be < 5.\n\t\t// Let's remove p2HeroStrong from P2's expedition for the companion check part of the test,\n\t\t// by only adding p2CompanionWeak for P2.\n\n\t\t// Reset for a clearer P2 setup for the second assertion\n\t\tplayer2.zones.expeditionZone.clear(); // Clear P2's expedition\n\t\tconst p2CompanionWeakOnlyInst = gsm.objectFactory.createCardInstance(\n\t\t\tcardDef_P2_CompanionChar_Stats3.id,\n\t\t\tP2\n\t\t);\n\t\tconst p2CompanionWeakOnly = gsm.objectFactory.createGameObject(p2CompanionWeakOnlyInst, P2);\n\t\tplayer2.zones.expeditionZone.add(p2CompanionWeakOnly); // P2 total stats = 3 for both hero and comp.\n\n\t\tplayer1.heroExpedition.hasMoved = false;\n\t\tplayer1.heroExpedition.position = 0;\n\t\tplayer1.companionExpedition.hasMoved = false;\n\t\tplayer1.companionExpedition.position = 0;\n\t\tplayer2.heroExpedition.hasMoved = false;\n\t\tplayer2.heroExpedition.position = 0;\n\t\tplayer2.companionExpedition.hasMoved = false;\n\t\tplayer2.companionExpedition.position = 0;\n\n\t\tawait gsm.progressPhase(); // P1 (Gigantic, 5) vs P2 (Comp Only, 3)\n\n\t\t// P1 Hero (5) vs P2 Hero (3) -> P1 Hero moves\n\t\texpect(player1.heroExpedition.hasMoved).toBe(true);\n\t\texpect(player1.heroExpedition.position).toBe(1);\n\n\t\t// P1 Companion (5) vs P2 Companion (3) -> P1 Companion moves\n\t\texpect(player1.companionExpedition.hasMoved).toBe(true);\n\t\texpect(player1.companionExpedition.position).toBe(1);\n\t});\n\n\t// --- Scout Keyword Rules (Rule 7.4.5) ---\n\tdescribe('Scout Keyword Rules (Rule 7.4.5)', () => {\n\t\tlet player: ReturnType<GameStateManager['getPlayer']>;\n\n\t\tbeforeEach(() => {\n\t\t\tplayer = gsm.getPlayer(P1)!;\n\t\t\tplayer.currentMana = 10; // Reset mana for each scout test\n\t\t\t// Ensure P1 is in ActionPhase for playing cards\n\t\t\tgsm.currentPhase = GamePhase.Action;\n\t\t\tgsm.activePlayerId = P1;\n\n\t\t\t// Clear zones for clean test slate\n\t\t\tplayer.zones.hand.clear();\n\t\t\tplayer.zones.expeditionZone.clear();\n\t\t\tplayer.zones.reserveZone.clear();\n\t\t\tplayer.zones.discardPile.clear();\n\t\t\tgsm.effectExecutionManager.resetPendingEffects(); // Clear any pending effects\n\t\t});\n\n\t\ttest('Rule 7.4.5.a, 7.4.5.c: Scout provides an alternative play cost and card enters Expedition Zone', async () => {\n\t\t\tconst scoutCardInst = gsm.objectFactory.createCardInstance(\n\t\t\t\tcardDef_ScoutChar_Cost2_Scout1.id,\n\t\t\t\tP1\n\t\t\t);\n\t\t\tplayer.zones.hand.add(scoutCardInst);\n\t\t\tconst initialMana = player.currentMana;\n\n\t\t\t// Action: Player plays the card using its Scout 1 cost.\n\t\t\t// This requires a way to choose the alternative cost.\n\t\t\t// Assuming playCard will have an option for this, or a specific \"playWithScoutCost\" method.\n\t\t\t// For now, let's assume the game logic automatically picks scout if player indicates.\n\t\t\t// We'll simulate this by directly calling a method that implies scout usage.\n\t\t\t// The actual mechanism might involve player.choosePlayOption() then gsm.playCard().\n\n\t\t\t// The playCard method needs to be aware of alternative costs like Scout.\n\t\t\t// Let's assume a parameter like `useAlternativeCostKeyword: KeywordAbility.Scout`\n\t\t\tconst playResult = await gsm.playerPlaysCardFromHand(P1, scoutCardInst.instanceId, {\n\t\t\t\tuseAlternativeCostKeyword: KeywordAbility.Scout\n\t\t\t});\n\t\t\texpect(playResult.success).toBe(true);\n\n\t\t\tconst playedCardObject = gsm.findCardInAnyZone(scoutCardInst.instanceId);\n\t\t\texpect(playedCardObject).toBeDefined();\n\t\t\texpect(playedCardObject?.zone).toBe(ZoneIdentifier.Expedition);\n\n\t\t\t// Assertion: Check that only 1 mana was spent (Scout 1 cost)\n\t\t\t// cardDef_ScoutChar_Cost2_Scout1 has Scout 1\n\t\t\tconst expectedManaSpent =\n\t\t\t\tcardDef_ScoutChar_Cost2_Scout1.abilities.find((a) => a.keyword === KeywordAbility.Scout)\n\t\t\t\t\t?.value ?? 0;\n\t\t\texpect(player.currentMana).toBe(initialMana - expectedManaSpent);\n\t\t});\n\n\t\ttest('Rule 7.4.5.b: Scouted card gains \"h Send me to Reserve\" and it works', async () => {\n\t\t\tconst scoutCardInst = gsm.objectFactory.createCardInstance(\n\t\t\t\tcardDef_ScoutChar_Cost2_Scout1.id,\n\t\t\t\tP1\n\t\t\t);\n\t\t\tplayer.zones.hand.add(scoutCardInst);\n\n\t\t\tawait gsm.playerPlaysCardFromHand(P1, scoutCardInst.instanceId, {\n\t\t\t\tuseAlternativeCostKeyword: KeywordAbility.Scout\n\t\t\t});\n\n\t\t\tconst playedCardObject = gsm.findCardInAnyZone(\n\t\t\t\tscoutCardInst.instanceId,\n\t\t\t\tZoneIdentifier.Expedition\n\t\t\t) as IGameObject;\n\t\t\texpect(playedCardObject).toBeDefined();\n\n\t\t\t// Check if the gained ability \"h Send me to Reserve\" is present.\n\t\t\t// This ability is temporary and should be added by the Scout rule.\n\t\t\t// The exact implementation of this gained ability needs to be verified in the engine.\n\t\t\t// For testing, we assume it's an activatable ability that gets triggered.\n\t\t\t// Let's assume it's an 'h' (played from hand) triggered ability that resolves after entering play.\n\t\t\t// Or it could be an activated ability the player must use.\n\t\t\t// Rule 7.4.5.b says \"it gains 'h Send me to your Reserve.' that resolves after it enters play.\"\n\t\t\t// This implies it's an automatically triggered and resolved effect.\n\n\t\t\t// After playCard resolves, any 'onPlay' or 'onEnterPlay' effects (including the gained one) should resolve.\n\t\t\t// We might need to explicitly advance the effect queue or check the state after effects resolve.\n\t\t\tawait gsm.effectExecutionManager.resolvePendingEffects();\n\n\t\t\tconst cardAfterEffects = gsm.findCardInAnyZone(scoutCardInst.instanceId);\n\t\t\texpect(cardAfterEffects).toBeDefined();\n\t\t\texpect(cardAfterEffects?.zone).toBe(ZoneIdentifier.Reserve);\n\t\t});\n\n\t\ttest('Rule 7.4.5.c: Scout with Cost Increase', async () => {\n\t\t\tconst scoutCardInst = gsm.objectFactory.createCardInstance(\n\t\t\t\tcardDef_ScoutChar_Cost2_Scout1.id,\n\t\t\t\tP1\n\t\t\t); // Scout 1\n\t\t\tplayer.zones.hand.add(scoutCardInst);\n\t\t\tconst initialMana = player.currentMana; // 10\n\n\t\t\t// Apply a cost increase of +1 to the next character played\n\t\t\t// This is a hypothetical way to apply cost modifiers.\n\t\t\t// The actual implementation might differ.\n\t\t\tplayer.modifiers.add({\n\t\t\t\ttype: 'playCost',\n\t\t\t\tvalue: 1, // Increase cost by 1\n\t\t\t\tduration: 1, // Affects the next play\n\t\t\t\tfilter: { cardType: CardType.Character },\n\t\t\t\tsourceId: 'test-effect-cost-increase'\n\t\t\t});\n\n\t\t\tawait gsm.playerPlaysCardFromHand(P1, scoutCardInst.instanceId, {\n\t\t\t\tuseAlternativeCostKeyword: KeywordAbility.Scout\n\t\t\t});\n\n\t\t\t// Scout 1 cost + 1 (increase) = 2 mana spent\n\t\t\tconst scoutValue =\n\t\t\t\tcardDef_ScoutChar_Cost2_Scout1.abilities.find((a) => a.keyword === KeywordAbility.Scout)\n\t\t\t\t\t?.value ?? 0;\n\t\t\texpect(player.currentMana).toBe(initialMana - (scoutValue + 1));\n\n\t\t\tawait gsm.effectExecutionManager.resolvePendingEffects(); // Resolve \"Send to Reserve\"\n\t\t\tconst cardAfterEffects = gsm.findCardInAnyZone(scoutCardInst.instanceId);\n\t\t\texpect(cardAfterEffects?.zone).toBe(ZoneIdentifier.Reserve);\n\t\t});\n\n\t\ttest('Rule 7.4.5.c: Scout with Cost Decrease (down to 0)', async () => {\n\t\t\tconst scoutCardInst = gsm.objectFactory.createCardInstance(\n\t\t\t\tcardDef_ScoutChar_Cost2_Scout1.id,\n\t\t\t\tP1\n\t\t\t); // Scout 1\n\t\t\tplayer.zones.hand.add(scoutCardInst);\n\t\t\tconst initialMana = player.currentMana; // 10\n\n\t\t\t// Apply a cost decrease of -1 to the next character played\n\t\t\tplayer.modifiers.add({\n\t\t\t\ttype: 'playCost',\n\t\t\t\tvalue: -1, // Decrease cost by 1\n\t\t\t\tduration: 1,\n\t\t\t\tfilter: { cardType: CardType.Character },\n\t\t\t\tsourceId: 'test-effect-cost-decrease'\n\t\t\t});\n\n\t\t\tawait gsm.playerPlaysCardFromHand(P1, scoutCardInst.instanceId, {\n\t\t\t\tuseAlternativeCostKeyword: KeywordAbility.Scout\n\t\t\t});\n\n\t\t\t// Scout 1 cost - 1 (decrease) = 0 mana spent\n\t\t\tconst scoutValue =\n\t\t\t\tcardDef_ScoutChar_Cost2_Scout1.abilities.find((a) => a.keyword === KeywordAbility.Scout)\n\t\t\t\t\t?.value ?? 0;\n\t\t\tconst finalCost = Math.max(0, scoutValue - 1); // Costs cannot go below 0\n\t\t\texpect(player.currentMana).toBe(initialMana - finalCost);\n\n\t\t\tawait gsm.effectExecutionManager.resolvePendingEffects();\n\t\t\tconst cardAfterEffects = gsm.findCardInAnyZone(scoutCardInst.instanceId);\n\t\t\texpect(cardAfterEffects?.zone).toBe(ZoneIdentifier.Reserve);\n\t\t});\n\n\t\ttest('Rule 7.4.5.d (Remark): Scout with \"Play for Free\" effect', async () => {\n\t\t\tconst scoutCardInst = gsm.objectFactory.createCardInstance(\n\t\t\t\tcardDef_ScoutChar_Cost2_Scout1.id,\n\t\t\t\tP1\n\t\t\t); // Scout 1\n\t\t\tplayer.zones.hand.add(scoutCardInst);\n\t\t\tconst initialMana = player.currentMana;\n\n\t\t\t// Apply a \"Play for Free\" effect for the next character\n\t\t\tplayer.modifiers.add({\n\t\t\t\ttype: 'playCost',\n\t\t\t\tsetToZero: true, // Special flag for \"Play for Free\"\n\t\t\t\tduration: 1,\n\t\t\t\tfilter: { cardType: CardType.Character },\n\t\t\t\tsourceId: 'test-effect-play-free'\n\t\t\t});\n\n\t\t\tawait gsm.playerPlaysCardFromHand(P1, scoutCardInst.instanceId, {\n\t\t\t\tuseAlternativeCostKeyword: KeywordAbility.Scout\n\t\t\t});\n\n\t\t\t// Played for free, so 0 mana spent\n\t\t\texpect(player.currentMana).toBe(initialMana);\n\n\t\t\tconst playedCardObject = gsm.findCardInAnyZone(\n\t\t\t\tscoutCardInst.instanceId,\n\t\t\t\tZoneIdentifier.Expedition\n\t\t\t);\n\t\t\texpect(playedCardObject).toBeDefined(); // Should be in expedition first\n\n\t\t\t// Still gains \"h Send me to Reserve\"\n\t\t\tawait gsm.effectExecutionManager.resolvePendingEffects();\n\t\t\tconst cardAfterEffects = gsm.findCardInAnyZone(scoutCardInst.instanceId);\n\t\t\texpect(cardAfterEffects?.zone).toBe(ZoneIdentifier.Reserve);\n\t\t});\n\n\t\ttest(\"Rule 7.4.5.e: Scouted card's other reactions resolve correctly after moving to Reserve\", async () => {\n\t\t\t// cardDef_ScoutChar_Cost2_Scout1 has \"j You may draw a card\"\n\t\t\tconst scoutCardInst = gsm.objectFactory.createCardInstance(\n\t\t\t\tcardDef_ScoutChar_Cost2_Scout1.id,\n\t\t\t\tP1\n\t\t\t);\n\t\t\tplayer.zones.hand.add(scoutCardInst);\n\t\t\tconst initialHandSize = player.zones.hand.count; // For checking draw\n\n\t\t\t// Play card using Scout\n\t\t\tawait gsm.playerPlaysCardFromHand(P1, scoutCardInst.instanceId, {\n\t\t\t\tuseAlternativeCostKeyword: KeywordAbility.Scout\n\t\t\t});\n\n\t\t\tconst cardInExpedition = gsm.findCardInAnyZone(\n\t\t\t\tscoutCardInst.instanceId,\n\t\t\t\tZoneIdentifier.Expedition\n\t\t\t) as IGameObject;\n\t\t\texpect(cardInExpedition).toBeDefined(); // Initially in expedition\n\n\t\t\t// Resolve all pending effects. This should include:\n\t\t\t// 1. The Scout's gained \"h Send me to Reserve\" ability.\n\t\t\t// 2. The card's own \"j You may draw a card\" reaction.\n\t\t\t// The rule implies \"h Send to Reserve\" resolves, then other 'j' or 'h' abilities.\n\t\t\t// The EffectExecutionManager should handle the correct order and context.\n\t\t\tawait gsm.effectExecutionManager.resolvePendingEffects();\n\n\t\t\t// Card should be in Reserve due to Scout's gained ability\n\t\t\tconst cardInReserve = gsm.findCardInAnyZone(scoutCardInst.instanceId, ZoneIdentifier.Reserve);\n\t\t\texpect(cardInReserve).toBeDefined();\n\t\t\tconst cardNotInExpedition = gsm.findCardInAnyZone(\n\t\t\t\tscoutCardInst.instanceId,\n\t\t\t\tZoneIdentifier.Expedition\n\t\t\t);\n\t\t\texpect(cardNotInExpedition).toBeUndefined();\n\n\t\t\t// Assertion: Check that the 'j' reaction (draw a card) successfully resolved.\n\t\t\t// This means the player should have drawn a card.\n\t\t\t// The card to draw is defined as non-optional in the test card def, so it should always draw.\n\t\t\t// If it was optional, we'd need a way to make the choice.\n\t\t\t// For this test, let's assume the \"j You may draw a card\" has isOptional: false or auto-resolves for simplicity\n\t\t\t// The current definition has `isOptional: true`. This means the test needs to handle a choice.\n\t\t\t// For now, let's assume the test setup makes the choice automatically or the effect resolves if possible.\n\t\t\t// If the effect system requires explicit choice handling, this test would need adjustment.\n\t\t\t// Let's simplify the card's draw to be non-optional for this test case to avoid choice logic here.\n\n\t\t\t// Modify cardDef_ScoutChar_Cost2_Scout1's draw to be non-optional for this specific test logic.\n\t\t\t// This is a bit of a hack. Ideally, the choice mechanism would be mocked or handled.\n\t\t\t// (Simulating this change for the test's purpose - in a real scenario, use a different card or mock choices)\n\t\t\tconst drawAbility = cardDef_ScoutChar_Cost2_Scout1.abilities.find(\n\t\t\t\t(a) => a.abilityId === 'abil-scout-j-draw'\n\t\t\t);\n\t\t\tif (drawAbility && drawAbility.effect.steps[0]) {\n\t\t\t\t// (drawAbility.effect.steps[0] as any).isOptional = false; // Temporarily modify for test logic\n\t\t\t\t// This modification is tricky as the card def is already cached.\n\t\t\t\t// A better way would be to have a card variant or ensure the choice is auto-made if possible.\n\t\t\t\t// For now, we'll rely on the fact that if an optional effect *can* resolve, it *will* for this test,\n\t\t\t\t// or check if a choice was presented and auto-resolved.\n\t\t\t\t// The critical part is that the effect *could* resolve, not necessarily that it *did* without player input.\n\t\t\t\t// The prompt for draw is part of EffectExecutionManager usually.\n\t\t\t\t// Let's check if the hand size increased.\n\t\t\t}\n\t\t\t// If the draw effect (even if optional) was able to resolve, hand size should increase.\n\t\t\t// This implies that the effect found its context (the player) correctly.\n\t\t\texpect(player.zones.hand.count).toBe(initialHandSize); // Card played from hand (-1), card drawn (+1)\n\t\t});\n\t});\n\n\t// --- Seasoned Keyword Rules (Rule 7.4.6) ---\n\tdescribe('Seasoned Keyword Rules (Rule 7.4.6)', () => {\n\t\tlet player: ReturnType<GameStateManager['getPlayer']>;\n\t\tlet seasonedCharObject: IGameObject;\n\t\tlet nonSeasonedCharObject: IGameObject;\n\n\t\tbeforeEach(async () => {\n\t\t\tplayer = gsm.getPlayer(P1)!;\n\t\t\tgsm.currentPhase = GamePhase.Action;\n\t\t\tgsm.activePlayerId = P1;\n\t\t\tplayer.currentMana = 10;\n\n\t\t\tplayer.zones.hand.clear();\n\t\t\tplayer.zones.expeditionZone.clear();\n\t\t\tplayer.zones.reserveZone.clear();\n\t\t\tplayer.zones.discardPile.clear();\n\t\t\tplayer.heroExpedition.hasMoved = false;\n\t\t\tplayer.heroExpedition.position = 0;\n\t\t\tgsm.effectExecutionManager.resetPendingEffects();\n\n\t\t\tconst seasonedCardDef = gsm.cardDataRepository.getCardDefinition(cardDef_SeasonedChar.id)!;\n\t\t\tseasonedCharObject = gsm.objectFactory.createGameObject(\n\t\t\t\tgsm.objectFactory.createCardInstance(seasonedCardDef.id, P1),\n\t\t\t\tP1\n\t\t\t);\n\t\t\tgsm.zones.addToZone(seasonedCharObject, ZoneIdentifier.Expedition, P1);\n\n\t\t\tconst nonSeasonedCardDef = gsm.cardDataRepository.getCardDefinition(\n\t\t\t\tcardDef_NonSeasonedChar_Boosts.id\n\t\t\t)!;\n\t\t\tnonSeasonedCharObject = gsm.objectFactory.createGameObject(\n\t\t\t\tgsm.objectFactory.createCardInstance(nonSeasonedCardDef.id, P1),\n\t\t\t\tP1\n\t\t\t);\n\t\t\tgsm.zones.addToZone(nonSeasonedCharObject, ZoneIdentifier.Expedition, P1);\n\n\t\t\tgsm.ruleAdjudicator.applyAllPassiveAbilities();\n\t\t});\n\n\t\tconst addBoostsToGameObject = (charObject: IGameObject, amount: number) => {\n\t\t\tcharObject.boostCounters = (charObject.boostCounters || 0) + amount;\n\t\t};\n\n\t\ttest('Rule 7.4.6.b, 7.4.6.c: Seasoned character keeps boosts during Rest Phase', async () => {\n\t\t\taddBoostsToGameObject(seasonedCharObject, 2);\n\t\t\texpect(seasonedCharObject.boostCounters).toBe(2);\n\t\t\texpect(seasonedCharObject.currentCharacteristics.isSeasoned).toBe(true);\n\n\t\t\tplayer.heroExpedition.hasMoved = true;\n\t\t\tawait gsm.restPhase();\n\n\t\t\tconst charInReserve = player.zones.reserveZone.findById(seasonedCharObject.objectId);\n\t\t\texpect(charInReserve).toBeDefined();\n\t\t\texpect(charInReserve?.boostCounters).toBe(2);\n\t\t});\n\n\t\ttest('Rule 2.5.j (Control): Non-Seasoned character loses boosts during Rest Phase', async () => {\n\t\t\taddBoostsToGameObject(nonSeasonedCharObject, 2);\n\t\t\texpect(nonSeasonedCharObject.boostCounters).toBe(2);\n\t\t\texpect(nonSeasonedCharObject.currentCharacteristics.isSeasoned).toBe(false);\n\n\t\t\tplayer.heroExpedition.hasMoved = true;\n\t\t\tawait gsm.restPhase();\n\n\t\t\tconst charInReserve = player.zones.reserveZone.findById(nonSeasonedCharObject.objectId);\n\t\t\texpect(charInReserve).toBeDefined();\n\t\t\texpect(charInReserve?.boostCounters).toBe(0);\n\t\t});\n\n\t\ttest('Rule 7.4.6.b, 7.4.6.c: Seasoned character keeps boosts when moved to Reserve by an effect', async () => {\n\t\t\taddBoostsToGameObject(seasonedCharObject, 3);\n\t\t\texpect(seasonedCharObject.boostCounters).toBe(3);\n\t\t\texpect(seasonedCharObject.currentCharacteristics.isSeasoned).toBe(true);\n\n\t\t\tconst spellInst = gsm.objectFactory.createCardInstance(\n\t\t\t\tcardDef_MoveCharacterToReserveSpell.id,\n\t\t\t\tP1\n\t\t\t);\n\t\t\tplayer.zones.hand.add(spellInst);\n\n\t\t\tplayer.zones.expeditionZone.remove(nonSeasonedCharObject.objectId); // Simplify targeting\n\n\t\t\tconst playResult = await gsm.playerPlaysCardFromHand(P1, spellInst.instanceId, {\n\t\t\t\ttargetObjectIds: [seasonedCharObject.objectId]\n\t\t\t});\n\t\t\texpect(playResult.success).toBe(true);\n\t\t\tawait gsm.effectExecutionManager.resolvePendingEffects();\n\n\t\t\tconst charInReserve = player.zones.reserveZone.findById(seasonedCharObject.objectId);\n\t\t\texpect(charInReserve).toBeDefined();\n\t\t\texpect(charInReserve?.objectId).toBe(seasonedCharObject.objectId);\n\t\t\texpect(charInReserve?.boostCounters).toBe(3);\n\t\t});\n\n\t\ttest('Rule 2.5.j (Control): Non-Seasoned character loses boosts when moved to Reserve by an effect', async () => {\n\t\t\taddBoostsToGameObject(nonSeasonedCharObject, 3);\n\t\t\texpect(nonSeasonedCharObject.boostCounters).toBe(3);\n\t\t\texpect(nonSeasonedCharObject.currentCharacteristics.isSeasoned).toBe(false);\n\n\t\t\tconst spellInst = gsm.objectFactory.createCardInstance(\n\t\t\t\tcardDef_MoveCharacterToReserveSpell.id,\n\t\t\t\tP1\n\t\t\t);\n\t\t\tplayer.zones.hand.add(spellInst);\n\n\t\t\tplayer.zones.expeditionZone.remove(seasonedCharObject.objectId); // Simplify targeting\n\n\t\t\tconst playResult = await gsm.playerPlaysCardFromHand(P1, spellInst.instanceId, {\n\t\t\t\ttargetObjectIds: [nonSeasonedCharObject.objectId]\n\t\t\t});\n\t\t\texpect(playResult.success).toBe(true);\n\t\t\tawait gsm.effectExecutionManager.resolvePendingEffects();\n\n\t\t\tconst charInReserve = player.zones.reserveZone.findById(nonSeasonedCharObject.objectId);\n\t\t\texpect(charInReserve).toBeDefined();\n\t\t\texpect(charInReserve?.objectId).toBe(nonSeasonedCharObject.objectId);\n\t\t\texpect(charInReserve?.boostCounters).toBe(0);\n\t\t});\n\t});\n\n\t// --- Tough Keyword Rules (Rule 7.4.7) ---\n\tdescribe('Tough Keyword Rules (Rule 7.4.7)', () => {\n\t\tlet p1: ReturnType<GameStateManager['getPlayer']>;\n\t\tlet p2: ReturnType<GameStateManager['getPlayer']>;\n\t\tlet tough1CharP1: IGameObject;\n\t\tlet tough2CharP1: IGameObject;\n\t\tlet normalCharP1: IGameObject;\n\t\tlet targetingSpellP2: ICardDefinition; // Keep as ICardDefinition for cost checks\n\t\tlet targetingSpellP1: ICardDefinition; // Keep as ICardDefinition for cost checks\n\n\t\tbeforeEach(async () => {\n\t\t\tp1 = gsm.getPlayer(P1)!;\n\t\t\tp2 = gsm.getPlayer(P2)!;\n\n\t\t\t// Set initial mana\n\t\t\tp1.currentMana = 10;\n\t\t\tp2.currentMana = 10;\n\n\t\t\t// Clear zones\n\t\t\tp1.zones.hand.clear();\n\t\t\tp1.zones.expeditionZone.clear();\n\t\t\tp1.zones.reserveZone.clear();\n\t\t\tp1.zones.discardPile.clear();\n\t\t\tp2.zones.hand.clear();\n\t\t\tp2.zones.expeditionZone.clear(); // P2 shouldn't have expedition units for these tests usually\n\t\t\tp2.zones.discardPile.clear();\n\n\t\t\tgsm.effectExecutionManager.resetPendingEffects();\n\n\t\t\t// Create P1's characters and place in P1's expedition zone\n\t\t\tconst tough1Def = gsm.cardDataRepository.getCardDefinition(cardDef_Tough1Char_P1.id)!;\n\t\t\ttough1CharP1 = gsm.objectFactory.createGameObject(\n\t\t\t\tgsm.objectFactory.createCardInstance(tough1Def.id, P1),\n\t\t\t\tP1\n\t\t\t);\n\t\t\tgsm.zones.addToZone(tough1CharP1, ZoneIdentifier.Expedition, P1);\n\n\t\t\tconst tough2Def = gsm.cardDataRepository.getCardDefinition(cardDef_Tough2Char_P1.id)!;\n\t\t\ttough2CharP1 = gsm.objectFactory.createGameObject(\n\t\t\t\tgsm.objectFactory.createCardInstance(tough2Def.id, P1),\n\t\t\t\tP1\n\t\t\t);\n\t\t\tgsm.zones.addToZone(tough2CharP1, ZoneIdentifier.Expedition, P1);\n\n\t\t\tconst normalDef = gsm.cardDataRepository.getCardDefinition(cardDef_NormalChar_P1.id)!;\n\t\t\tnormalCharP1 = gsm.objectFactory.createGameObject(\n\t\t\t\tgsm.objectFactory.createCardInstance(normalDef.id, P1),\n\t\t\t\tP1\n\t\t\t);\n\t\t\tgsm.zones.addToZone(normalCharP1, ZoneIdentifier.Expedition, P1);\n\n\t\t\t// Apply passive abilities (like Tough)\n\t\t\tgsm.ruleAdjudicator.applyAllPassiveAbilities();\n\t\t\texpect(tough1CharP1.currentCharacteristics.isTough).toBe(1); // Check if Tough value is correctly applied\n\t\t\texpect(tough2CharP1.currentCharacteristics.isTough).toBe(2);\n\t\t\texpect(normalCharP1.currentCharacteristics.isTough).toBeUndefined();\n\n\t\t\t// Get spell definitions (not instances yet, as they'll be added to hand in tests)\n\t\t\ttargetingSpellP2 = gsm.cardDataRepository.getCardDefinition(cardDef_TargetingSpell_P2.id)!;\n\t\t\ttargetingSpellP1 = gsm.cardDataRepository.getCardDefinition(cardDef_TargetingSpell_P1.id)!;\n\n\t\t\t// Default to P2 active for most tests, P1 in Action phase\n\t\t\tgsm.currentPhase = GamePhase.Action;\n\t\t\tgsm.activePlayerId = P2; // Most tests involve P2 targeting P1's char\n\t\t});\n\n\t\ttest('Rule 7.4.7.c: Opponent (P2) pays Tough 1 cost successfully', async () => {\n\t\t\tconst spellCardInst = gsm.objectFactory.createCardInstance(targetingSpellP2.id, P2);\n\t\t\tp2.zones.hand.add(spellCardInst);\n\t\t\tconst initialManaP2 = p2.currentMana; // e.g. 10\n\t\t\tconst spellCost = targetingSpellP2.handCost; // e.g. 1\n\t\t\tconst toughCost = tough1CharP1.currentCharacteristics.isTough as number; // Should be 1\n\n\t\t\t// P2 plays spell targeting P1's Tough 1 char\n\t\t\t// Assuming playerPlaysCardFromHand handles the Tough cost payment automatically if enough mana,\n\t\t\t// or requires an option like { payAdditionalCosts: [{ type: 'tough', amount: toughCost }] }\n\t\t\t// For this test, assume it's automatic if mana is sufficient.\n\t\t\tconst playResult = await gsm.playerPlaysCardFromHand(P2, spellCardInst.instanceId, {\n\t\t\t\ttargetObjectIds: [tough1CharP1.objectId]\n\t\t\t});\n\t\t\texpect(playResult.success).toBe(true);\n\t\t\tawait gsm.effectExecutionManager.resolvePendingEffects();\n\n\t\t\texpect(p2.currentMana).toBe(initialManaP2 - spellCost - toughCost);\n\t\t\t// Check if effect applied (e.g., stats changed or card tapped)\n\t\t\t// For 'modifyStats' as defined in cardDef_TargetingSpell_P2:\n\t\t\tconst targetStats = gsm.getObject(tough1CharP1.objectId)?.currentStats;\n\t\t\tconst originalStats = cardDef_Tough1Char_P1.statistics;\n\t\t\texpect(targetStats?.forest).toBe(originalStats.forest - 1);\n\t\t});\n\n\t\ttest('Rule 7.4.7.c, 7.4.7.d: Opponent (P2) fails to target if Tough 1 cost not paid (insufficient mana)', async () => {\n\t\t\tconst spellCardInst = gsm.objectFactory.createCardInstance(targetingSpellP2.id, P2);\n\t\t\tp2.zones.hand.add(spellCardInst);\n\t\t\tconst spellCost = targetingSpellP2.handCost; // 1\n\t\t\tconst toughCost = tough1CharP1.currentCharacteristics.isTough as number; // 1\n\n\t\t\tp2.currentMana = spellCost + toughCost - 1; // Not enough for spell + tough (e.g., 1 mana, needs 2)\n\t\t\tconst initialManaP2 = p2.currentMana;\n\n\t\t\tconst playResult = await gsm.playerPlaysCardFromHand(P2, spellCardInst.instanceId, {\n\t\t\t\ttargetObjectIds: [tough1CharP1.objectId]\n\t\t\t});\n\t\t\texpect(playResult.success).toBe(false); // Play should fail\n\t\t\t// Ensure mana is NOT spent if play fails due to pre-check\n\t\t\texpect(p2.currentMana).toBe(initialManaP2);\n\n\t\t\tconst targetStats = gsm.getObject(tough1CharP1.objectId)?.currentStats;\n\t\t\tconst originalStats = cardDef_Tough1Char_P1.statistics;\n\t\t\texpect(targetStats?.forest).toBe(originalStats.forest); // Effect not applied\n\t\t});\n\n\t\ttest('Rule 7.4.7.c (implicitly): Controller (P1) does not pay Tough cost for own character', async () => {\n\t\t\tgsm.activePlayerId = P1; // P1 is active\n\t\t\tconst spellCardInst = gsm.objectFactory.createCardInstance(targetingSpellP1.id, P1);\n\t\t\tp1.zones.hand.add(spellCardInst);\n\t\t\tconst initialManaP1 = p1.currentMana;\n\t\t\tconst spellCost = targetingSpellP1.handCost;\n\n\t\t\tconst playResult = await gsm.playerPlaysCardFromHand(P1, spellCardInst.instanceId, {\n\t\t\t\ttargetObjectIds: [tough1CharP1.objectId]\n\t\t\t});\n\t\t\texpect(playResult.success).toBe(true);\n\t\t\tawait gsm.effectExecutionManager.resolvePendingEffects();\n\n\t\t\texpect(p1.currentMana).toBe(initialManaP1 - spellCost); // Only spell cost\n\t\t\tconst targetStats = gsm.getObject(tough1CharP1.objectId)?.currentStats;\n\t\t\tconst originalStats = cardDef_Tough1Char_P1.statistics;\n\t\t\texpect(targetStats?.forest).toBe(originalStats.forest + 1); // P1's spell was a buff\n\t\t});\n\n\t\ttest('Rule 7.4.7.b, 7.4.7.c: Opponent (P2) pays correct Tough 2 cost', async () => {\n\t\t\tconst spellCardInst = gsm.objectFactory.createCardInstance(targetingSpellP2.id, P2);\n\t\t\tp2.zones.hand.add(spellCardInst);\n\t\t\tconst initialManaP2 = p2.currentMana;\n\t\t\tconst spellCost = targetingSpellP2.handCost;\n\t\t\tconst toughCost = tough2CharP1.currentCharacteristics.isTough as number; // Should be 2\n\n\t\t\tp2.currentMana = spellCost + toughCost + 1; // Ensure enough mana (e.g. 1 + 2 + 1 = 4)\n\t\t\tconst manaBeforePlay = p2.currentMana;\n\n\t\t\tconst playResult = await gsm.playerPlaysCardFromHand(P2, spellCardInst.instanceId, {\n\t\t\t\ttargetObjectIds: [tough2CharP1.objectId]\n\t\t\t});\n\t\t\texpect(playResult.success).toBe(true);\n\t\t\tawait gsm.effectExecutionManager.resolvePendingEffects();\n\n\t\t\texpect(p2.currentMana).toBe(manaBeforePlay - spellCost - toughCost);\n\t\t\tconst targetStats = gsm.getObject(tough2CharP1.objectId)?.currentStats;\n\t\t\tconst originalStats = cardDef_Tough2Char_P1.statistics;\n\t\t\texpect(targetStats?.forest).toBe(originalStats.forest - 1);\n\t\t});\n\n\t\ttest('Targeting non-Tough character (P1 NormalChar) does not require Tough cost from P2', async () => {\n\t\t\tconst spellCardInst = gsm.objectFactory.createCardInstance(targetingSpellP2.id, P2);\n\t\t\tp2.zones.hand.add(spellCardInst);\n\t\t\tconst initialManaP2 = p2.currentMana;\n\t\t\tconst spellCost = targetingSpellP2.handCost;\n\n\t\t\t// Ensure P2 has just enough for spell, but would not be enough if Tough 1 was added\n\t\t\tp2.currentMana = spellCost;\n\t\t\tconst manaBeforePlay = p2.currentMana;\n\n\t\t\tconst playResult = await gsm.playerPlaysCardFromHand(P2, spellCardInst.instanceId, {\n\t\t\t\ttargetObjectIds: [normalCharP1.objectId]\n\t\t\t});\n\t\t\texpect(playResult.success).toBe(true);\n\t\t\tawait gsm.effectExecutionManager.resolvePendingEffects();\n\n\t\t\texpect(p2.currentMana).toBe(manaBeforePlay - spellCost); // Only spell cost paid\n\t\t\tconst targetStats = gsm.getObject(normalCharP1.objectId)?.currentStats;\n\t\t\tconst originalStats = cardDef_NormalChar_P1.statistics;\n\t\t\texpect(targetStats?.forest).toBe(originalStats.forest - 1);\n\t\t});\n\t});\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/ManaSystem.test.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'TerrainType' is defined but never used.",
				"line": 5,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 5,
				"endColumn": 21
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 72,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 72,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [2493, 2494], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 76,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 76,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [2598, 2599], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 79,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 79,
				"endColumn": 21,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [2706, 2707], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 80,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 80,
				"endColumn": 21,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [2749, 2750], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 90,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 90,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3128, 3129], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 94,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 94,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3233, 3234], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 97,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 97,
				"endColumn": 19,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3337, 3338], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 102,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 102,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3563, 3564], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 123,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 123,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [4341, 4342], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 141,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 141,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [4923, 4924], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 160,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 160,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [5597, 5598], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 182,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 182,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [6418, 6419], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 189,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 189,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [6623, 6624], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 205,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 205,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [7317, 7318], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 212,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 212,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [7520, 7521], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 228,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 228,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [8143, 8144], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 246,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 246,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [8913, 8914], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 265,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 265,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [9692, 9693], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 267,
				"column": 28,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 267,
				"endColumn": 35,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [9754, 9755], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 268,
				"column": 29,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 268,
				"endColumn": 36,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [9822, 9823], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 273,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 273,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [9991, 9992], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 274,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 274,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10068, 10069], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 277,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 277,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10205, 10206], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 279,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 279,
				"endColumn": 20,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10358, 10359], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 281,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 281,
				"endColumn": 20,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10513, 10514], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'player' is assigned a value but never used.",
				"line": 285,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 285,
				"endColumn": 16
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 300,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 300,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [11267, 11268], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 301,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 301,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [11305, 11306], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 325,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 325,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [12170, 12171], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 326,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 326,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [12219, 12220], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 349,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 349,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [12989, 12990], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 358,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 358,
				"endColumn": 33,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [13336, 13337], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 359,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 359,
				"endColumn": 33,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [13390, 13391], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 367,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 367,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [13698, 13699], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 397,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 397,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [14535, 14536], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 2,
		"fatalErrorCount": 0,
		"warningCount": 34,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, test, expect, beforeEach } from 'bun:test';\nimport { ManaSystem } from '../../src/engine/ManaSystem';\nimport { GameStateManager } from '../../src/engine/GameStateManager';\nimport { EventBus } from '../../src/engine/EventBus';\nimport { TerrainType, StatusType, CardType } from '../../src/engine/types/enums';\nimport type { ICardDefinition } from '../../src/engine/types/cards';\n\n/**\n * Unit tests for ManaSystem - Rules 3.2.9 (Mana Zone) and 2.2.10 (Terrain Statistics)\n * Following TDD methodology: write failing tests based on Altered rules, then fix implementation\n */\ndescribe('ManaSystem - Mana and Terrain Rules', () => {\n\tlet manaSystem: ManaSystem;\n\tlet gameStateManager: GameStateManager;\n\tlet eventBus: EventBus;\n\n\tbeforeEach(() => {\n\t\teventBus = new EventBus();\n\t\tconst mockCardDefinitions: ICardDefinition[] = [\n\t\t\t{\n\t\t\t\tid: 'character-forest',\n\t\t\t\tname: 'Forest Character',\n\t\t\t\ttype: CardType.Character,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 2, forest: 2, mountain: 0, water: 0 },\n\t\t\t\treserveCost: { total: 1, forest: 1, mountain: 0, water: 0 },\n\t\t\t\tfaction: 'Forest',\n\t\t\t\tstatistics: { forest: 3, mountain: 0, water: 1 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'character-mountain',\n\t\t\t\tname: 'Mountain Character',\n\t\t\t\ttype: CardType.Character,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 2, forest: 0, mountain: 2, water: 0 },\n\t\t\t\treserveCost: { total: 1, forest: 0, mountain: 1, water: 0 },\n\t\t\t\tfaction: 'Mountain',\n\t\t\t\tstatistics: { forest: 0, mountain: 3, water: 1 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'basic-card',\n\t\t\t\tname: 'Basic Card',\n\t\t\t\ttype: CardType.Spell,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 1, forest: 0, mountain: 0, water: 0 },\n\t\t\t\treserveCost: { total: 1, forest: 0, mountain: 0, water: 0 },\n\t\t\t\tfaction: 'Neutral',\n\t\t\t\tstatistics: { forest: 0, mountain: 0, water: 0 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t}\n\t\t];\n\n\t\tgameStateManager = new GameStateManager(['player1', 'player2'], mockCardDefinitions, eventBus);\n\t\tmanaSystem = new ManaSystem(gameStateManager);\n\t\tgameStateManager.initializeGame();\n\t});\n\n\tdescribe('Rule 3.2.9: Mana Zone and Mana Orbs', () => {\n\t\ttest('Rule 3.2.9.b: Cards should enter Mana zone face-down and exhausted', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('basic-card', 'player1');\n\n\t\t\t// Add card to hand first\n\t\t\tplayer!.zones.handZone.add(card);\n\n\t\t\tmanaSystem.addCardToMana('player1', card.id);\n\n\t\t\tconst manaZone = player!.zones.manaZone;\n\t\t\tconst addedCard = manaZone.getAll().find((c) => c.id === card.id);\n\n\t\t\texpect(addedCard!.faceDown).toBe(true);\n\t\t\texpect(addedCard!.statuses.has(StatusType.Exhausted)).toBe(true);\n\t\t});\n\n\t\ttest('Rule 3.2.9.c: Cards in Mana zone should become type \"Mana Orb\"', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('basic-card', 'player1');\n\n\t\t\texpect(card.type).toBe(CardType.Spell); // Original type\n\n\t\t\t// Add card to hand first\n\t\t\tplayer!.zones.handZone.add(card);\n\n\t\t\tmanaSystem.addCardToMana('player1', card.id);\n\n\t\t\tconst manaZone = player!.zones.manaZone;\n\t\t\tconst manaOrb = manaZone.getAll().find((c) => c.id === card.id);\n\n\t\t\texpect(manaOrb!.type).toBe(CardType.ManaOrb); // Type changed\n\t\t});\n\n\t\ttest('Rule 3.2.9.e: Should be able to exhaust one Mana Orb to ready another', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst manaOrbs = player!.zones.manaZone.getAll();\n\n\t\t\t// Start with all orbs ready\n\t\t\tmanaOrbs.forEach((orb) => orb.statuses.delete(StatusType.Exhausted));\n\n\t\t\t// Exhaust second orb, then use conversion (first orb ready -> second orb ready)\n\t\t\tmanaOrbs[1].statuses.add(StatusType.Exhausted);\n\n\t\t\tconst conversionResult = manaSystem.convertMana(\n\t\t\t\t'player1',\n\t\t\t\tmanaOrbs[0].objectId,\n\t\t\t\tmanaOrbs[1].objectId\n\t\t\t);\n\n\t\t\texpect(conversionResult).toBe(true);\n\t\t\texpect(manaOrbs[0].statuses.has(StatusType.Exhausted)).toBe(true); // Used for conversion\n\t\t\texpect(manaOrbs[1].statuses.has(StatusType.Exhausted)).toBe(false); // Now ready\n\t\t});\n\n\t\ttest('Rule 3.2.9.f: Should pay X mana by exhausting X Mana Orbs', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst manaOrbs = player!.zones.manaZone.getAll();\n\n\t\t\t// Start with all orbs ready\n\t\t\tmanaOrbs.forEach((orb) => orb.statuses.delete(StatusType.Exhausted));\n\n\t\t\tconst paymentResult = manaSystem.payMana('player1', 2);\n\n\t\t\texpect(paymentResult.success).toBe(true);\n\n\t\t\t// Exactly 2 orbs should be exhausted\n\t\t\tconst exhaustedCount = manaOrbs.filter((orb) =>\n\t\t\t\torb.statuses.has(StatusType.Exhausted)\n\t\t\t).length;\n\t\t\texpect(exhaustedCount).toBe(2);\n\t\t});\n\n\t\ttest('Should not be able to pay more mana than available', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst manaOrbs = player!.zones.manaZone.getAll();\n\n\t\t\t// Start with all orbs ready (3 total)\n\t\t\tmanaOrbs.forEach((orb) => orb.statuses.delete(StatusType.Exhausted));\n\n\t\t\tconst paymentResult = manaSystem.payMana('player1', 5); // More than available\n\n\t\t\texpect(paymentResult.success).toBe(false);\n\t\t\texpect(paymentResult.error).toBe('Insufficient mana');\n\n\t\t\t// No orbs should be exhausted\n\t\t\tconst exhaustedCount = manaOrbs.filter((orb) =>\n\t\t\t\torb.statuses.has(StatusType.Exhausted)\n\t\t\t).length;\n\t\t\texpect(exhaustedCount).toBe(0);\n\t\t});\n\n\t\ttest('Should correctly calculate available mana from ready orbs', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst manaOrbs = player!.zones.manaZone.getAll();\n\n\t\t\t// Start with all orbs ready\n\t\t\tmanaOrbs.forEach((orb) => orb.statuses.delete(StatusType.Exhausted));\n\n\t\t\tlet availableMana = manaSystem.getManaFromOrbs('player1');\n\t\t\texpect(availableMana).toBe(3); // All 3 orbs ready\n\n\t\t\t// Exhaust one orb\n\t\t\tmanaOrbs[0].statuses.add(StatusType.Exhausted);\n\n\t\t\tavailableMana = manaSystem.getManaFromOrbs('player1');\n\t\t\texpect(availableMana).toBe(2); // Only 2 orbs ready\n\t\t});\n\t});\n\n\tdescribe('Rule 2.2.10: Character Statistics and Terrain Mana', () => {\n\t\ttest('Rule 2.2.10: Characters should provide terrain-based mana through statistics', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add forest character to expedition\n\t\t\tconst forestChar = gameStateManager.objectFactory.createCard('character-forest', 'player1');\n\t\t\tplayer!.zones.expeditionZone.add(forestChar);\n\n\t\t\t// Add mountain character to hero zone\n\t\t\tconst mountainChar = gameStateManager.objectFactory.createCard(\n\t\t\t\t'character-mountain',\n\t\t\t\t'player1'\n\t\t\t);\n\t\t\tplayer!.zones.heroZone.add(mountainChar);\n\n\t\t\tconst manaPool = manaSystem.getAvailableMana('player1');\n\n\t\t\texpect(manaPool.forest).toBe(3); // From forest character\n\t\t\texpect(manaPool.mountain).toBe(3); // From mountain character\n\t\t\texpect(manaPool.water).toBe(2); // From both characters (1+1)\n\t\t\texpect(manaPool.orbs).toBe(3); // From mana orbs\n\t\t\texpect(manaPool.total).toBe(11); // 3+3+2+3\n\t\t});\n\n\t\ttest('Should only count statistics from characters in expedition and hero zones', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add character to hand (shouldn't count)\n\t\t\tconst handChar = gameStateManager.objectFactory.createCard('character-forest', 'player1');\n\t\t\tplayer!.zones.handZone.add(handChar);\n\n\t\t\t// Add character to reserve (shouldn't count)\n\t\t\tconst reserveChar = gameStateManager.objectFactory.createCard(\n\t\t\t\t'character-mountain',\n\t\t\t\t'player1'\n\t\t\t);\n\t\t\tplayer!.zones.reserveZone.add(reserveChar);\n\n\t\t\tconst manaPool = manaSystem.getAvailableMana('player1');\n\n\t\t\texpect(manaPool.forest).toBe(0); // Hand character doesn't count\n\t\t\texpect(manaPool.mountain).toBe(0); // Reserve character doesn't count\n\t\t\texpect(manaPool.water).toBe(0);\n\t\t\texpect(manaPool.orbs).toBe(3); // Only mana orbs\n\t\t\texpect(manaPool.total).toBe(3);\n\t\t});\n\n\t\ttest('Should handle terrain restrictions correctly', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add forest character\n\t\t\tconst forestChar = gameStateManager.objectFactory.createCard('character-forest', 'player1');\n\t\t\tplayer!.zones.expeditionZone.add(forestChar);\n\n\t\t\t// Should be able to pay forest cost\n\t\t\tconst forestCost = { total: 2, forest: 2, mountain: 0, water: 0 };\n\t\t\tconst canPayForest = manaSystem.canPayCost('player1', forestCost);\n\t\t\texpect(canPayForest).toBe(true);\n\n\t\t\t// Should not be able to pay mountain cost\n\t\t\tconst mountainCost = { total: 2, forest: 0, mountain: 2, water: 0 };\n\t\t\tconst canPayMountain = manaSystem.canPayCost('player1', mountainCost);\n\t\t\texpect(canPayMountain).toBe(false);\n\t\t});\n\n\t\ttest('Should allow terrain mana to be used for generic costs', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add character with terrain stats\n\t\t\tconst character = gameStateManager.objectFactory.createCard('character-forest', 'player1');\n\t\t\tplayer!.zones.expeditionZone.add(character);\n\n\t\t\t// Should be able to pay generic cost with terrain mana\n\t\t\tconst genericCost = { total: 2, forest: 0, mountain: 0, water: 0 };\n\t\t\tconst canPayGeneric = manaSystem.canPayCost('player1', genericCost);\n\t\t\texpect(canPayGeneric).toBe(true);\n\n\t\t\t// Pay the cost\n\t\t\tconst paymentResult = manaSystem.payGenericCost('player1', genericCost);\n\t\t\texpect(paymentResult.success).toBe(true);\n\t\t});\n\t});\n\n\tdescribe('Rule 4.2.1.e: Expand Mechanics', () => {\n\t\ttest('Should allow adding card from hand to mana during Morning phase', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add card to hand (cards in hand should be game objects)\n\t\t\tconst card = gameStateManager.objectFactory.createCard('basic-card', 'player1');\n\t\t\tplayer!.zones.handZone.add(card);\n\n\t\t\tconst initialHandSize = player!.zones.handZone.getAll().length;\n\t\t\tconst initialManaCount = player!.zones.manaZone.getAll().length;\n\n\t\t\tconst expandResult = manaSystem.expandMana('player1', card.objectId);\n\n\t\t\texpect(expandResult.success).toBe(true);\n\t\t\texpect(player!.zones.handZone.getAll().length).toBe(initialHandSize - 1);\n\t\t\texpect(player!.zones.manaZone.getAll().length).toBe(initialManaCount + 1);\n\n\t\t\t// Card should be in mana zone and face-down\n\t\t\tconst manaCard = player!.zones.manaZone.getAll().find((c) => c.id === card.id); // Assuming card.id is the instanceId here\n\t\t\texpect(manaCard).toBeDefined();\n\t\t\texpect(manaCard!.faceDown).toBe(true);\n\t\t\t// Rule 4.2.1.e: \"Expand Each player may put one card from their Hand in their Mana zone as a ready Mana Orb\"\n\t\t\texpect(manaCard!.statuses.has(StatusType.Exhausted)).toBe(false); // Should be ready\n\t\t});\n\n\t\ttest('Should prevent expand if card not in hand', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Try to expand card not in hand\n\t\t\tconst expandResult = manaSystem.expandMana('player1', 'nonexistent-card');\n\n\t\t\texpect(expandResult.success).toBe(false);\n\t\t\texpect(expandResult.error).toBe('Card not found in hand');\n\t\t});\n\n\t\ttest('Should track expand usage per player per turn', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add two cards to hand\n\t\t\tconst card1 = gameStateManager.objectFactory.createCard('basic-card', 'player1');\n\t\t\tconst card2 = gameStateManager.objectFactory.createCard('basic-card', 'player1');\n\t\t\tplayer!.zones.handZone.add(card1);\n\t\t\tplayer!.zones.handZone.add(card2);\n\n\t\t\t// First expand should succeed\n\t\t\tconst expand1 = manaSystem.expandMana('player1', card1.objectId);\n\t\t\texpect(expand1.success).toBe(true);\n\n\t\t\t// Second expand should fail (once per turn)\n\t\t\tconst expand2 = manaSystem.expandMana('player1', card2.objectId);\n\t\t\texpect(expand2.success).toBe(false);\n\t\t\texpect(expand2.error).toBe('Already expanded this turn');\n\t\t});\n\t});\n\n\tdescribe('Mana Conversion and Complex Payments', () => {\n\t\ttest('Should handle complex mana costs with terrain requirements', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add characters with different terrain stats\n\t\t\tconst forestChar = gameStateManager.objectFactory.createCard('character-forest', 'player1');\n\t\t\tconst mountainChar = gameStateManager.objectFactory.createCard(\n\t\t\t\t'character-mountain',\n\t\t\t\t'player1'\n\t\t\t);\n\n\t\t\tplayer!.zones.expeditionZone.add(forestChar);\n\t\t\tplayer!.zones.heroZone.add(mountainChar);\n\n\t\t\t// Complex cost requiring specific terrains\n\t\t\tconst complexCost = { total: 5, forest: 2, mountain: 2, water: 1 };\n\n\t\t\tconst canPay = manaSystem.canPayCost('player1', complexCost);\n\t\t\texpect(canPay).toBe(true);\n\n\t\t\tconst paymentResult = manaSystem.payComplexCost('player1', complexCost);\n\t\t\texpect(paymentResult.success).toBe(true);\n\t\t\texpect(paymentResult.payment).toEqual({\n\t\t\t\tforestUsed: 2,\n\t\t\t\tmountainUsed: 2,\n\t\t\t\twaterUsed: 1,\n\t\t\t\torbsUsed: 0\n\t\t\t});\n\t\t});\n\n\t\ttest('Should prioritize specific terrain mana over generic mana', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add forest character\n\t\t\tconst forestChar = gameStateManager.objectFactory.createCard('character-forest', 'player1');\n\t\t\tplayer!.zones.expeditionZone.add(forestChar);\n\n\t\t\t// Cost with forest and generic components\n\t\t\tconst cost = { total: 4, forest: 2, mountain: 0, water: 0 };\n\n\t\t\tconst paymentResult = manaSystem.payComplexCost('player1', cost);\n\n\t\t\texpect(paymentResult.success).toBe(true);\n\t\t\t// Should use forest mana first, then generic\n\t\t\texpect(paymentResult.payment!.forestUsed).toBe(2);\n\t\t\texpect(paymentResult.payment!.orbsUsed).toBe(2); // Remaining generic cost\n\t\t});\n\n\t\ttest('Should handle mana overflow correctly', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add character with high stats\n\t\t\tconst character = gameStateManager.objectFactory.createCard('character-forest', 'player1');\n\t\t\tplayer!.zones.expeditionZone.add(character);\n\n\t\t\tconst manaPool = manaSystem.getAvailableMana('player1');\n\n\t\t\t// Should not have negative values\n\t\t\texpect(manaPool.forest).toBeGreaterThanOrEqual(0);\n\t\t\texpect(manaPool.mountain).toBeGreaterThanOrEqual(0);\n\t\t\texpect(manaPool.water).toBeGreaterThanOrEqual(0);\n\t\t\texpect(manaPool.orbs).toBeGreaterThanOrEqual(0);\n\t\t\texpect(manaPool.total).toBeGreaterThanOrEqual(0);\n\t\t});\n\t});\n\n\tdescribe('Error Handling', () => {\n\t\ttest('Should handle invalid player ID gracefully', () => {\n\t\t\tconst manaPool = manaSystem.getAvailableMana('invalid-player');\n\n\t\t\texpect(manaPool).toEqual({\n\t\t\t\ttotal: 0,\n\t\t\t\tforest: 0,\n\t\t\t\tmountain: 0,\n\t\t\t\twater: 0,\n\t\t\t\torbs: 0\n\t\t\t});\n\t\t});\n\n\t\ttest('Should handle empty mana zone', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Clear mana zone\n\t\t\tplayer!.zones.manaZone.clear();\n\n\t\t\tconst availableMana = manaSystem.getManaFromOrbs('player1');\n\t\t\texpect(availableMana).toBe(0);\n\n\t\t\tconst paymentResult = manaSystem.payMana('player1', 1);\n\t\t\texpect(paymentResult.success).toBe(false);\n\t\t\texpect(paymentResult.error).toBe('Insufficient mana');\n\t\t});\n\n\t\ttest('Should validate mana conversion parameters', () => {\n\t\t\t// Test with completely invalid IDs should return false\n\t\t\tconst conversionResult = manaSystem.convertMana(\n\t\t\t\t'invalid-player',\n\t\t\t\t'invalid-source',\n\t\t\t\t'invalid-target'\n\t\t\t);\n\n\t\t\texpect(conversionResult).toBe(false);\n\t\t});\n\t});\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/ManaSystem.test.vitest.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'TerrainType' is defined but never used.",
				"line": 5,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 5,
				"endColumn": 21
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 72,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 72,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [2505, 2506], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 76,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 76,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [2610, 2611], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 79,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 79,
				"endColumn": 21,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [2718, 2719], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 80,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 80,
				"endColumn": 21,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [2761, 2762], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 90,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 90,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3140, 3141], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 94,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 94,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3245, 3246], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 97,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 97,
				"endColumn": 19,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3349, 3350], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 102,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 102,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3575, 3576], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 123,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 123,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [4353, 4354], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 141,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 141,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [4935, 4936], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 160,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 160,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [5609, 5610], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 182,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 182,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [6430, 6431], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 189,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 189,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [6635, 6636], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 205,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 205,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [7329, 7330], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 212,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 212,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [7532, 7533], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 228,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 228,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [8155, 8156], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 246,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 246,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [8925, 8926], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 265,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 265,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [9704, 9705], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 267,
				"column": 28,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 267,
				"endColumn": 35,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [9766, 9767], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 268,
				"column": 29,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 268,
				"endColumn": 36,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [9834, 9835], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 273,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 273,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10003, 10004], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 274,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 274,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10080, 10081], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 277,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 277,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10217, 10218], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 279,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 279,
				"endColumn": 20,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10327, 10328], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'player' is assigned a value but never used.",
				"line": 283,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 283,
				"endColumn": 16
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 298,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 298,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [11035, 11036], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 299,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 299,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [11073, 11074], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 323,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 323,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [11938, 11939], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 324,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 324,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [11987, 11988], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 347,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 347,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [12757, 12758], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 356,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 356,
				"endColumn": 33,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [13104, 13105], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 357,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 357,
				"endColumn": 33,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [13158, 13159], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 365,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 365,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [13466, 13467], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 395,
				"column": 4,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 395,
				"endColumn": 11,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [14303, 14304], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 2,
		"fatalErrorCount": 0,
		"warningCount": 33,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, test, expect, beforeEach } from 'bun:test';\nimport { ManaSystem } from '../../src/engine/ManaSystem';\nimport { GameStateManager } from '../../src/engine/GameStateManager';\nimport { EventBus } from '../../src/engine/EventBus';\nimport { TerrainType, StatusType, CardType } from '../../src/engine/types/enums';\nimport type { ICardDefinition } from '../../src/engine/types/cards';\n\n/**\n * Unit tests for ManaSystem - Rules 3.2.9 (Mana Zone) and 2.2.10 (Terrain Statistics)\n * Following TDD methodology: write failing tests based on Altered rules, then fix implementation\n */\ndescribe('ManaSystem - Mana and Terrain Rules', () => {\n\tlet manaSystem: ManaSystem;\n\tlet gameStateManager: GameStateManager;\n\tlet eventBus: EventBus;\n\n\tbeforeEach(async () => {\n\t\teventBus = new EventBus();\n\t\tconst mockCardDefinitions: ICardDefinition[] = [\n\t\t\t{\n\t\t\t\tid: 'character-forest',\n\t\t\t\tname: 'Forest Character',\n\t\t\t\ttype: CardType.Character,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 2, forest: 2, mountain: 0, water: 0 },\n\t\t\t\treserveCost: { total: 1, forest: 1, mountain: 0, water: 0 },\n\t\t\t\tfaction: 'Forest',\n\t\t\t\tstatistics: { forest: 3, mountain: 0, water: 1 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'character-mountain',\n\t\t\t\tname: 'Mountain Character',\n\t\t\t\ttype: CardType.Character,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 2, forest: 0, mountain: 2, water: 0 },\n\t\t\t\treserveCost: { total: 1, forest: 0, mountain: 1, water: 0 },\n\t\t\t\tfaction: 'Mountain',\n\t\t\t\tstatistics: { forest: 0, mountain: 3, water: 1 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'basic-card',\n\t\t\t\tname: 'Basic Card',\n\t\t\t\ttype: CardType.Spell,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 1, forest: 0, mountain: 0, water: 0 },\n\t\t\t\treserveCost: { total: 1, forest: 0, mountain: 0, water: 0 },\n\t\t\t\tfaction: 'Neutral',\n\t\t\t\tstatistics: { forest: 0, mountain: 0, water: 0 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t}\n\t\t];\n\n\t\tgameStateManager = new GameStateManager(['player1', 'player2'], mockCardDefinitions, eventBus);\n\t\tmanaSystem = new ManaSystem(gameStateManager);\n\t\tawait gameStateManager.initializeGame();\n\t});\n\n\tdescribe('Rule 3.2.9: Mana Zone and Mana Orbs', () => {\n\t\ttest('Rule 3.2.9.b: Cards should enter Mana zone face-down and exhausted', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('basic-card', 'player1');\n\n\t\t\t// Add card to hand first\n\t\t\tplayer!.zones.handZone.add(card);\n\n\t\t\tmanaSystem.addCardToMana('player1', card.id);\n\n\t\t\tconst manaZone = player!.zones.manaZone;\n\t\t\tconst addedCard = manaZone.getAll().find((c) => c.id === card.id);\n\n\t\t\texpect(addedCard!.faceDown).toBe(true);\n\t\t\texpect(addedCard!.statuses.has(StatusType.Exhausted)).toBe(true);\n\t\t});\n\n\t\ttest('Rule 3.2.9.c: Cards in Mana zone should become type \"Mana Orb\"', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst card = gameStateManager.objectFactory.createCard('basic-card', 'player1');\n\n\t\t\texpect(card.type).toBe(CardType.Spell); // Original type\n\n\t\t\t// Add card to hand first\n\t\t\tplayer!.zones.handZone.add(card);\n\n\t\t\tmanaSystem.addCardToMana('player1', card.id);\n\n\t\t\tconst manaZone = player!.zones.manaZone;\n\t\t\tconst manaOrb = manaZone.getAll().find((c) => c.id === card.id);\n\n\t\t\texpect(manaOrb!.type).toBe(CardType.ManaOrb); // Type changed\n\t\t});\n\n\t\ttest('Rule 3.2.9.e: Should be able to exhaust one Mana Orb to ready another', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst manaOrbs = player!.zones.manaZone.getAll();\n\n\t\t\t// Start with all orbs ready\n\t\t\tmanaOrbs.forEach((orb) => orb.statuses.delete(StatusType.Exhausted));\n\n\t\t\t// Exhaust second orb, then use conversion (first orb ready -> second orb ready)\n\t\t\tmanaOrbs[1].statuses.add(StatusType.Exhausted);\n\n\t\t\tconst conversionResult = manaSystem.convertMana(\n\t\t\t\t'player1',\n\t\t\t\tmanaOrbs[0].objectId,\n\t\t\t\tmanaOrbs[1].objectId\n\t\t\t);\n\n\t\t\texpect(conversionResult).toBe(true);\n\t\t\texpect(manaOrbs[0].statuses.has(StatusType.Exhausted)).toBe(true); // Used for conversion\n\t\t\texpect(manaOrbs[1].statuses.has(StatusType.Exhausted)).toBe(false); // Now ready\n\t\t});\n\n\t\ttest('Rule 3.2.9.f: Should pay X mana by exhausting X Mana Orbs', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst manaOrbs = player!.zones.manaZone.getAll();\n\n\t\t\t// Start with all orbs ready\n\t\t\tmanaOrbs.forEach((orb) => orb.statuses.delete(StatusType.Exhausted));\n\n\t\t\tconst paymentResult = manaSystem.payMana('player1', 2);\n\n\t\t\texpect(paymentResult.success).toBe(true);\n\n\t\t\t// Exactly 2 orbs should be exhausted\n\t\t\tconst exhaustedCount = manaOrbs.filter((orb) =>\n\t\t\t\torb.statuses.has(StatusType.Exhausted)\n\t\t\t).length;\n\t\t\texpect(exhaustedCount).toBe(2);\n\t\t});\n\n\t\ttest('Should not be able to pay more mana than available', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst manaOrbs = player!.zones.manaZone.getAll();\n\n\t\t\t// Start with all orbs ready (3 total)\n\t\t\tmanaOrbs.forEach((orb) => orb.statuses.delete(StatusType.Exhausted));\n\n\t\t\tconst paymentResult = manaSystem.payMana('player1', 5); // More than available\n\n\t\t\texpect(paymentResult.success).toBe(false);\n\t\t\texpect(paymentResult.error).toBe('Insufficient mana');\n\n\t\t\t// No orbs should be exhausted\n\t\t\tconst exhaustedCount = manaOrbs.filter((orb) =>\n\t\t\t\torb.statuses.has(StatusType.Exhausted)\n\t\t\t).length;\n\t\t\texpect(exhaustedCount).toBe(0);\n\t\t});\n\n\t\ttest('Should correctly calculate available mana from ready orbs', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\t\t\tconst manaOrbs = player!.zones.manaZone.getAll();\n\n\t\t\t// Start with all orbs ready\n\t\t\tmanaOrbs.forEach((orb) => orb.statuses.delete(StatusType.Exhausted));\n\n\t\t\tlet availableMana = manaSystem.getManaFromOrbs('player1');\n\t\t\texpect(availableMana).toBe(3); // All 3 orbs ready\n\n\t\t\t// Exhaust one orb\n\t\t\tmanaOrbs[0].statuses.add(StatusType.Exhausted);\n\n\t\t\tavailableMana = manaSystem.getManaFromOrbs('player1');\n\t\t\texpect(availableMana).toBe(2); // Only 2 orbs ready\n\t\t});\n\t});\n\n\tdescribe('Rule 2.2.10: Character Statistics and Terrain Mana', () => {\n\t\ttest('Rule 2.2.10: Characters should provide terrain-based mana through statistics', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add forest character to expedition\n\t\t\tconst forestChar = gameStateManager.objectFactory.createCard('character-forest', 'player1');\n\t\t\tplayer!.zones.expeditionZone.add(forestChar);\n\n\t\t\t// Add mountain character to hero zone\n\t\t\tconst mountainChar = gameStateManager.objectFactory.createCard(\n\t\t\t\t'character-mountain',\n\t\t\t\t'player1'\n\t\t\t);\n\t\t\tplayer!.zones.heroZone.add(mountainChar);\n\n\t\t\tconst manaPool = manaSystem.getAvailableMana('player1');\n\n\t\t\texpect(manaPool.forest).toBe(3); // From forest character\n\t\t\texpect(manaPool.mountain).toBe(3); // From mountain character\n\t\t\texpect(manaPool.water).toBe(2); // From both characters (1+1)\n\t\t\texpect(manaPool.orbs).toBe(3); // From mana orbs\n\t\t\texpect(manaPool.total).toBe(11); // 3+3+2+3\n\t\t});\n\n\t\ttest('Should only count statistics from characters in expedition and hero zones', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add character to hand (shouldn't count)\n\t\t\tconst handChar = gameStateManager.objectFactory.createCard('character-forest', 'player1');\n\t\t\tplayer!.zones.handZone.add(handChar);\n\n\t\t\t// Add character to reserve (shouldn't count)\n\t\t\tconst reserveChar = gameStateManager.objectFactory.createCard(\n\t\t\t\t'character-mountain',\n\t\t\t\t'player1'\n\t\t\t);\n\t\t\tplayer!.zones.reserveZone.add(reserveChar);\n\n\t\t\tconst manaPool = manaSystem.getAvailableMana('player1');\n\n\t\t\texpect(manaPool.forest).toBe(0); // Hand character doesn't count\n\t\t\texpect(manaPool.mountain).toBe(0); // Reserve character doesn't count\n\t\t\texpect(manaPool.water).toBe(0);\n\t\t\texpect(manaPool.orbs).toBe(3); // Only mana orbs\n\t\t\texpect(manaPool.total).toBe(3);\n\t\t});\n\n\t\ttest('Should handle terrain restrictions correctly', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add forest character\n\t\t\tconst forestChar = gameStateManager.objectFactory.createCard('character-forest', 'player1');\n\t\t\tplayer!.zones.expeditionZone.add(forestChar);\n\n\t\t\t// Should be able to pay forest cost\n\t\t\tconst forestCost = { total: 2, forest: 2, mountain: 0, water: 0 };\n\t\t\tconst canPayForest = manaSystem.canPayCost('player1', forestCost);\n\t\t\texpect(canPayForest).toBe(true);\n\n\t\t\t// Should not be able to pay mountain cost\n\t\t\tconst mountainCost = { total: 2, forest: 0, mountain: 2, water: 0 };\n\t\t\tconst canPayMountain = manaSystem.canPayCost('player1', mountainCost);\n\t\t\texpect(canPayMountain).toBe(false);\n\t\t});\n\n\t\ttest('Should allow terrain mana to be used for generic costs', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add character with terrain stats\n\t\t\tconst character = gameStateManager.objectFactory.createCard('character-forest', 'player1');\n\t\t\tplayer!.zones.expeditionZone.add(character);\n\n\t\t\t// Should be able to pay generic cost with terrain mana\n\t\t\tconst genericCost = { total: 2, forest: 0, mountain: 0, water: 0 };\n\t\t\tconst canPayGeneric = manaSystem.canPayCost('player1', genericCost);\n\t\t\texpect(canPayGeneric).toBe(true);\n\n\t\t\t// Pay the cost\n\t\t\tconst paymentResult = manaSystem.payGenericCost('player1', genericCost);\n\t\t\texpect(paymentResult.success).toBe(true);\n\t\t});\n\t});\n\n\tdescribe('Rule 4.2.1.e: Expand Mechanics', () => {\n\t\ttest('Should allow adding card from hand to mana during Morning phase', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add card to hand (cards in hand should be game objects)\n\t\t\tconst card = gameStateManager.objectFactory.createCard('basic-card', 'player1');\n\t\t\tplayer!.zones.handZone.add(card);\n\n\t\t\tconst initialHandSize = player!.zones.handZone.getAll().length;\n\t\t\tconst initialManaCount = player!.zones.manaZone.getAll().length;\n\n\t\t\tconst expandResult = manaSystem.expandMana('player1', card.objectId);\n\n\t\t\texpect(expandResult.success).toBe(true);\n\t\t\texpect(player!.zones.handZone.getAll().length).toBe(initialHandSize - 1);\n\t\t\texpect(player!.zones.manaZone.getAll().length).toBe(initialManaCount + 1);\n\n\t\t\t// Card should be in mana zone and face-down\n\t\t\tconst manaCard = player!.zones.manaZone.getAll().find((c) => c.id === card.id);\n\t\t\texpect(manaCard).toBeDefined();\n\t\t\texpect(manaCard!.faceDown).toBe(true);\n\t\t});\n\n\t\ttest('Should prevent expand if card not in hand', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Try to expand card not in hand\n\t\t\tconst expandResult = manaSystem.expandMana('player1', 'nonexistent-card');\n\n\t\t\texpect(expandResult.success).toBe(false);\n\t\t\texpect(expandResult.error).toBe('Card not found in hand');\n\t\t});\n\n\t\ttest('Should track expand usage per player per turn', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add two cards to hand\n\t\t\tconst card1 = gameStateManager.objectFactory.createCard('basic-card', 'player1');\n\t\t\tconst card2 = gameStateManager.objectFactory.createCard('basic-card', 'player1');\n\t\t\tplayer!.zones.handZone.add(card1);\n\t\t\tplayer!.zones.handZone.add(card2);\n\n\t\t\t// First expand should succeed\n\t\t\tconst expand1 = manaSystem.expandMana('player1', card1.objectId);\n\t\t\texpect(expand1.success).toBe(true);\n\n\t\t\t// Second expand should fail (once per turn)\n\t\t\tconst expand2 = manaSystem.expandMana('player1', card2.objectId);\n\t\t\texpect(expand2.success).toBe(false);\n\t\t\texpect(expand2.error).toBe('Already expanded this turn');\n\t\t});\n\t});\n\n\tdescribe('Mana Conversion and Complex Payments', () => {\n\t\ttest('Should handle complex mana costs with terrain requirements', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add characters with different terrain stats\n\t\t\tconst forestChar = gameStateManager.objectFactory.createCard('character-forest', 'player1');\n\t\t\tconst mountainChar = gameStateManager.objectFactory.createCard(\n\t\t\t\t'character-mountain',\n\t\t\t\t'player1'\n\t\t\t);\n\n\t\t\tplayer!.zones.expeditionZone.add(forestChar);\n\t\t\tplayer!.zones.heroZone.add(mountainChar);\n\n\t\t\t// Complex cost requiring specific terrains\n\t\t\tconst complexCost = { total: 5, forest: 2, mountain: 2, water: 1 };\n\n\t\t\tconst canPay = manaSystem.canPayCost('player1', complexCost);\n\t\t\texpect(canPay).toBe(true);\n\n\t\t\tconst paymentResult = manaSystem.payComplexCost('player1', complexCost);\n\t\t\texpect(paymentResult.success).toBe(true);\n\t\t\texpect(paymentResult.payment).toEqual({\n\t\t\t\tforestUsed: 2,\n\t\t\t\tmountainUsed: 2,\n\t\t\t\twaterUsed: 1,\n\t\t\t\torbsUsed: 0\n\t\t\t});\n\t\t});\n\n\t\ttest('Should prioritize specific terrain mana over generic mana', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add forest character\n\t\t\tconst forestChar = gameStateManager.objectFactory.createCard('character-forest', 'player1');\n\t\t\tplayer!.zones.expeditionZone.add(forestChar);\n\n\t\t\t// Cost with forest and generic components\n\t\t\tconst cost = { total: 4, forest: 2, mountain: 0, water: 0 };\n\n\t\t\tconst paymentResult = manaSystem.payComplexCost('player1', cost);\n\n\t\t\texpect(paymentResult.success).toBe(true);\n\t\t\t// Should use forest mana first, then generic\n\t\t\texpect(paymentResult.payment!.forestUsed).toBe(2);\n\t\t\texpect(paymentResult.payment!.orbsUsed).toBe(2); // Remaining generic cost\n\t\t});\n\n\t\ttest('Should handle mana overflow correctly', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Add character with high stats\n\t\t\tconst character = gameStateManager.objectFactory.createCard('character-forest', 'player1');\n\t\t\tplayer!.zones.expeditionZone.add(character);\n\n\t\t\tconst manaPool = manaSystem.getAvailableMana('player1');\n\n\t\t\t// Should not have negative values\n\t\t\texpect(manaPool.forest).toBeGreaterThanOrEqual(0);\n\t\t\texpect(manaPool.mountain).toBeGreaterThanOrEqual(0);\n\t\t\texpect(manaPool.water).toBeGreaterThanOrEqual(0);\n\t\t\texpect(manaPool.orbs).toBeGreaterThanOrEqual(0);\n\t\t\texpect(manaPool.total).toBeGreaterThanOrEqual(0);\n\t\t});\n\t});\n\n\tdescribe('Error Handling', () => {\n\t\ttest('Should handle invalid player ID gracefully', () => {\n\t\t\tconst manaPool = manaSystem.getAvailableMana('invalid-player');\n\n\t\t\texpect(manaPool).toEqual({\n\t\t\t\ttotal: 0,\n\t\t\t\tforest: 0,\n\t\t\t\tmountain: 0,\n\t\t\t\twater: 0,\n\t\t\t\torbs: 0\n\t\t\t});\n\t\t});\n\n\t\ttest('Should handle empty mana zone', () => {\n\t\t\tconst player = gameStateManager.getPlayer('player1');\n\n\t\t\t// Clear mana zone\n\t\t\tplayer!.zones.manaZone.clear();\n\n\t\t\tconst availableMana = manaSystem.getManaFromOrbs('player1');\n\t\t\texpect(availableMana).toBe(0);\n\n\t\t\tconst paymentResult = manaSystem.payMana('player1', 1);\n\t\t\texpect(paymentResult.success).toBe(false);\n\t\t\texpect(paymentResult.error).toBe('Insufficient mana');\n\t\t});\n\n\t\ttest('Should validate mana conversion parameters', () => {\n\t\t\t// Test with completely invalid IDs should return false\n\t\t\tconst conversionResult = manaSystem.convertMana(\n\t\t\t\t'invalid-player',\n\t\t\t\t'invalid-source',\n\t\t\t\t'invalid-target'\n\t\t\t);\n\n\t\t\texpect(conversionResult).toBe(false);\n\t\t});\n\t});\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/PhaseManager.test.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 112,
				"column": 3,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 112,
				"endColumn": 41,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3555, 3556], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 113,
				"column": 3,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 113,
				"endColumn": 41,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3616, 3617], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 114,
				"column": 3,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 114,
				"endColumn": 41,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3679, 3680], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 115,
				"column": 3,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 115,
				"endColumn": 41,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3740, 3741], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 174,
				"column": 20,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 174,
				"endColumn": 58
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 203,
				"column": 20,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 203,
				"endColumn": 58
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 213,
				"column": 20,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 213,
				"endColumn": 58
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 238,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 238,
				"endColumn": 57
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 287,
				"column": 20,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 287,
				"endColumn": 58
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 306,
				"column": 20,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 306,
				"endColumn": 58
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 335,
				"column": 15,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 335,
				"endColumn": 53
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 371,
				"column": 60,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 371,
				"endColumn": 63,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [15501, 15504], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [15501, 15504], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 371,
				"column": 82,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 371,
				"endColumn": 85,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [15523, 15526], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [15523, 15526], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 372,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 372,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 386,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 386,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [16244, 16245], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 387,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 387,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [16332, 16333], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 392,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 392,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [16657, 16658], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 393,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 393,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [16745, 16746], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 398,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 398,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [17055, 17056], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 406,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 406,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [17511, 17512], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 407,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 407,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [17599, 17600], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 412,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 412,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [17898, 17899], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 433,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 433,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [18788, 18789], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 434,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 434,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [18876, 18877], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 435,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 435,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [18969, 18970], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 436,
				"column": 11,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 436,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [19057, 19058], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 443,
				"column": 15,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 443,
				"endColumn": 53
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 477,
				"column": 15,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 477,
				"endColumn": 53
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 513,
				"column": 15,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 513,
				"endColumn": 53
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 514,
				"column": 15,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 514,
				"endColumn": 53
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'initialPlayer' is assigned a value but never used.",
				"line": 541,
				"column": 10,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 541,
				"endColumn": 23
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 30,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, test, expect, beforeEach } from 'bun:test';\nimport { PhaseManager } from '../../src/engine/PhaseManager';\nimport { GameStateManager } from '../../src/engine/GameStateManager';\nimport { TurnManager } from '../../src/engine/TurnManager';\nimport { EventBus } from '../../src/engine/EventBus';\nimport { GamePhase, StatusType, CardType } from '../../src/engine/types/enums';\nimport type { ICardDefinition } from '../../src/engine/types/cards';\n\n/**\n * Unit tests for PhaseManager - Rules 4.2 (Day Structure and Phase Transitions)\n * Following TDD methodology: write failing tests based on Altered rules, then fix implementation\n */\ndescribe('PhaseManager - Phase Transition Rules', () => {\n\tlet phaseManager: PhaseManager;\n\tlet gameStateManager: GameStateManager;\n\tlet turnManager: TurnManager;\n\tlet eventBus: EventBus;\n\n\tbeforeEach(async () => {\n\t\teventBus = new EventBus();\n\t\tconst mockCardDefinitions: ICardDefinition[] = [\n\t\t\t{\n\t\t\t\tid: 'hero-001',\n\t\t\t\tname: 'Test Hero',\n\t\t\t\ttype: CardType.Hero,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 0, forest: 0, mountain: 0, water: 0 },\n\t\t\t\treserveCost: { total: 0, forest: 0, mountain: 0, water: 0 },\n\t\t\t\tfaction: 'Neutral',\n\t\t\t\tstatistics: { forest: 2, mountain: 1, water: 1 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'test-card',\n\t\t\t\tname: 'Test Card',\n\t\t\t\ttype: CardType.Spell,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 1, forest: 0, mountain: 0, water: 0 },\n\t\t\t\treserveCost: { total: 1, forest: 0, mountain: 0, water: 0 },\n\t\t\t\tfaction: 'Neutral',\n\t\t\t\tstatistics: { forest: 0, mountain: 0, water: 0 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t},\n\t\t\t{\n\t\t\t\t// Added missing definition\n\t\t\t\tid: 'character-001',\n\t\t\t\tname: 'Test Character',\n\t\t\t\ttype: CardType.Character,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 3, forest: 1, mountain: 1, water: 1 },\n\t\t\t\treserveCost: { total: 2, forest: 0, mountain: 1, water: 1 },\n\t\t\t\tfaction: 'Neutral',\n\t\t\t\tstatistics: { forest: 2, mountain: 1, water: 1 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'at-noon-effect-card',\n\t\t\t\tname: 'Sundial of Effects',\n\t\t\t\ttype: CardType.Landmark, // Or Character, depending on where \"At Noon\" can trigger\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 1 },\n\t\t\t\treserveCost: { total: 1 },\n\t\t\t\tfaction: 'Neutral',\n\t\t\t\tstatistics: { forest: 0, mountain: 0, water: 0 },\n\t\t\t\tabilities: [\n\t\t\t\t\t{\n\t\t\t\t\t\tabilityId: 'noon-abil',\n\t\t\t\t\t\ttext: 'At Noon: Gain 1 mana.',\n\t\t\t\t\t\tabilityType: 'reaction',\n\t\t\t\t\t\ttrigger: 'onNoonPhaseStart', // Assuming such a trigger\n\t\t\t\t\t\teffect: { steps: [{ type: 'gainMana', player: 'self', quantity: 1 }] }\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'gear-001',\n\t\t\t\tname: 'Test Gear',\n\t\t\t\ttype: CardType.Gear,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 1 },\n\t\t\t\treserveCost: { total: 1 },\n\t\t\t\tfaction: 'Neutral',\n\t\t\t\tstatistics: { forest: 0, mountain: 0, water: 0 }, // Gears might not have stats\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'landmark-001',\n\t\t\t\tname: 'Test Landmark',\n\t\t\t\ttype: CardType.Landmark,\n\t\t\t\tsubTypes: [],\n\t\t\t\thandCost: { total: 2 },\n\t\t\t\treserveCost: { total: 2 },\n\t\t\t\tfaction: 'Neutral',\n\t\t\t\tstatistics: { forest: 0, mountain: 0, water: 0 },\n\t\t\t\tabilities: [],\n\t\t\t\trarity: 'Common',\n\t\t\t\tversion: '1.0'\n\t\t\t}\n\t\t];\n\t\tgameStateManager = new GameStateManager(['player1', 'player2'], mockCardDefinitions, eventBus);\n\t\t// Setup default hero limits if not part of hero card def for these tests\n\t\tgameStateManager.getPlayer('player1')!.limits.reserve = 2;\n\t\tgameStateManager.getPlayer('player1')!.limits.landmarks = 2;\n\t\tgameStateManager.getPlayer('player2')!.limits.reserve = 2;\n\t\tgameStateManager.getPlayer('player2')!.limits.landmarks = 2;\n\n\t\tturnManager = new TurnManager(gameStateManager);\n\t\tphaseManager = new PhaseManager(gameStateManager, turnManager);\n\n\t\t// Initialize game state\n\t\tawait gameStateManager.initializeGame();\n\t\t// Set current player for tests that need it.\n\t\tgameStateManager.state.currentPlayerId = gameStateManager.state.firstPlayerId;\n\t});\n\n\tdescribe('Rule 4.2: Day Structure - Five Phases', () => {\n\t\ttest('Rule 4.2.a: Day should consist of exactly 5 phases in correct order', () => {\n\t\t\tconst expectedPhases = [\n\t\t\t\tGamePhase.Morning,\n\t\t\t\tGamePhase.Noon,\n\t\t\t\tGamePhase.Afternoon,\n\t\t\t\tGamePhase.Dusk,\n\t\t\t\tGamePhase.Night\n\t\t\t];\n\n\t\t\t// Test phase progression through a complete day\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Morning);\n\t\t\texpect(gameStateManager.state.currentPhase).toBe(GamePhase.Morning);\n\n\t\t\t// Should advance through each phase in order\n\t\t\tfor (let i = 0; i < expectedPhases.length - 1; i++) {\n\t\t\t\tphaseManager.advancePhase();\n\t\t\t\texpect(gameStateManager.state.currentPhase).toBe(expectedPhases[i + 1]);\n\t\t\t}\n\t\t});\n\n\t\ttest('Rule 4.2.g: Night phase should advance to next day and return to Morning', async () => {\n\t\t\tconst initialDay = gameStateManager.state.currentDay;\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Night);\n\n\t\t\tawait phaseManager.advancePhase();\n\n\t\t\texpect(gameStateManager.state.currentDay).toBe(initialDay + 1);\n\t\t\texpect(gameStateManager.state.currentPhase).toBe(GamePhase.Morning);\n\t\t});\n\t});\n\n\tdescribe('Rule 4.2.1: Morning Phase - Succeed  Prepare  Draw  Expand', () => {\n\t\ttest('Rule 4.2.1.a (Succeed): Morning phase should update firstPlayerId and currentPlayerId', async () => {\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Morning);\n\t\t\tconst p1 = 'player1';\n\t\t\tconst p2 = 'player2';\n\t\t\tgameStateManager.state.firstPlayerId = p2; // P2 starts as first player\n\t\t\tgameStateManager.state.currentPlayerId = p2;\n\n\t\t\tawait phaseManager.executeMorningPhaseSucceedStep(); // Assuming this specific sub-step method exists for testing\n\n\t\t\texpect(gameStateManager.state.firstPlayerId).toBe(p1); // Should switch to P1\n\t\t\texpect(gameStateManager.state.currentPlayerId).toBe(p1); // Current player also becomes P1\n\t\t});\n\n\t\ttest('Rule 4.2.1.c (Prepare): Morning phase readies exhausted characters, reserve cards, and mana', async () => {\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Morning);\n\t\t\tconst player1 = gameStateManager.getPlayer('player1')!;\n\n\t\t\t// Setup exhausted entities\n\t\t\tconst charInExp = gameStateManager.objectFactory.createGameObject(\n\t\t\t\tgameStateManager.objectFactory.createCard('character-001', 'player1'),\n\t\t\t\t'player1'\n\t\t\t);\n\t\t\tcharInExp.statuses.add(StatusType.Exhausted);\n\t\t\tplayer1.zones.expeditionZone.add(charInExp);\n\n\t\t\tconst cardInReserve = gameStateManager.objectFactory.createGameObject(\n\t\t\t\tgameStateManager.objectFactory.createCard('test-card', 'player1'),\n\t\t\t\t'player1'\n\t\t\t);\n\t\t\tcardInReserve.statuses.add(StatusType.Exhausted);\n\t\t\tplayer1.zones.reserveZone.add(cardInReserve);\n\n\t\t\tconst manaOrb = player1.zones.manaZone.getAll()[0]; // Assuming at least one mana orb from init\n\t\t\tif (manaOrb) manaOrb.statuses.add(StatusType.Exhausted);\n\n\t\t\tawait phaseManager.executeMorningPhasePrepareStep(); // Assuming this specific sub-step method exists\n\n\t\t\texpect(charInExp.statuses.has(StatusType.Exhausted)).toBe(false);\n\t\t\texpect(cardInReserve.statuses.has(StatusType.Exhausted)).toBe(false);\n\t\t\tif (manaOrb) expect(manaOrb.statuses.has(StatusType.Exhausted)).toBe(false);\n\t\t});\n\n\t\ttest('Rule 4.2.1.d (Draw): Morning phase executes Draw step', async () => {\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Morning);\n\t\t\tconst player1 = gameStateManager.getPlayer('player1')!;\n\t\t\tconst initialHandSize = player1.zones.handZone.count;\n\n\t\t\tawait phaseManager.executeMorningPhaseDrawStep(); // Assuming this specific sub-step method\n\n\t\t\texpect(player1.zones.handZone.count).toBe(initialHandSize + 2); // Draws 2 cards\n\t\t});\n\n\t\ttest('Rule 4.2.1.e (Expand): Morning phase allows player to expand once', async () => {\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Morning);\n\t\t\tconst player1 = gameStateManager.getPlayer('player1')!;\n\t\t\tconst cardToExpand = gameStateManager.objectFactory.createCard('test-card', 'player1');\n\t\t\tplayer1.zones.handZone.add(cardToExpand); // Add a card to hand\n\n\t\t\tconst initialManaCount = player1.zones.manaZone.count;\n\t\t\tconst initialHandCount = player1.zones.handZone.count;\n\n\t\t\t// Simulate P1 choosing to expand this card\n\t\t\t// This assumes PhaseManager has a way to signal this choice for a player.\n\t\t\t// For testing, we might directly call a method like phaseManager.playerChoseExpand(P1, cardToExpand.id);\n\t\t\t// Then executeExpandStep would process it.\n\t\t\tgameStateManager.state.playerExpandChoices = { [player1.id]: cardToExpand.instanceId }; // Simulate choice\n\t\t\tawait phaseManager.executeMorningPhaseExpandStep(); // Assuming this specific sub-step method\n\n\t\t\texpect(player1.zones.manaZone.count).toBe(initialManaCount + 1);\n\t\t\texpect(player1.zones.handZone.count).toBe(initialHandCount - 1);\n\t\t\tconst newManaOrb = player1.zones.manaZone.findById(cardToExpand.instanceId);\n\t\t\texpect(newManaOrb).toBeDefined();\n\t\t\texpect(newManaOrb?.statuses.has(StatusType.Exhausted)).toBe(false); // New mana is ready\n\t\t\texpect(player1.flags.hasExpandedThisTurn).toBe(true); // Check flag\n\t\t});\n\n\t\ttest('Rule 4.2.1.e: Expand is once-per-turn and only in Morning phase', async () => {\n\t\t\t// This test logic from original file is mostly fine, adapt to use new sub-step methods\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Morning);\n\t\t\tconst player = gameStateManager.getPlayer('player1')!;\n\t\t\tconst cardToExpand = gameStateManager.objectFactory.createCard('test-card', 'player1');\n\t\t\tplayer.zones.handZone.add(cardToExpand);\n\n\t\t\t// Simulate P1 choosing to expand\n\t\t\tgameStateManager.state.playerExpandChoices = { [player.id]: cardToExpand.instanceId };\n\t\t\tawait phaseManager.executeMorningPhaseExpandStep();\n\t\t\texpect(player.flags.hasExpandedThisTurn).toBe(true);\n\n\t\t\t// Attempt to expand again (should not be possible)\n\t\t\tplayer.flags.hasExpandedThisTurn = true; // Ensure flag is set from previous action\n\t\t\tconst canExpandAgain = phaseManager.canPlayerExpand(player.id); // Check before trying\n\t\t\texpect(canExpandAgain).toBe(false);\n\n\t\t\t// In other phases, expand should not be available\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Afternoon);\n\t\t\texpect(phaseManager.canPlayerExpand(player.id)).toBe(false);\n\t\t});\n\n\t\ttest('Rule 4.1.l: First Morning phase (Day 1) is skipped, and subsequent are not', async () => {\n\t\t\t// Reset to game start, Day 1 Morning\n\t\t\tawait gameStateManager.initializeGame(); // Re-initialize to reset day and flags\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Morning); // Set explicitly if initializeGame doesn't set to Morning\n\t\t\texpect(gameStateManager.state.currentDay).toBe(1);\n\n\t\t\tawait phaseManager.advancePhase(); // Attempt to advance from Day 1 Morning\n\n\t\t\texpect(gameStateManager.state.currentPhase).toBe(GamePhase.Noon); // Should skip to Noon\n\t\t\texpect(gameStateManager.state.flags.firstMorningSkipped).toBe(true);\n\n\t\t\t// Progress to Day 2 Morning\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Night);\n\t\t\tawait phaseManager.advancePhase(); // Night -> Morning (Day 2)\n\t\t\texpect(gameStateManager.state.currentDay).toBe(2);\n\t\t\texpect(gameStateManager.state.currentPhase).toBe(GamePhase.Morning);\n\n\t\t\t// On Day 2, Morning phase should not be skipped\n\t\t\t// To test executeMorningPhase not skipping, we'd need to check some effect of morning phase occurred.\n\t\t\t// For example, currentPlayerId should be the firstPlayerId after Succeed step.\n\t\t\tconst firstPlayerDay2 = gameStateManager.state.firstPlayerId;\n\t\t\tawait phaseManager.executeMorningPhase(); // Execute full morning\n\t\t\texpect(gameStateManager.state.currentPlayerId).toBe(firstPlayerDay2); // Succeed step ran\n\t\t\t// Or check if draw happened, etc.\n\t\t});\n\t});\n\n\tdescribe('Rule 4.2.2: Noon Phase', () => {\n\t\ttest('Rule 4.2.2: Noon phase should trigger \"At Noon\" reactions', async () => {\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Noon);\n\t\t\tconst player1 = gameStateManager.getPlayer('player1')!;\n\t\t\tconst atNoonCard = gameStateManager.objectFactory.createGameObject(\n\t\t\t\tgameStateManager.objectFactory.createCard('at-noon-effect-card', player1.id),\n\t\t\t\tplayer1.id\n\t\t\t);\n\t\t\tplayer1.zones.landmarkZone.add(atNoonCard); // Assuming it's a landmark\n\n\t\t\tconst initialMana = player1.currentMana;\n\t\t\t// Spy on eventBus or EffectExecutionManager if \"At Noon\" triggers are event-based\n\t\t\t// For now, assume executeNoonPhase directly calls or leads to effect resolution.\n\n\t\t\tawait phaseManager.executeNoonPhase();\n\n\t\t\t// The card 'at-noon-effect-card' is defined to \"Gain 1 mana\" At Noon.\n\t\t\texpect(player1.currentMana).toBe(initialMana + 1);\n\t\t});\n\n\t\ttest('Noon phase should have no daily effects (Prepare, Draw, Expand)', async () => {\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Noon);\n\t\t\tconst player1 = gameStateManager.getPlayer('player1')!;\n\n\t\t\t// Setup: Exhaust mana, note hand size\n\t\t\tplayer1.zones.manaZone.getAll().forEach((orb) => orb.statuses.add(StatusType.Exhausted));\n\t\t\tconst initialHandSize = player1.zones.handZone.count;\n\t\t\tplayer1.flags.hasExpandedThisTurn = false;\n\n\t\t\tawait phaseManager.executeNoonPhase();\n\n\t\t\t// Assertions: No Prepare, Draw, or Expand actions occurred\n\t\t\tplayer1.zones.manaZone.getAll().forEach((orb) => {\n\t\t\t\texpect(orb.statuses.has(StatusType.Exhausted)).toBe(true); // Mana remains exhausted\n\t\t\t});\n\t\t\texpect(player1.zones.handZone.count).toBe(initialHandSize); // Hand size unchanged\n\t\t\texpect(player1.flags.hasExpandedThisTurn).toBe(false); // Expand flag not set/used\n\t\t});\n\t});\n\n\tdescribe('Rule 4.2.3: Afternoon Phase - Player Turns', () => {\n\t\ttest('Rule 4.2.3.c: First player (firstPlayerId) should take the first turn', async () => {\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Afternoon);\n\t\t\t// Set P2 as first player for this test\n\t\t\tgameStateManager.state.firstPlayerId = 'player2';\n\t\t\tawait phaseManager.executeAfternoonPhase(); // This should set currentPlayerId\n\t\t\texpect(gameStateManager.state.currentPlayerId).toBe('player2');\n\t\t});\n\n\t\ttest('Playing a card ends the turn', async () => {\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Afternoon);\n\t\t\tconst p1 = gameStateManager.getPlayer('player1')!;\n\t\t\tconst p2Id = 'player2';\n\t\t\tgameStateManager.state.currentPlayerId = p1.id; // P1 is active\n\n\t\t\tconst spellCard = gameStateManager.objectFactory.createCard('test-card', p1.id);\n\t\t\tp1.zones.handZone.add(spellCard);\n\t\t\tp1.currentMana = 10; // Ensure enough mana\n\n\t\t\t// Spy or check turn manager's state if possible, for now, check currentPlayerId change\n\t\t\t// This assumes playerPlaysCardFromHand internally calls the logic to end the turn.\n\t\t\tawait gameStateManager.playerPlaysCardFromHand(p1.id, spellCard.instanceId, {\n\t\t\t\ttargetObjectIds: []\n\t\t\t});\n\n\t\t\texpect(gameStateManager.state.currentPlayerId).toBe(p2Id);\n\t\t});\n\n\t\ttest('Rule 4.2.3.e: Afternoon should end when all players pass consecutively', async () => {\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Afternoon);\n\t\t\tconst p1Id = gameStateManager.state.firstPlayerId;\n\t\t\tconst p2Id = p1Id === 'player1' ? 'player2' : 'player1';\n\n\t\t\tgameStateManager.state.currentPlayerId = p1Id;\n\t\t\tawait phaseManager.passTurn(); // P1 passes, turn goes to P2\n\t\t\texpect(gameStateManager.state.currentPlayerId).toBe(p2Id);\n\n\t\t\tawait phaseManager.passTurn(); // P2 passes\n\n\t\t\t// After both pass consecutively, phase should advance to Dusk\n\t\t\t// This relies on passTurn calling checkAfternoonEnd, which calls advancePhase.\n\t\t\texpect(gameStateManager.state.currentPhase).toBe(GamePhase.Dusk);\n\t\t});\n\t});\n\n\tdescribe('Rule 4.2.4: Dusk Phase - Progress Calculation', () => {\n\t\t// Helper to set expedition stats for testing\n\t\tconst setExpeditionStats = (playerId: string, heroStats: any, companionStats?: any) => {\n\t\t\tconst player = gameStateManager.getPlayer(playerId)!;\n\t\t\tplayer.expeditionState.heroStats = heroStats;\n\t\t\tplayer.expeditionState.heroPosition = 0; // Reset position for each test\n\t\t\tif (companionStats) {\n\t\t\t\tplayer.expeditionState.companionStats = companionStats;\n\t\t\t\tplayer.expeditionState.companionPosition = 0;\n\t\t\t}\n\t\t};\n\n\t\ttest('Rule 4.2.4.b/e: Expedition moves if stats > opponent AND > 0', async () => {\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Dusk);\n\t\t\tsetExpeditionStats('player1', { forest: 3, mountain: 0, water: 0 });\n\t\t\tsetExpeditionStats('player2', { forest: 2, mountain: 0, water: 0 });\n\t\t\tawait phaseManager.executeDuskPhaseProgressStep();\n\t\t\texpect(gameStateManager.getPlayer('player1')!.expeditionState.heroPosition).toBe(1);\n\t\t\texpect(gameStateManager.getPlayer('player2')!.expeditionState.heroPosition).toBe(0);\n\n\t\t\tsetExpeditionStats('player1', { forest: 1, mountain: 0, water: 0 });\n\t\t\tsetExpeditionStats('player2', { forest: 0, mountain: -1, water: 0 }); // P2 has non-positive relevant stat\n\t\t\tawait phaseManager.executeDuskPhaseProgressStep();\n\t\t\texpect(gameStateManager.getPlayer('player1')!.expeditionState.heroPosition).toBe(1);\n\t\t\texpect(gameStateManager.getPlayer('player2')!.expeditionState.heroPosition).toBe(0);\n\n\t\t\tsetExpeditionStats('player1', { forest: 0, mountain: 0, water: 0 }); // P1 has zero stat\n\t\t\tsetExpeditionStats('player2', { forest: -1, mountain: -1, water: -1 });\n\t\t\tawait phaseManager.executeDuskPhaseProgressStep();\n\t\t\texpect(gameStateManager.getPlayer('player1')!.expeditionState.heroPosition).toBe(0);\n\t\t});\n\n\t\ttest('Rule 4.2.4.e: Ties (or P1 stat not strictly greater) should not allow movement', async () => {\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Dusk);\n\t\t\tsetExpeditionStats('player1', { forest: 2, mountain: 0, water: 0 });\n\t\t\tsetExpeditionStats('player2', { forest: 2, mountain: 0, water: 0 }); // Tie\n\t\t\tawait phaseManager.executeDuskPhaseProgressStep();\n\t\t\texpect(gameStateManager.getPlayer('player1')!.expeditionState.heroPosition).toBe(0);\n\t\t\texpect(gameStateManager.getPlayer('player2')!.expeditionState.heroPosition).toBe(0);\n\n\t\t\tsetExpeditionStats('player1', { forest: 2, mountain: 0, water: 0 });\n\t\t\tsetExpeditionStats('player2', { forest: 3, mountain: 0, water: 0 }); // P1 loses\n\t\t\tawait phaseManager.executeDuskPhaseProgressStep();\n\t\t\texpect(gameStateManager.getPlayer('player1')!.expeditionState.heroPosition).toBe(0);\n\t\t\t// P2 would move if their stats are also >0, but this test focuses on P1 not moving.\n\t\t});\n\n\t\ttest('Rule 4.2.4.h: All successful expeditions move simultaneously (conceptual)', async () => {\n\t\t\t// This rule is hard to test directly without deep diving into how simultaneous resolution is architected.\n\t\t\t// We test that if both P1 hero and P1 companion win their respective matchups, both move.\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Dusk);\n\t\t\tsetExpeditionStats(\n\t\t\t\t'player1',\n\t\t\t\t{ forest: 3, mountain: 0, water: 0 }, // Hero\n\t\t\t\t{ forest: 3, mountain: 0, water: 0 } // Companion\n\t\t\t);\n\t\t\tsetExpeditionStats(\n\t\t\t\t'player2',\n\t\t\t\t{ forest: 1, mountain: 0, water: 0 }, // Hero\n\t\t\t\t{ forest: 1, mountain: 0, water: 0 } // Companion\n\t\t\t);\n\n\t\t\tawait phaseManager.executeDuskPhaseProgressStep();\n\n\t\t\texpect(gameStateManager.getPlayer('player1')!.expeditionState.heroPosition).toBe(1);\n\t\t\texpect(gameStateManager.getPlayer('player1')!.expeditionState.companionPosition).toBe(1);\n\t\t\texpect(gameStateManager.getPlayer('player2')!.expeditionState.heroPosition).toBe(0);\n\t\t\texpect(gameStateManager.getPlayer('player2')!.expeditionState.companionPosition).toBe(0);\n\t\t});\n\t});\n\n\tdescribe('Rule 4.2.5: Night Phase - Rest  Clean-up  Victory Check', () => {\n\t\ttest('Rule 4.2.5.b (Rest): Characters/Gears in MOVED expeditions go to Reserve; others stay', async () => {\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Night);\n\t\t\tconst p1 = gameStateManager.getPlayer('player1')!;\n\n\t\t\tconst charMovedExp = gameStateManager.objectFactory.createGameObject(\n\t\t\t\tgameStateManager.objectFactory.createCard('character-001', p1.id),\n\t\t\t\tp1.id\n\t\t\t);\n\t\t\tconst gearMovedExp = gameStateManager.objectFactory.createGameObject(\n\t\t\t\tgameStateManager.objectFactory.createCard('gear-001', p1.id),\n\t\t\t\tp1.id\n\t\t\t);\n\t\t\tp1.zones.expeditionZone.add(charMovedExp);\n\t\t\tp1.zones.expeditionZone.add(gearMovedExp);\n\t\t\t// Associate them with hero expedition for this test, and mark hero expedition as moved\n\t\t\tp1.expeditionState.heroExpeditionObjects = [charMovedExp.objectId, gearMovedExp.objectId];\n\t\t\tp1.expeditionState.heroMovedThisTurn = true;\n\n\t\t\tconst charStayExp = gameStateManager.objectFactory.createGameObject(\n\t\t\t\tgameStateManager.objectFactory.createCard('character-001', p1.id),\n\t\t\t\tp1.id\n\t\t\t);\n\t\t\tcharStayExp.instanceId = 'charStay'; // ensure unique id\n\t\t\tp1.zones.expeditionZone.add(charStayExp);\n\t\t\tp1.expeditionState.companionExpeditionObjects = [charStayExp.objectId];\n\t\t\tp1.expeditionState.companionMovedThisTurn = false; // Companion expedition did not move\n\n\t\t\tawait phaseManager.executeNightPhaseRestStep();\n\n\t\t\texpect(p1.zones.reserveZone.findById(charMovedExp.objectId)).toBeDefined();\n\t\t\texpect(p1.zones.reserveZone.findById(gearMovedExp.objectId)).toBeDefined();\n\t\t\texpect(p1.zones.expeditionZone.findById(charStayExp.objectId)).toBeDefined(); // Stays\n\t\t});\n\n\t\ttest('Rule 4.2.5.c (Clean-up): Discard/Sacrifice excess Reserve/Landmark cards', async () => {\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Night);\n\t\t\tconst p1 = gameStateManager.getPlayer('player1')!;\n\t\t\tp1.limits.reserve = 1; // Lower limit for testing\n\t\t\tp1.limits.landmarks = 1;\n\n\t\t\t// Add 2 cards to Reserve\n\t\t\tp1.zones.reserveZone.add(gameStateManager.objectFactory.createCard('character-001', p1.id));\n\t\t\tp1.zones.reserveZone.add(gameStateManager.objectFactory.createCard('test-card', p1.id));\n\t\t\t// Add 2 Landmarks\n\t\t\tp1.zones.landmarkZone.add(\n\t\t\t\tgameStateManager.objectFactory.createGameObject(\n\t\t\t\t\tgameStateManager.objectFactory.createCard('landmark-001', p1.id),\n\t\t\t\t\tp1.id\n\t\t\t\t)\n\t\t\t);\n\t\t\tp1.zones.landmarkZone.add(\n\t\t\t\tgameStateManager.objectFactory.createGameObject(\n\t\t\t\t\tgameStateManager.objectFactory.createCard('landmark-001', p1.id),\n\t\t\t\t\tp1.id\n\t\t\t\t)\n\t\t\t);\n\n\t\t\texpect(p1.zones.reserveZone.count).toBe(2);\n\t\t\texpect(p1.zones.landmarkZone.count).toBe(2);\n\n\t\t\t// This assumes player choice is handled or defaults (e.g., discards oldest/newest)\n\t\t\t// Or that PhaseManager triggers a choice request that would be mocked in a more complex setup.\n\t\t\tawait phaseManager.executeNightPhaseCleanupStep();\n\n\t\t\texpect(p1.zones.reserveZone.count).toBe(1);\n\t\t\texpect(p1.zones.landmarkZone.count).toBe(1);\n\t\t\texpect(p1.zones.discardPileZone.count).toBeGreaterThanOrEqual(1); // At least one reserve card discarded\n\t\t\t// Plus one landmark sacrificed (also goes to discard)\n\t\t});\n\n\t\ttest('Rule 1.3.3.c (Victory Check): Tie in distance leads to Tiebreaker mode', async () => {\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Night);\n\t\t\tconst p1 = gameStateManager.getPlayer('player1')!;\n\t\t\tconst p2 = gameStateManager.getPlayer('player2')!;\n\n\t\t\tp1.expeditionState.heroPosition = 3;\n\t\t\tp1.expeditionState.companionPosition = 4; // P1 Total = 7\n\t\t\tp2.expeditionState.heroPosition = 4;\n\t\t\tp2.expeditionState.companionPosition = 3; // P2 Total = 7\n\n\t\t\tawait phaseManager.executeNightPhaseVictoryCheckStep();\n\n\t\t\texpect(gameStateManager.state.gameEnded).toBe(false); // Game not ended yet\n\t\t\texpect(gameStateManager.state.winner).toBeUndefined();\n\t\t\texpect(gameStateManager.state.flags.tiebreakerMode).toBe(true); // Tiebreaker mode activated\n\t\t});\n\t});\n\n\tdescribe('Reaction Checking - Rule 4.4', () => {\n\t\t// Rule 4.4 is about the system for offering players the chance to act with reactions.\n\t\t// Testing the full reaction system (which card reactions trigger, how choices are presented/resolved)\n\t\t// is likely beyond *just* PhaseManager tests. PhaseManager's role is likely to initiate\n\t\t// the reaction window at the correct times (e.g., after phase change, after an action).\n\n\t\ttest('Rule 4.4.a: Advancing phase should conceptually open a reaction window', async () => {\n\t\t\t// This test is more about the *concept* that a reaction check step is part of advancing.\n\t\t\t// Actual reaction processing would be handled by a ReactionManager or similar,\n\t\t\t// potentially by PhaseManager calling it.\n\t\t\t// We can check if the turn ownership or priority is correctly set for reactions.\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Morning);\n\t\t\tconst initialPlayer = gameStateManager.state.currentPlayerId;\n\n\t\t\t// After advancing from Morning to Noon, a reaction window should occur.\n\t\t\t// The first player (usually currentPlayerId at the start of the new phase) gets priority.\n\t\t\tawait phaseManager.advancePhase(); // Advances to Noon\n\t\t\texpect(gameStateManager.state.currentPhase).toBe(GamePhase.Noon);\n\n\t\t\t// PhaseManager might set a flag or state indicating a reaction window is open,\n\t\t\t// and currentTurnPlayerId would still be the player who has priority.\n\t\t\t// For example, if P1 was firstPlayerId and currentPlayerId in Morning, they'd also be after Succeed step.\n\t\t\t// If firstPlayerId changed in Morning's Succeed step, that new firstPlayer gets priority.\n\t\t\texpect(gameStateManager.state.currentPlayerId).toBe(gameStateManager.state.firstPlayerId);\n\t\t\t// A more specific assertion would require knowledge of how ReactionManager is invoked.\n\t\t\t// For now, ensuring the currentPlayerId is the one expected to react first is a good proxy.\n\t\t});\n\n\t\ttest('Rule 4.4.b: First player should have priority in reaction windows following phase changes', async () => {\n\t\t\t// Setup: P2 is the first player.\n\t\t\tgameStateManager.state.firstPlayerId = 'player2';\n\t\t\tgameStateManager.state.currentPlayerId = 'player2'; // Current player is P2\n\t\t\tgameStateManager.setCurrentPhase(GamePhase.Morning); // Start of a phase where P2 is active.\n\n\t\t\t// PhaseManager.checkReactions() or a similar method would be called.\n\t\t\t// This method should ensure that 'player2' (the firstPlayerId) gets the first chance to react.\n\t\t\t// This might involve setting some state in gameStateManager like 'reactionPlayerId' or 'priorityPlayerId'.\n\t\t\t// For now, we'll assume that after a phase change, currentPlayerId reflects who has priority.\n\n\t\t\tawait phaseManager.executeMorningPhaseSucceedStep(); // P1 becomes firstPlayer and currentPlayer\n\t\t\texpect(gameStateManager.state.firstPlayerId).toBe('player1');\n\t\t\texpect(gameStateManager.state.currentPlayerId).toBe('player1');\n\n\t\t\t// If phaseManager.checkReactions() was called (implicitly or explicitly after a step/phase change),\n\t\t\t// it should respect that 'player1' now has priority.\n\t\t\t// This is difficult to assert without more details on ReactionManager interaction.\n\t\t\t// The previous test covers that currentPlayerId (who would act first) is correctly set.\n\t\t\t// This test essentially re-affirms that the currentPlayerId is the one with priority.\n\t\t\t// No direct action for checkReactions() separate from phase transitions for this test.\n\t\t\t// The assertion is that the game state (currentPlayerId) is correctly set for P1 to act.\n\t\t\texpect(gameStateManager.state.currentPlayerId).toBe('player1');\n\t\t});\n\t});\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/StatusRules.test.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'GamePhase' is defined but never used.",
				"line": 6,
				"column": 2,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 6,
				"endColumn": 11
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 153,
				"column": 3,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 153,
				"endColumn": 21,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [4118, 4119], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 154,
				"column": 3,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 154,
				"endColumn": 21,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [4157, 4158], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 162,
				"column": 18,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 162,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 178,
				"column": 29,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 178,
				"endColumn": 59,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [5223, 5224], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 179,
				"column": 31,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 179,
				"endColumn": 61,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [5320, 5321], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 180,
				"column": 28,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 180,
				"endColumn": 58,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [5389, 5390], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 185,
				"column": 18,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 185,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 237,
				"column": 18,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 237,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 268,
				"column": 18,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 268,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 281,
				"column": 29,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 281,
				"endColumn": 59,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10057, 10058], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 289,
				"column": 29,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 289,
				"endColumn": 67
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 289,
				"column": 29,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 289,
				"endColumn": 59,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10412, 10413], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 298,
				"column": 29,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 298,
				"endColumn": 59,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10894, 10895], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 305,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 305,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 308,
				"column": 25,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 308,
				"endColumn": 56,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [11438, 11439], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 333,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 333,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 336,
				"column": 25,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 336,
				"endColumn": 56,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [12897, 12898], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 377,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 377,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 380,
				"column": 25,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 380,
				"endColumn": 56,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [15717, 15718], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 397,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 397,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 415,
				"column": 5,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 415,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [17167, 17168], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 425,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 425,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 455,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 455,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 476,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 476,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 484,
				"column": 25,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 484,
				"endColumn": 56,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [20544, 20545], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 505,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 505,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 521,
				"column": 5,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 521,
				"endColumn": 20,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [22134, 22135], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 534,
				"column": 19,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 534,
				"endColumn": 37
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 28,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, test, expect, beforeEach } from 'bun:test';\nimport { GameStateManager } from '../../src/engine/GameStateManager';\nimport { EventBus } from '../../src/engine/EventBus';\nimport {\n\tCardType,\n\tGamePhase,\n\tStatusType,\n\tZoneIdentifier,\n\tKeywordAbility,\n\tCounterType\n} from '../../src/engine/types/enums';\nimport type { ICardDefinition } from '../../src/engine/types/cards';\nimport type { IGameObject } from '../../src/engine/types/objects';\nimport { isGameObject } from '../../src/engine/types/objects';\n\ndescribe('GameStateManager - Status Rule Compliance (Rule 2.4)', () => {\n\tlet gsm: GameStateManager;\n\tlet eventBus: EventBus;\n\tlet P1 = 'player1';\n\tlet P2 = 'player2';\n\n\tconst cardDef_AsleepAnchoredChar: ICardDefinition = {\n\t\tid: 'char-asleep-anchored',\n\t\tname: 'Sleepy Rock',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: { total: 1 },\n\t\treserveCost: { total: 1 },\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 1, mountain: 1, water: 1 },\n\t\tabilities: [], // No passive abilities that grant these statuses\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_NormalChar: ICardDefinition = {\n\t\tid: 'char-normal',\n\t\tname: 'Normal Guy',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: { total: 1 },\n\t\treserveCost: { total: 1 },\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 2, mountain: 2, water: 2 },\n\t\tabilities: [],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_FleetingChar: ICardDefinition = {\n\t\tid: 'char-fleeting',\n\t\tname: 'Fleeting Fellow',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: { total: 1 },\n\t\treserveCost: { total: 1 },\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 1, mountain: 1, water: 1 },\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tdescription: 'Fleeting (passive for test)',\n\t\t\t\ttype: 'passive',\n\t\t\t\tkeyword: KeywordAbility.Fleeting\n\t\t\t}\n\t\t], // Note: This is a conceptual passive. Real Fleeting is applied differently.\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_FleetingSpell: ICardDefinition = {\n\t\tid: 'spell-fleeting',\n\t\tname: 'Fleeting Chant',\n\t\ttype: CardType.Spell,\n\t\tsubTypes: [],\n\t\thandCost: { total: 1 },\n\t\tfaction: 'Neutral',\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-fleeting-passive-spell',\n\t\t\t\ttext: 'This spell is Fleeting.',\n\t\t\t\tabilityType: 'passive',\n\t\t\t\tkeyword: KeywordAbility.Fleeting, // This implies the card instance itself should become Fleeting\n\t\t\t\teffect: { steps: [] },\n\t\t\t\tisSupportAbility: false\n\t\t\t}\n\t\t],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_CharWithTapAbility: ICardDefinition = {\n\t\tid: 'char-tap-ability',\n\t\tname: 'Resourceful Tapper',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: { total: 1 },\n\t\treserveCost: { total: 1 },\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 1, mountain: 1, water: 1 },\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-tap-draw',\n\t\t\t\ttext: 'T: Draw a card.',\n\t\t\t\tabilityType: 'activated',\n\t\t\t\tcost: [{ type: 'exhaustSelf' }],\n\t\t\t\teffect: { steps: [{ type: 'drawCard', player: 'self', quantity: 1 }] },\n\t\t\t\tisSupportAbility: false\n\t\t\t}\n\t\t],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tconst cardDef_CharWithSupportAbility: ICardDefinition = {\n\t\tid: 'char-support-ability',\n\t\tname: 'Helpful Friend',\n\t\ttype: CardType.Character,\n\t\tsubTypes: [],\n\t\thandCost: { total: 1 },\n\t\treserveCost: { total: 1 },\n\t\tfaction: 'Neutral',\n\t\tstatistics: { forest: 1, mountain: 1, water: 1 },\n\t\tabilities: [\n\t\t\t{\n\t\t\t\tabilityId: 'abil-support-draw',\n\t\t\t\ttext: 'D: You may draw a card.',\n\t\t\t\tabilityType: 'support',\n\t\t\t\ttrigger: 'onDemand', // Assuming 'onDemand' or similar for 'D' abilities\n\t\t\t\teffect: { steps: [{ type: 'drawCard', player: 'self', quantity: 1, isOptional: true }] },\n\t\t\t\tisSupportAbility: true\n\t\t\t}\n\t\t],\n\t\trarity: 'Common',\n\t\tversion: '1.0'\n\t};\n\n\tbeforeEach(async () => {\n\t\teventBus = new EventBus();\n\t\tgsm = new GameStateManager(\n\t\t\t[P1, P2],\n\t\t\t[\n\t\t\t\tcardDef_AsleepAnchoredChar,\n\t\t\t\tcardDef_NormalChar,\n\t\t\t\tcardDef_FleetingChar,\n\t\t\t\tcardDef_FleetingSpell,\n\t\t\t\tcardDef_CharWithTapAbility,\n\t\t\t\tcardDef_CharWithSupportAbility\n\t\t\t],\n\t\t\teventBus\n\t\t);\n\t\tawait gsm.initializeGame(); // Basic setup\n\t\t// Ensure players start with some mana for tests\n\t\tgsm.getPlayer(P1)!.currentMana = 10;\n\t\tgsm.getPlayer(P2)!.currentMana = 10;\n\n\t\t// Ensure players have their expedition zones set up in gsm.state.players.get(P1).zones.expeditionZone\n\t\t// initializeGame should handle this, but good to be aware.\n\t});\n\n\t// Rule 2.4.3.a: Asleep Character's statistics are not counted in their expedition's statistics during Progress.\n\ttest('Rule 2.4.3.a: Asleep character stats are not counted during Progress', async () => {\n\t\tconst player = gsm.getPlayer(P1)!;\n\t\tconst sleepyChar = gsm.objectFactory.createGameObject(\n\t\t\tgsm.objectFactory.createCardInstance(cardDef_AsleepAnchoredChar.id, P1),\n\t\t\tP1\n\t\t);\n\t\tsleepyChar.statuses.add(StatusType.Asleep);\n\t\tplayer.zones.expeditionZone.add(sleepyChar);\n\n\t\tconst normalChar = gsm.objectFactory.createGameObject(\n\t\t\tgsm.objectFactory.createCardInstance(cardDef_NormalChar.id, P1),\n\t\t\tP1\n\t\t);\n\t\tplayer.zones.expeditionZone.add(normalChar);\n\n\t\t// Manually trigger stat calculation for P1's hero expedition (assuming it's one of them)\n\t\tconst stats = gsm.calculateExpeditionStats(P1, 'hero');\n\t\texpect(stats.forest).toBe(cardDef_NormalChar.statistics!.forest); // Only normalChar's stats\n\t\texpect(stats.mountain).toBe(cardDef_NormalChar.statistics!.mountain);\n\t\texpect(stats.water).toBe(cardDef_NormalChar.statistics!.water);\n\t});\n\n\t// Rule 2.4.3.b & 2.4.2.b: During Rest, Asleep/Anchored Characters are not sent to Reserve and lose Asleep/Anchored.\n\ttest('Rule 2.4.3.b / 2.4.2.b: Asleep/Anchored characters are not sent to Reserve and lose status during Rest', async () => {\n\t\tconst player = gsm.getPlayer(P1)!;\n\t\tconst expeditionZone = player.zones.expeditionZone;\n\t\tconst reserveZone = player.zones.reserveZone;\n\n\t\tconst sleepyChar = gsm.objectFactory.createGameObject(\n\t\t\tgsm.objectFactory.createCardInstance(cardDef_AsleepAnchoredChar.id, P1),\n\t\t\tP1\n\t\t);\n\t\tsleepyChar.statuses.add(StatusType.Asleep);\n\t\texpeditionZone.add(sleepyChar);\n\t\tconst sleepyCharId = sleepyChar.objectId;\n\n\t\tconst anchoredChar = gsm.objectFactory.createGameObject(\n\t\t\tgsm.objectFactory.createCardInstance(cardDef_AsleepAnchoredChar.id, P1),\n\t\t\tP1 // Use same def for simplicity\n\t\t);\n\t\tanchoredChar.instanceId = 'anchoredCharInst'; // different instance\n\t\tanchoredChar.statuses.add(StatusType.Anchored);\n\t\texpeditionZone.add(anchoredChar);\n\t\tconst anchoredCharId = anchoredChar.objectId;\n\n\t\tconst normalChar = gsm.objectFactory.createGameObject(\n\t\t\tgsm.objectFactory.createCardInstance(cardDef_NormalChar.id, P1),\n\t\t\tP1\n\t\t);\n\t\texpeditionZone.add(normalChar);\n\t\tconst normalCharId = normalChar.objectId;\n\n\t\t// Simulate that the player's expeditions moved forward to trigger Rest actions\n\t\tplayer.heroExpedition.hasMoved = true;\n\t\tplayer.companionExpedition.hasMoved = true;\n\n\t\tawait gsm.restPhase();\n\n\t\texpect(expeditionZone.findById(sleepyCharId)).toBeDefined(); // Stays in expedition\n\t\texpect(reserveZone.findById(sleepyCharId)).toBeUndefined();\n\t\texpect(gsm.getObject(sleepyCharId)?.statuses.has(StatusType.Asleep)).toBe(false); // Loses Asleep\n\n\t\texpect(expeditionZone.findById(anchoredCharId)).toBeDefined(); // Stays in expedition\n\t\texpect(reserveZone.findById(anchoredCharId)).toBeUndefined();\n\t\texpect(gsm.getObject(anchoredCharId)?.statuses.has(StatusType.Anchored)).toBe(false); // Loses Anchored\n\n\t\texpect(expeditionZone.findById(normalCharId)).toBeUndefined(); // Normal char goes to reserve\n\t\t// Find by definitionId as objectId changes on move\n\t\tconst normalCharInReserve = reserveZone\n\t\t\t.getAll()\n\t\t\t.find((o) => isGameObject(o) && o.definitionId === cardDef_NormalChar.id);\n\t\texpect(normalCharInReserve).toBeDefined();\n\t});\n\n\t// Rule 2.4.6.d: If a Fleeting Character or Expedition Permanent would go to the Reserve from the Expedition zone, it is discarded instead.\n\ttest('Rule 2.4.6.d: Fleeting character is discarded instead of going to Reserve during Rest', async () => {\n\t\tconst player = gsm.getPlayer(P1)!;\n\t\tconst expeditionZone = player.zones.expeditionZone;\n\t\tconst reserveZone = player.zones.reserveZone;\n\t\tconst discardPile = player.zones.discardPileZone;\n\n\t\tconst fleetingChar = gsm.objectFactory.createGameObject(\n\t\t\tgsm.objectFactory.createCardInstance(cardDef_FleetingChar.id, P1),\n\t\t\tP1\n\t\t);\n\t\t// Fleeting is typically applied on play from reserve. Here, we simulate it being active.\n\t\t// The StatusEffectHandler or game logic should correctly apply Fleeting.\n\t\t// For this test, we'll manually add it.\n\t\tfleetingChar.statuses.add(StatusType.Fleeting);\n\t\texpeditionZone.add(fleetingChar);\n\t\tconst fleetingCharId = fleetingChar.objectId;\n\n\t\tplayer.heroExpedition.hasMoved = true; // Simulate expedition moved\n\n\t\tawait gsm.restPhase();\n\n\t\texpect(expeditionZone.findById(fleetingCharId)).toBeUndefined();\n\t\texpect(reserveZone.findById(fleetingCharId)).toBeUndefined();\n\t\t// Find by definitionId as objectId changes on move\n\t\tconst fleetingCharInDiscard = discardPile\n\t\t\t.getAll()\n\t\t\t.find((o) => isGameObject(o) && o.definitionId === cardDef_FleetingChar.id);\n\t\texpect(fleetingCharInDiscard).toBeDefined(); // Should be in discard\n\t});\n\n\t// Rule 2.4.4.b: Boosted status (derived from boost counters)\n\ttest('Rule 2.4.4.b: Boosted status is present if boost counters > 0, affects stats', async () => {\n\t\tconst player = gsm.getPlayer(P1)!;\n\t\tconst normalCharObj = gsm.objectFactory.createGameObject(\n\t\t\tgsm.objectFactory.createCardInstance(cardDef_NormalChar.id, P1),\n\t\t\tP1\n\t\t);\n\t\tplayer.zones.expeditionZone.add(normalCharObj);\n\n\t\t// Initial state: no boost counters, no Boosted status\n\t\t// Explicitly call status update after adding to zone to ensure initial state is clean\n\t\tawait gsm.statusUpdater.updateObjectStatusBasedOnCounters(normalCharObj); // Hypothetical method\n\t\texpect(normalCharObj.counters.get(CounterType.Boost) || 0).toBe(0);\n\t\texpect(normalCharObj.statuses.has(StatusType.Boosted)).toBe(false);\n\t\tlet stats = gsm.calculateExpeditionStats(P1, 'hero'); // Assumes normalCharObj is part of hero expedition\n\t\texpect(stats.forest).toBe(cardDef_NormalChar.statistics!.forest);\n\n\t\t// Add a boost counter\n\t\tnormalCharObj.counters.set(CounterType.Boost, 1);\n\t\t// System should update status based on counter change\n\t\tawait gsm.statusUpdater.updateObjectStatusBasedOnCounters(normalCharObj); // Hypothetical method\n\n\t\tstats = gsm.calculateExpeditionStats(P1, 'hero');\n\t\texpect(stats.forest).toBe(cardDef_NormalChar.statistics!.forest! + 1); // Stats reflect boost\n\t\texpect(normalCharObj.statuses.has(StatusType.Boosted)).toBe(true); // Boosted status is present\n\n\t\t// Remove boost counter\n\t\tnormalCharObj.counters.set(CounterType.Boost, 0);\n\t\t// System should update status based on counter change\n\t\tawait gsm.statusUpdater.updateObjectStatusBasedOnCounters(normalCharObj); // Hypothetical method\n\n\t\tstats = gsm.calculateExpeditionStats(P1, 'hero');\n\t\texpect(stats.forest).toBe(cardDef_NormalChar.statistics!.forest); // Stats back to normal\n\t\texpect(normalCharObj.statuses.has(StatusType.Boosted)).toBe(false); // Boosted status is removed\n\t});\n\n\t// --- Tests for Gaining Statuses ---\n\tdescribe('Gaining Statuses', () => {\n\t\ttest('Rule 2.4.6.a: Character played from Reserve gains Fleeting', async () => {\n\t\t\tconst player = gsm.getPlayer(P1)!;\n\t\t\tconst cardInst = gsm.objectFactory.createCardInstance(cardDef_NormalChar.id, P1);\n\t\t\tplayer.zones.reserveZone.add(cardInst); // Add to reserve first\n\t\t\tplayer.currentMana = cardDef_NormalChar.reserveCost!.total;\n\n\t\t\t// Action: Player plays the card from Reserve\n\t\t\t// Assuming a method like playerPlaysCardFromReserve exists or is part of playerPlaysCardFromHand logic\n\t\t\tconst playResult = await gsm.playerPlaysCardFromHand(P1, cardInst.instanceId, {\n\t\t\t\tfromZone: ZoneIdentifier.Reserve\n\t\t\t});\n\t\t\texpect(playResult.success).toBe(true);\n\n\t\t\tconst charInExpedition = gsm.findCardInAnyZone(\n\t\t\t\tcardInst.instanceId,\n\t\t\t\tZoneIdentifier.Expedition\n\t\t\t) as IGameObject;\n\t\t\texpect(charInExpedition).toBeDefined();\n\n\t\t\t// Assertion: The character in the expedition zone should have StatusType.Fleeting\n\t\t\t// This relies on the game engine correctly applying Fleeting when a card is played from Reserve.\n\t\t\t// Rule 2.4.6.a: \"When a Character or Expedition Permanent is played from a Reserve zone, it gains Fleeting.\"\n\t\t\t// This might be applied by the CardPlaySystem or a similar handler.\n\t\t\t// For testing, we check the status after it has entered play.\n\t\t\t// If a specific \"gainFleetingFromReservePlay\" event/handler is expected, this test verifies its outcome.\n\t\t\texpect(charInExpedition.statuses.has(StatusType.Fleeting)).toBe(true);\n\t\t});\n\n\t\ttest('Rule 2.4.6.b: Spell with passive Fleeting ability is Fleeting when played', async () => {\n\t\t\tconst player = gsm.getPlayer(P1)!;\n\t\t\tconst spellCardInst = gsm.objectFactory.createCardInstance(cardDef_FleetingSpell.id, P1);\n\t\t\tplayer.zones.hand.add(spellCardInst);\n\t\t\tplayer.currentMana = cardDef_FleetingSpell.handCost!.total;\n\n\t\t\t// Action: P1 plays the spell.\n\t\t\t// The spell itself (cardDef_FleetingSpell) has a passive Fleeting keyword.\n\t\t\t// This implies the spell instance should become Fleeting.\n\t\t\tconst playResult = await gsm.playerPlaysCardFromHand(P1, spellCardInst.instanceId, {\n\t\t\t\ttargetObjectIds: []\n\t\t\t}); // Assuming no target needed or handled by effect\n\t\t\texpect(playResult.success).toBe(true); // Spell play itself is successful\n\n\t\t\t// The spell, being Fleeting, should go to discard instead of limbo/resolve and then discard normally.\n\t\t\t// Rule 2.4.6.e: \"If a Fleeting Spell card would go to Limbo, it is discarded instead.\"\n\t\t\t// We need to check if it ended up in the discard pile.\n\t\t\tconst spellInDiscard = player.zones.discardPileZone.findById(spellCardInst.instanceId);\n\t\t\texpect(spellInDiscard).toBeDefined();\n\t\t\t// And it should have had the Fleeting status that caused this.\n\t\t\t// This is hard to check on the instance if it's immediately moved.\n\t\t\t// We infer it was Fleeting because it went to discard directly.\n\t\t\t// If possible to inspect the object *during* its transition or if status is retained on the instance:\n\t\t\t// expect(spellInDiscard.statuses.has(StatusType.Fleeting)).toBe(true);\n\t\t\t// This part of the assertion might be tricky depending on engine implementation.\n\t\t\t// For now, its presence in discard due to Fleeting property is the key.\n\t\t\t// The passive ability on cardDef_FleetingSpell should make the instance Fleeting.\n\t\t\t// Let's assume the object in discard pile retains its statuses from when it was active/in limbo.\n\t\t\tif (spellInDiscard) {\n\t\t\t\t// We need to ensure the status was applied by the passive ability.\n\t\t\t\t// This might require a step where passive abilities apply to spells as they become objects.\n\t\t\t\t// For now, let's check if the definition implies it should be fleeting.\n\t\t\t\tconst spellDef = gsm.cardDataRepository.getCardDefinition(spellInDiscard.definitionId);\n\t\t\t\tconst hasPassiveFleeting = spellDef?.abilities.some(\n\t\t\t\t\t(a) => a.keyword === KeywordAbility.Fleeting && a.abilityType === 'passive'\n\t\t\t\t);\n\t\t\t\texpect(hasPassiveFleeting).toBe(true);\n\t\t\t\t// And ideally, the instance itself would have gained the status:\n\t\t\t\t// This depends on whether the engine applies statuses to spell instances from their passives before checking Fleeting for Limbo.\n\t\t\t\t// expect(spellInDiscard.statuses.has(StatusType.Fleeting)).toBe(true);\n\t\t\t}\n\t\t});\n\n\t\ttest('Rule 2.4.6.c: Character that became Fleeting (e.g. from Reserve) retains Fleeting in expedition', async () => {\n\t\t\t// This is essentially the same as 2.4.6.a's assertion but confirms retention.\n\t\t\tconst player = gsm.getPlayer(P1)!;\n\t\t\tconst cardInst = gsm.objectFactory.createCardInstance(cardDef_NormalChar.id, P1);\n\t\t\tplayer.zones.reserveZone.add(cardInst);\n\t\t\tplayer.currentMana = cardDef_NormalChar.reserveCost!.total;\n\n\t\t\tconst playResult = await gsm.playerPlaysCardFromHand(P1, cardInst.instanceId, {\n\t\t\t\tfromZone: ZoneIdentifier.Reserve\n\t\t\t});\n\t\t\texpect(playResult.success).toBe(true);\n\n\t\t\tconst charInExpedition = gsm.findCardInAnyZone(\n\t\t\t\tcardInst.instanceId,\n\t\t\t\tZoneIdentifier.Expedition\n\t\t\t) as IGameObject;\n\t\t\texpect(charInExpedition).toBeDefined();\n\t\t\t// Fleeting should have been gained when played from reserve and should persist on entering expedition.\n\t\t\texpect(charInExpedition.statuses.has(StatusType.Fleeting)).toBe(true);\n\t\t});\n\n\t\ttest('Rule 2.4.5.a (T-cost): Character becomes Exhausted after paying a T (Exhaust me) cost', async () => {\n\t\t\tconst player = gsm.getPlayer(P1)!;\n\t\t\tconst charInst = gsm.objectFactory.createCardInstance(cardDef_CharWithTapAbility.id, P1);\n\t\t\tconst charObject = gsm.objectFactory.createGameObject(charInst, P1);\n\t\t\tplayer.zones.expeditionZone.add(charObject);\n\t\t\tgsm.ruleAdjudicator.applyAllPassiveAbilities(); // Apply any initial passives\n\n\t\t\texpect(charObject.statuses.has(StatusType.Exhausted)).toBe(false); // Starts ready\n\n\t\t\t// Action: P1 activates the 'T' ability.\n\t\t\t// Assuming an activateAbility method that handles costs.\n\t\t\tconst abilityToActivate = charObject.definition.abilities.find(\n\t\t\t\t(a) => a.abilityId === 'abil-tap-draw'\n\t\t\t);\n\t\t\texpect(abilityToActivate).toBeDefined();\n\n\t\t\tconst activationResult = await gsm.playerActivatesAbility(\n\t\t\t\tP1,\n\t\t\t\tcharObject.objectId,\n\t\t\t\tabilityToActivate!.abilityId\n\t\t\t);\n\t\t\texpect(activationResult.success).toBe(true);\n\n\t\t\t// Assertion: The character has StatusType.Exhausted.\n\t\t\t// The cost payment ({ type: 'exhaustSelf' }) should apply this status.\n\t\t\texpect(charObject.statuses.has(StatusType.Exhausted)).toBe(true);\n\t\t});\n\n\t\ttest('Rule 2.4.1.f: Cannot gain an existing status (Asleep)', async () => {\n\t\t\tconst player = gsm.getPlayer(P1)!;\n\t\t\tconst charObject = gsm.objectFactory.createGameObject(\n\t\t\t\tgsm.objectFactory.createCardInstance(cardDef_NormalChar.id, P1),\n\t\t\t\tP1\n\t\t\t);\n\t\t\tplayer.zones.expeditionZone.add(charObject);\n\t\t\tcharObject.statuses.add(StatusType.Asleep); // Pre-set Asleep status\n\t\t\texpect(charObject.statuses.has(StatusType.Asleep)).toBe(true);\n\n\t\t\t// Action: Apply an effect that grants StatusType.Asleep.\n\t\t\t// This requires a mechanism to apply a status via an effect.\n\t\t\t// Let's simulate this by directly calling a status adding function that respects 2.4.1.f.\n\t\t\t// gsm.statusHandler.addStatus(charObject, StatusType.Asleep);\n\t\t\t// If addStatus is idempotent or has specific \"becomes Asleep\" logic, this tests it.\n\t\t\t// For now, we'll assume the add method is simple. The rule implies no \"new\" gaining event.\n\n\t\t\t// To test \"does not trigger 'becomes Asleep' logic again\", we'd need to spy on an event/handler.\n\t\t\t// Since we can't do that easily here, we assert the state remains correct.\n\t\t\t// The core of 2.4.1.f is that you can't \"stack\" the same status or re-trigger \"gains X\" for it.\n\t\t\tcharObject.statuses.add(StatusType.Asleep); // Attempt to add it again\n\t\t\tlet asleepCount = 0;\n\t\t\tcharObject.statuses.forEach((s) => {\n\t\t\t\tif (s === StatusType.Asleep) asleepCount++;\n\t\t\t});\n\t\t\texpect(asleepCount).toBe(1); // Still just one instance of Asleep\n\n\t\t\texpect(charObject.statuses.has(StatusType.Asleep)).toBe(true);\n\t\t});\n\n\t\ttest('Rule 2.4.1.h: Cannot lose a non-existing status (Asleep)', async () => {\n\t\t\tconst player = gsm.getPlayer(P1)!;\n\t\t\tconst charObject = gsm.objectFactory.createGameObject(\n\t\t\t\tgsm.objectFactory.createCardInstance(cardDef_NormalChar.id, P1),\n\t\t\t\tP1\n\t\t\t);\n\t\t\tplayer.zones.expeditionZone.add(charObject);\n\t\t\texpect(charObject.statuses.has(StatusType.Asleep)).toBe(false); // Not Asleep\n\n\t\t\t// Action: Apply an effect that removes StatusType.Asleep.\n\t\t\t// gsm.statusHandler.removeStatus(charObject, StatusType.Asleep);\n\t\t\t// Similar to the above, testing \"does not trigger 'loses Asleep' logic\" is hard without spies.\n\t\t\t// We ensure the state remains correct.\n\t\t\tcharObject.statuses.delete(StatusType.Asleep); // Attempt to remove it\n\n\t\t\texpect(charObject.statuses.has(StatusType.Asleep)).toBe(false);\n\t\t});\n\t});\n\n\t// --- Tests for Effects of Statuses ---\n\tdescribe('Effects of Statuses', () => {\n\t\ttest('Rule 2.4.5.c: Cannot play an Exhausted card from Reserve', async () => {\n\t\t\tconst player = gsm.getPlayer(P1)!;\n\t\t\tconst cardInst = gsm.objectFactory.createCardInstance(cardDef_NormalChar.id, P1);\n\t\t\t// Manually set Exhausted for this test setup in Reserve\n\t\t\t// In a real game, it might become Exhausted in Reserve through other means (e.g. effect)\n\t\t\tconst cardAsObject = gsm.objectFactory.createGameObject(cardInst, P1); // Create a temporary game object to add status\n\t\t\tcardAsObject.statuses.add(StatusType.Exhausted);\n\t\t\tplayer.zones.reserveZone.add(cardAsObject); // Add the object with status to reserve\n\n\t\t\tplayer.currentMana = cardDef_NormalChar.reserveCost!.total;\n\n\t\t\t// Action: Attempt to play this Exhausted character from Reserve\n\t\t\tconst playResult = await gsm.playerPlaysCardFromHand(P1, cardInst.instanceId, {\n\t\t\t\tfromZone: ZoneIdentifier.Reserve\n\t\t\t});\n\n\t\t\t// Assertion: Play action fails or is invalid\n\t\t\texpect(playResult.success).toBe(false);\n\t\t\tconst charInReserve = player.zones.reserveZone.findById(cardInst.instanceId);\n\t\t\texpect(charInReserve).toBeDefined(); // Card remains in Reserve\n\t\t\texpect(charInReserve?.statuses.has(StatusType.Exhausted)).toBe(true); // Still Exhausted\n\n\t\t\tconst charInExpedition = gsm.findCardInAnyZone(\n\t\t\t\tcardInst.instanceId,\n\t\t\t\tZoneIdentifier.Expedition\n\t\t\t);\n\t\t\texpect(charInExpedition).toBeUndefined(); // Not in expedition\n\t\t});\n\n\t\ttest('Rule 2.4.5.e: Support ability of an Exhausted card in Reserve cannot be used', async () => {\n\t\t\tconst player = gsm.getPlayer(P1)!;\n\t\t\tconst cardInst = gsm.objectFactory.createCardInstance(cardDef_CharWithSupportAbility.id, P1);\n\t\t\tconst cardObject = gsm.objectFactory.createGameObject(cardInst, P1);\n\t\t\tcardObject.statuses.add(StatusType.Exhausted); // Manually set Exhausted\n\t\t\tplayer.zones.reserveZone.add(cardObject);\n\n\t\t\tconst supportAbility = cardObject.definition.abilities.find(\n\t\t\t\t(a) => a.abilityType === 'support'\n\t\t\t);\n\t\t\texpect(supportAbility).toBeDefined();\n\n\t\t\t// Action: P1 attempts to activate the support ability\n\t\t\t// Assuming playerActivatesAbility checks for valid source object state (not Exhausted in Reserve for support)\n\t\t\tconst activationResult = await gsm.playerActivatesAbility(\n\t\t\t\tP1,\n\t\t\t\tcardObject.objectId,\n\t\t\t\tsupportAbility!.abilityId\n\t\t\t);\n\n\t\t\t// Assertion: Activation fails\n\t\t\texpect(activationResult.success).toBe(false);\n\t\t\t// Any effects of the ability (e.g. drawing a card) should not have happened.\n\t\t\t// (This would be more robust with an initial hand size check if the ability drew cards)\n\t\t});\n\t});\n\n\t// --- Tests for Losing Statuses ---\n\tdescribe('Losing Statuses', () => {\n\t\ttest('Rule 4.2.1.c: Exhausted characters/cards become ready during Prepare phase', async () => {\n\t\t\tconst player = gsm.getPlayer(P1)!;\n\n\t\t\t// Setup Exhausted character in Expedition\n\t\t\tconst charInExpInst = gsm.objectFactory.createCardInstance(cardDef_NormalChar.id, P1);\n\t\t\tconst exhaustedCharInExp = gsm.objectFactory.createGameObject(charInExpInst, P1);\n\t\t\texhaustedCharInExp.statuses.add(StatusType.Exhausted);\n\t\t\tplayer.zones.expeditionZone.add(exhaustedCharInExp);\n\t\t\texpect(exhaustedCharInExp.statuses.has(StatusType.Exhausted)).toBe(true);\n\n\t\t\t// Setup Exhausted card (as object to hold status) in Reserve\n\t\t\tconst cardInReserveInst = gsm.objectFactory.createCardInstance(\n\t\t\t\tcardDef_CharWithTapAbility.id,\n\t\t\t\tP1\n\t\t\t); // Using a different card for variety\n\t\t\tconst exhaustedCardInReserve = gsm.objectFactory.createGameObject(cardInReserveInst, P1);\n\t\t\texhaustedCardInReserve.statuses.add(StatusType.Exhausted);\n\t\t\tplayer.zones.reserveZone.add(exhaustedCardInReserve);\n\t\t\texpect(exhaustedCardInReserve.statuses.has(StatusType.Exhausted)).toBe(true);\n\n\t\t\t// Action: Trigger Prepare phase (or the part of it that readies cards)\n\t\t\t// This assumes preparePhase correctly calls the logic to remove Exhausted status.\n\t\t\t// Rule 4.2.1.c: \"All Exhausted cards its controller owns in their Expedition zone and Reserve zone lose Exhausted.\"\n\t\t\tawait gsm.preparePhase(); // This method should iterate and remove Exhausted status\n\n\t\t\t// Assertion\n\t\t\tconst charAfterPrepare = player.zones.expeditionZone.findById(exhaustedCharInExp.objectId);\n\t\t\texpect(charAfterPrepare).toBeDefined();\n\t\t\texpect(charAfterPrepare?.statuses.has(StatusType.Exhausted)).toBe(false);\n\n\t\t\tconst cardAfterPrepare = player.zones.reserveZone.findById(exhaustedCardInReserve.objectId);\n\t\t\texpect(cardAfterPrepare).toBeDefined();\n\t\t\texpect(cardAfterPrepare?.statuses.has(StatusType.Exhausted)).toBe(false);\n\t\t});\n\t});\n});\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/app/tests/unit/setup.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	}
]
